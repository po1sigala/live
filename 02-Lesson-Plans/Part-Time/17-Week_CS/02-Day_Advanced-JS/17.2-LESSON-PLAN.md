# 17.2 Part-Time Lesson Plan: Computer Science for JavaScript

## Overview 

In today's class, students will take a dive deep into what JavaScript does under the hood. First, they'll learn about higher-order functions and how to implement them. Then they'll explore closures, including how to leverage them using factory functions. Students will also learn about the difference between inheritance and a composition-based approach to designing an application. Finally, students will be introduced to a new way to delegate events using closures.

## Instructor Notes

* In this lesson, students will complete activities `11-Ins_Higher-Order-Functions` through `20-Stu_Event-Delegation-Handling`.

* Be sure to review the activities before class and try to anticipate any questions that students might have.

* This class deals with some abstract topics, so it's important to start a dialogue and keep the conversation going so that students can better grasp these topics and feel comfortable asking questions.

* Closures are a large part of the day's activities. If you are feeling a little unsure about them, take some time to become more familiar with them before class.

* In `13-Ins_Closures`, we use `console.dir`. Encourage students to learn about it on their own time, as we will only be using it for demonstration purposes.

* The `17-Ins_Factory-Vs-Constructor` demo might take longer than five minutes, but the previous and subsequent activities should take less time. It's important to take the time to talk about the code while live-coding the demo for this particular activity.

* We will use jest in a couple of the activities, so make sure students use `npm test` when prompted.

* Remind students to do a `git pull` of the class repo and to have today's activities ready and open in VS Code. 

* If you are comfortable doing so, live-code the solutions to the activities. If not, just use the solutions provided and follow the prompts and talking points for review.

* Let students know that the Bonus at the end of each activity is not meant to be extra coding practice, but instead is a self-study on topics beyond the scope of this unit for those who want to further their knowledge.

## Learning Objectives

By the end of class, students will be able to:

* Construct their own higher-order functions.

* Explain the lexical environment.

* Identify encapsulated variables.

* Create a factory function.

* Distinguish the difference between inheritance and composition design.

## Time Tracker
| Start  | #   | Activity Name                                        | Duration |
|---     |---  |---                                                   |---       |
| 6:30PM | 1   | Instructor Do: Stoke Curiosity                       | 0:10     |
| 6:40PM | 2   | Instructor Demo: Higher-Order Functions              | 0:05     |
| 6:45PM | 3   | Student Do: Higher-Order Functions                   | 0:15     |
| 7:00PM | 4   | Instructor Review: Higher-Order Functions            | 0:10     |
| 7:10PM | 5   | Instructor Demo: Closures                            | 0:05     |
| 7:15PM | 6   | Student Do: Closures                                 | 0:15     |
| 7:30PM | 7   | Instructor Review: Closures                          | 0:10     |
| 7:40PM | 8   | Instructor Demo: Factory Functions                   | 0:05     |
| 7:45PM | 9   | Student Do: Factory Functions                        | 0:15     |
| 8:00PM | 10  | BREAK                                                | 0:15     |
| 8:15PM | 11  | Instructor Review: Factory Functions                 | 0:10     |
| 8:25PM | 12  | Instructor Demo: Constructor vs. Factory functions    | 0:05     |
| 8:30PM | 13  | Student Do: Constructor vs. Factory Functions         | 0:15     |
| 8:45PM | 14  | Instructor Review: Constructor vs. Factory Functions  | 0:10     |
| 8:55PM | 15  | Instructor Demo: Event Delegation and Handling         | 0:05     |
| 9:00PM | 16  | Student Do: Event Delegation and Handling              | 0:15     |
| 9:15PM | 17  | Instructor Review: Event Delegation and Handling       | 0:15     |
| 9:30PM | 18  | END                                                  | 0:00     |

---

## Class Instruction

### 1. Instructor Do: Stoke Curiosity (10 min)

* Welcome students to class.

* Ask the class the following questions (â˜ï¸) and call on students for the answers (ğŸ™‹):

  * â˜ What is a paradigm in programming?
  
  * ğŸ™‹ A paradigm a style or philosophy that a programming language follows.

  * â˜ï¸ What is object-oriented programming (OOP)?

  * ğŸ™‹ OOP is a programming paradigm that JavaScript uses. In OOP, we model the data around objects.

  * â˜ï¸ What other paradigms does JavaScript use?

  * ğŸ™‹ Functional and procedural.

* Explain that we will be learning about the technical portion of the interview process, with a focus on the functional paradigm of JavaScript.

  * â˜ï¸ In JavaScript, how else can we create objects?

  * ğŸ™‹ With classes and constructor functions.

  * â˜ï¸ What are some problems that may occur when using class inheritance?

  * ğŸ™‹ The larger the app becomes, the more difficult it can be to restructure the class hierarchy.
  
* Explain to students that we will be learning an entirely new way to build objects by using factory functions.

* Let students know ahead of time that these topics can get abstract and encourage them to ask questions.

* JavaScript has many layers, and interviewers want to know how well a candidate understands them. 

* In JavaScript, we have a design choice to make early on that will dictate if we use inheritance or composition.

* JavaScript uses three different paradigms and it is important as developers that we understand each one and how to leverage them to our benefit.

* Let students know that this knowledge comes with time and practice, and to not fall into that sinking feeling of imposter syndrome.They have been using these concepts all along and now we are just expanding on that knowledge.

### 2. Instructor Demo: Higher-Order Functions (5 min) 

* Open `11-Ins_Higher-Order-Functions/index.js` in your IDE and explain the following:

  * We first create a function that we will be using to pass into the JavaScript provided higher-order function, `.map()`.

  * We have access to the element and the index of the element which is provided to us through the `.map()` method.

    ```js
    function evenIndexMultiplier(number, index) {
      // Code...
    }
    ```
  
  * Next, we create the logic for the function that will be passed into the higher-order function, the `.map()` method.

    ```js
    function evenIndexMultiplier(number, index) {
    
      if (index % 2 === 0) {
    
        return number * 10;

      }

      return number;
    }
    ```

  * ğŸ”‘ Finally, we pass the newly created function into the `.map()` method and storing it into a variable named `evenIndexes`.
  
  * ğŸ”‘ Now we have a function which accepts another function as an argument, creating a higher-order function.

  * ğŸ”‘ We are not limited to only using `evenIndexMultiplier` inside the `.map()` method. We can use `evenIndexMultiplier` anywhere in the application or even in a custom higher-order function.

    ```js
    const evenIndexes = arrayIndex.map(evenIndexMultiplier);

    ```

* Run `node index.js` from the command line and demonstrate the following: 

  * As we can see every even index is being multiplied by ten which is exactly what the function was meant to do.

  ```
  [10, 52, 350, 6, 720, 7, 30, 19, 320, 54, 780, 95, 970]
  ```

* Ask the class the following questions (â˜ï¸) and call on students for the answers (ğŸ™‹):

  * â˜ï¸ How can we use higher-order functions to our benefit?

  * ğŸ™‹ It makes our code more reusable.

  * â˜ï¸ Are we limited to using a higher-order function provided by JavaScript?

  * ğŸ™‹ No, we can create our own. The function just needs to be able to accept another function for an argument.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `12-Stu_Higher-Order-Functions/README.md`.

### 3. Student Do: Higher-Order Functions (15 min) 

* Direct students to the activity instructions found in `12-Stu_Higher-Order-Functions/README.md`.

* Break your students into pairs that will work together on this activity.

  ```md
  # ğŸ—ï¸ Create a Function to Pass into the Reducer Method That Finds the Average of an Array of Numbers

  Work with a partner to implement the following user story:

  * As a teacher, I want to be able to find the average grade of my entire class.

  * As a developer, I want to be able to reuse my `findAverage` function in multiple filter method calls throughout my application so that my code is not being duplicated unnecessarily.

  ## Acceptance Criteria

  * It's done when the `findAverage` function correctly calculates the average of an array of numbers.

  * It's done when the `findAverage` function is being correctly passed through the `.reduce()` method.

  ## ğŸ’¡ Hints

  How do you find out how many elements are in an array? 

  ## ğŸ† Bonus

  If you have completed this activity, work through the following challenge with your partner to further your knowledge:

  * What other built-in functions are also higher-order functions? 

  Use [Google](https://www.google.com) or another search engine to research this.

  ```

* While breaking everyone into groups, be sure to remind students and instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students who need extra help.

### 4. Instructor Review: Higher-Order Functions (10 min) 

* Ask the class the following questions (â˜ï¸) and call on students for the answers (ğŸ™‹):

  * â˜ï¸ How comfortable do you feel with higher-order functions? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help!

* Use the prompts and talking points (ğŸ”‘) below to review the following key points:

  * âœ”ï¸ Accepting another function as an argument

  * âœ”ï¸ `.reduce()`

* Open `12-Stu_Higher-Order-Functions/Solved/index.js` in your IDE and explain the following: 

  * We create a function named `findAverage` that has access to four arguments: `accumulator`, `currentValue`, `index`, and `array`.

  * ğŸ”‘ We have access to these arguments because they are provided to us through the `.reduce()` method.

    ```js
    function findAverage(accumulator, currentValue, index, array) {
      // Code...
    }
    ```

  * Check to see if we are at the final index of the given array.

  * If so, we return the total plus the current value and divide it by how many elements are in the array. 
  
    ```js
    function findAverage(accumulator, currentValue, index, array) {
    
      if (index === array.length - 1) {
    
      return (accumulator + currentValue) / array.length;
      }
    }
    ```
    
  * If we have not reached the end of the array, add the total to the current value we are on. 
  
    ```js
    function findAverage(accumulator, currentValue, index, array) {
    
      if (index === array.length - 1) {
    
        return (accumulator + currentValue) / array.length;
      }

  
      return accumulator + currentValue;
    }
    ```
  
  * ğŸ”‘ Pass the newly created `findAverage` function into the `.reduce()` method.

    ```js
    let gradeAverage = grades.reduce(findAverage);
    ```

* Run `node index.js` from the command line and demonstrate the following:

  * ğŸ”‘ Inside the `console`, we should see the correct average being displayed.

    ```
    [79.5]
    ```

* Ask the class the following questions (â˜ï¸) and call on students for the answers (ğŸ™‹):

  * â˜ï¸ What are some other JavaScript methods that are higher-order functions?

  * ğŸ™‹ `.filter()` `.forEach()`

  * â˜ï¸ What can we do if we don't completely understand this?

  * ğŸ™‹ We can refer to supplemental material, read the [MDN Web Docs on functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions), and stay for office hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 5. Instructor Demo: Closures (5 min) 

* Open `13-Ins_Closures/index.js` in your IDE and explain the following:

  * ğŸ”‘ We first create a function named `bankAccount`, which will be the outer function, and create a closure around the soon-to-exist inner function:

    ```js
    function bankAccount() {
      // Code...
    }
    ```

  * Next, we create two variables inside the outer function, which will be scoped to the inner function that we will be creating.

    ```js
    function bankAccount() {
    
      const checking = 400;

      const savings = 1000;
     }
    ```
  
  * ğŸ”‘ To use a closure, the function must return an object with some type functionality, whether it be one method or multiple.

    ```js
    function bankAccount() {
    
      const checking = 400;

      const savings = 1000;

      return {
        displayFunds: function () {

          // Code...
      
        },
      };
    }
    ```

  * Inside the object being returned, we create a `displayFunds` method that logs the `checking` and `savings` variables.

    ```js
    function bankAccount() {
    
      const checking = 400;

      const savings = 1000;

      return {

        displayFunds: function () {

          console.log(
            `You have $${checking} in your checking account and $${savings} in your savings account`
          );

        },
      };
    }
    ```

  * Let's store the `bankAccount` function inside a variable and test what happens when we call the `displayFunds()` method.

    ```js
    const myBank = bankAccount();

    myBank.displayFunds()
    ```

* Run `node index.js` from the command line and explain the following:
  
  * ğŸ”‘ In the console, we can see that the `displayFunds()` method has access to the `bankAccount()` function's lexical environment. 

      ```
      You have $400 in your checking account and $1000 in your savings account
      ```

  * The next statement we will see is from `console.dir`. Feel free to look up what `console.dir` does, but we are only using it for demonstration purposes.

    ```js
    console.dir(myBank)
    ```

  * ğŸ”‘ By doing this, we can inspect the scope of the `displayFunds()` method and see that it does have a closure with a reference to the two variables in the outer functions' lexical environment.

  * Another interesting thing to point out is that the function is also an object.

    ```
    Object
      displayFunds: Æ’ ()
        arguments: null
        caller: null
        length: 0
        name: "displayFunds"
        prototype: {constructor: Æ’}
        __proto__: Æ’ ()
        [[FunctionLocation]]: Closures.js:24
        [[Scopes]]: Scopes[3]
          0: Closure (bankAccount)
            checking: 400
            savings: 1000
          1: Script {myBank: {â€¦}}
          2: Global {window: Window, self: Window, document: document, name: "", location: Location, â€¦}
      __proto__: Object
    ```

  * ğŸ”‘ For the final two statements, we can see that the variables inside the `bankAccount()` function are not accessible from outside the function's lexical environment.

    ```
    undefined
    undefined
    ``` 

* Ask the class the following questions (â˜ï¸) and call on students for the answers (ğŸ™‹):

  * â˜ï¸ Can we access a function's variable from outside of its scope?

  * ğŸ™‹ No, we have to be inside its lexical environment.

  * â˜ï¸ How do we use a closure?

  * ğŸ™‹ Returning an inner function that has access to the outer function's lexical environment.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `14-Stu_Closures/README.md`.

### 6. Student Do: Closures (15 min) 

* Direct students to the activity instructions found in `14-Stu_Closures/README.md`.

* Break your students into pairs that will work together on this activity.

  ```md
  # ğŸ—ï¸ Create a Counter Function That Uses a Private Variable

  Work with a partner to implement the following user story:

  * As a teacher, I want a way to keep track of the number of students I see every day.

  * As a developer, I want to keep my `count` variable data private.

  ## Acceptance Criteria

  * It's done when the `Counter` function correctly increments by 1.

  * It's done when I can only access the `count` variable from within the `Counter` function.

  * It's done when all of the unit tests pass using `npm test`.

  ## ğŸ’¡ Hints

  When is a closure created? 

  ## ğŸ† Bonus

  If you have completed this activity, work through the following challenge with your partner to further your knowledge:

  * What is the lexical environment? 

  Use [Google](https://www.google.com) or another search engine to research this.

  ```

* While breaking everyone into groups, be sure to remind students and instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students who need extra help.

### 7. Instructor Review: Closures (10 min) 

* Ask the class the following questions (â˜ï¸) and call on students for the answers (ğŸ™‹):

  * â˜ï¸ How comfortable do you feel with closures? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help!

* Use the prompts and talking points (ğŸ”‘) below to review the following key points:

  * âœ”ï¸ Closures

  * âœ”ï¸ Private variables

  * âœ”ï¸ Lexical environment

* Open `14-Stu_Closures/Solved/index.js` in your IDE and explain the following: 

  * ğŸ”‘ By creating the function `counter`, we have also created a closure.

    ```js
    function counter() {
      // Code...
    }
    ```
 
  * ğŸ”‘ Inside the outer function, we create a private `count` variable that will hold the number of times the function is called.

    ```js
    function counter() {

      let count = 0;
    }
    ```

  * ğŸ”‘ Next, we use the closure by returning an object by using the `increment` method, which increases the `count` by one.

    ```js
    function counter() {
    
      let count = 0;

      return {

        increment: function () {
        
          return count++;
        },
      };
    }
    ```

  * If we type `npm test` in the command line, we should see the following:

    ```bash
      PASS  __tests__/index.test.js
      âˆš counter is a defined function (2 ms)
      âˆš counter is returning as an object
      âˆš count should equal 0 (1 ms)
      âˆš count should equal 1
      âˆš count should equal 4

    Test Suites: 1 passed, 1 total
    Tests:       5 passed, 5 total
    Snapshots:   0 total
    Time:        1.974 s
    ```

* Ask the class the following questions (â˜ï¸) and call on students for the answers (ğŸ™‹):

  * â˜ï¸ How else could we use closures?

  * ğŸ™‹ We could conceal sensitive variables that shouldn't be mutated outside of the function's scope.

  * â˜ï¸ What can we do if we don't completely understand this?

  * ğŸ™‹ We can refer to supplemental material, read the [MDN Web Docs on closures](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures), and stay for office hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 8. Instructor Demo: Factory Functions (5 min) 

* Open `15-Ins_Factory-Functions/index.js` in your IDE and explain the following:

  * We create a function that accepts three arguments: `name`, `age`, and `city`.

    ```js
    function createUser(name, age, city) {
      // Code...
    }
    ```

  * Factory functions are similar to JavaScript classes.

  * ğŸ”‘ Instead of using a `constructor()` and binding the arguments to `this`, we create an object inside the function that holds our arguments.

  * ğŸ”‘ Because we don't have a `constructor()` function, `this` refers to the parent object.

    ```js
    function createUser(name, age, city) {

      let user = {
        name: name,
        age: age,
        city: city
      }

    }
    ```

  * ğŸ”‘ Factory functions use closures to encapsulate variables, making it difficult to mutate the data from outside of the function scope.

  * For us to leverage closures, we need to return an object with a method inside of it. We return two, `introduceSelf()` and `location()`.

    ```js
    function createUser(name, age, city) {

      let user = {
        name: name,
        age: age,
        city: city
      }

        return {

          introduceSelf: function() {
              // Code...
          },

          location: function() {
              // Code...
          }
      }
    }
    ```

  * Inside both of the methods, we `console.log` the user using the object we created with dot notation instead of `this`.

    ```js
    function createUser(name, age, city) {

      let user = {
        name: name,
        age: age,
        city: city
      }

        return {

          introduceSelf: function() {
            
            return console.log(`Hi my name is ${user.name} and I am currently ${user.age} years old!`)
          },

          location: function() {

            return console.log(`${user.name} is located in ${user.city}`)
          }
      }
    }

    ```

  * ğŸ”‘ This is similar to JavaScript classes except that we no longer need the `new` keyword; instead, we use the `createUser` factory function to create a user.

  ```js
  const userOne = createUser('Beverly', 58, 'Phoenix')
  ```

* Run `node index.js` from the command line and demonstrate the following:
  
  * As we can see, the new user we created works as expected, without using a JavaScript class.

  * ğŸ”‘ The new user has a reference to the `createUser` function which has the data we want encapsulated in it.

  * All of this is done using closures.

    ```
    Hi my name is Beverly and I am currently 58 years old!
    Beverly is located in Phoenix
    ```

* Ask the class the following questions (â˜ï¸) and call on students for the answers (ğŸ™‹):

  * â˜ï¸ Inside a factory function, what does `this` refer to?

  * ğŸ™‹ The parent object.

  * â˜ï¸ Do we need to use the `new` keyword with factory functions?

  * ğŸ™‹ No, we can forgo it entirely. 

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `16-Stu_Factory-Functions/README.md`.

### 9. Student Do: Factory Functions (15 min) 

* Direct students to the activity instructions found in `16-Stu_Factory-Functions/README.md`.

* Break your students into pairs that will work together on this activity.

  ```md
  # ğŸ› Factory Function Returns Undefined Values When the Inner Function Is Called

  Work with a partner to resolve the following issue(s):

  * As a developer, I want the inner function of my factory function to correctly log the variables when called.

  ## Expected Behavior

  When a user calls the `greet` method on the `Student` function, the values should be correctly displayed in the console.

  ## Actual Behavior

  When a user calls the `greet` method on the `Student` function, they see undefined values instead of the `name` and `gradeYear`.
  
  ## Steps to Reproduce the Problem

  1. Create a new student variable and assign it to the `Student` function. 

  2. Call the `greet` method on the newly created student variable.

  3. Check the console to see undefined values.

  4. Run `npm test` to check if all unit test pass.

  ## ğŸ’¡ Hints

  What is the context of `this` when inside a factory function? 

  ## ğŸ† Bonus

  If you have completed this activity, work through the following challenge with your partner to further your knowledge:

  * Is the `new` keyword required when using a factory function? 

  Use [Google](https://www.google.com) or another search engine to research this.

  ```

* While breaking everyone into groups, be sure to remind students and instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students who need extra help.

### 10. BREAK (15 min)

### 11. Instructor Review: Factory Functions (10 min) 

* Ask the class the following questions (â˜ï¸) and call on students for the answers (ğŸ™‹):

  * â˜ï¸ How comfortable do you feel with factory functions? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help!

* Use the prompts and talking points (ğŸ”‘) below to review the following key points:

  * âœ”ï¸ Factory functions

  * âœ”ï¸ `new`

  * âœ”ï¸ `this`

* Open `16-Stu_Factory-Functions/Solved/index.js` in your IDE and explain the following: 

  * We create a new function and store its two arguments `name` and `gradeYear` inside a newly created object named `student`.

    ```js
    function Student(name, gradeYear) {
    
      let student = {
        name: name,
        gradeYear: gradeYear,
      };

    }
    ```

  * Remember, `this` is being bound to the parent object instead of the new one being created.

  * ğŸ”‘ If we want to access the `name` and `gradeYear`, we must use the student object we stored it in.

    ```js
    function Student(name, gradeYear) {
    
      let student = {
        name: name,
        gradeYear: gradeYear,
      };

      return {
      
        greet: function () {

          console.log(
            `My name is ${student.name} and I am in ${student.gradeYear} grade`
          );

        },
      };
    }
    ```

  * ğŸ”‘ Now we create a new student with the `Student` factory function without using the `new` keyword.

    ```js
    const newStudent = Student('Dominique', '11th');
    ```
    
  * If we type `npm test` in the command line, we should see the following:

    ```bash
    Test Suites: 1 passed, 1 total
    Tests:       4 passed, 4 total
    Snapshots:   0 total
    Time:        1.924 s
    ```

* Ask the class the following questions (â˜ï¸) and call on students for the answers (ğŸ™‹):

  * â˜ï¸ Do we use a `constructor()` function inside a factory function?

  * ğŸ™‹ No.

  * â˜ï¸ What can we do if we don't completely understand this?

  * ğŸ™‹ We can refer to supplemental material, read the [MDN Web Docs on closures](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures), and stay for office hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 12. Instructor Demo: Factory vs. Constructor (5 min) 

* Open `17-Ins_Factory-Vs-Constructor/constructor.js` in your IDE and explain the following:

  * Now we'll step back and look at how we've been creating classes in JavaScript so far.

  * This application will have a simple `Device` class and a `Phone` class that `extends` from it.

    ```js
    class Device {
        constructor(name){
            this.name = name
        }

        takePicture() {
            console.log(`Taking picture with ${this.name}`)
        }
    }

    class Phone extends Device {
        constructor(name, ringTone) {
            super(name) 
            this.ringTone = ringTone
        }

        call() {
            console.log(`Phone: ${this.ringTone}`)
        }
    }
    ```

  * Now we have a basic class tree. The `Phone` can `call`, and it inherits the `takePicture` method from the `Device` class.

    ```js
    const nokia = new Phone('Nokia', 'ring')
    nokia.call()
    nokia.takePicture()
    console.log(nokia)
    ```

  * If we run this in Node.js, we can see that it is working like we expected.

    ```
    Phone: ring
    Taking picture with Nokia
    ```

  * Next, we'll have a quick refresher on how the prototype chain works with classes by inspecting the `Nokia` variable we created.

  * ğŸ”‘ By looking at the `__proto__` object, we can see the reference to the `Device`, which holds the `takePicture` method that the `Phone` class inherits.

    ```
    Phone {name: "Nokia", ringTone: "ring"}
      name: "Nokia"
      ringTone: "ring"
      __proto__: Device
        call: Æ’ call()
        constructor: class Phone
        __proto__:
          constructor: class Device
          takePicture: Æ’ takePicture()
          __proto__: Object
    ```

  * In this application, we create two more classes: `Appliance` and `Dryer`, which extends from `Appliance`.

  * Like earlier, they each have a method and some type of data stored.

    ```js
    class Appliance {
        constructor(noise){
            this.noise = noise
        }

        makeNoise() {
            console.log(this.noise)
        }
    }

    class Dryer extends Appliance {
        constructor(noise) {
            super(noise)

        }

        dry() {
            console.log(`Dryer is on: ${this.noise}`);
        }
    }

      ``` 

  * The `Phone` class inherits from the `Device` class, and the `Dryer` class inherits from the `Appliance` class.
  
  * With the current class hierarchy, it would be difficult to create an `Appliance` that could make a `call` without rewriting the `call` method.

  * ğŸ”‘ Having to rewrite logic violates the DRY (Don't Repeat Yourself) principle of programming.

  * ğŸ”‘ This can quickly get out of control if we decide to make additional changes similar to this one.

* Open `17-Ins_Factory-Vs-Constructor/factory-functions.js` in your IDE and explain the following:

  * Let's look at how we can take a composition-based approach with factory functions.

  * ğŸ”‘ We create factory functions that accept `state` as an argument and return a method that uses the information provided through the `state`.

  * We can think of state as an object that stores information that the function needs.
    
    ```js
    const phoneCall = (state) => ({
      call: () => console.log(`${state.name}'s Phone: ${state.ringTone}`),
    });

    const makeNoise = (state) => ({
      noise: () => console.log(state.noise),
    });

    const drying = (state) => ({
      dry: () =>
        console.log(`Finish drying in ${state.timer} minutes. ${state.noise}`),
    });

    ```

  * ğŸ”‘ Create a function named `Phone` which receives the `name` and `ringTone` that we will store in an object named `state`.

    ```js
    const Phone = (name, ringTone) => {
    
      const state = {
        name,
        ringTone
      };
    };
    ```

  * ğŸ”‘ Let's return an object, using the `...` operator and the action function, passing in the `state` to it.

    ```js
    const Phone = (name, ringTone) => {
    
      const state = {
        name,
        ringTone
      };

      return { ...phoneCall(state) };
    };
    ```

  * Using the same logic, let's create `Dryer` and `Washer` factory functions.

    ```js
    const Dryer = (noise, timer) => {

      const state = {
        noise,
        timer
      };

      return { ...makeNoise(state), ...drying(state) };
    };

    const Washer = (name, noise, ringTone) => {

      const state = {
        name,
        noise,
        ringTone
      };

      return { ...makeNoise(state), ...phoneCall(state) };
    };
    ```

  * We will test out the new factory functions to see if they work as expected.

    ```js
    // No need to add the `new` keyword because we are using a factory function.
    const nokia = Phone('Nokia', 'ring');
    const decker = Dryer('brshhuhsh', 35);
    const wPool = Washer('Whirlpool', 'brshhh', 'ring ring from the washer');
    // Test if the action functions work correctly with the newly created phone.
    nokia.call();
    decker.noise();
    decker.dry();
    wPool.call();
    wPool.noise();
    ```

  * If we run this in Node.js, we can see that it is working as expected.

  * ğŸ”‘ With **inheritance**, we design types based on what they are. With **composition**, we design types based on what they do.

    ```
    Nokia's Phone: ring
    brshhuhsh
    Finish drying in 35 minutes. brshhuhsh
    Whirlpool's Phone: ring ring from the washer
    brshhh
    ```

* Ask the class the following questions (â˜ï¸) and call on students for the answers (ğŸ™‹):

  * â˜ï¸ What happens if we want to create an appliance that can make a phone call?

  * ğŸ™‹ We would have to make a new `call` method on the `Appliance`.

  * â˜ï¸ What is the difference between inheritance and composition design?

  * ğŸ™‹ Inheritance is based on what types are. Composition is based on what types do.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `18-Stu_Factory-Vs-Constructor/README.md`.

### 13. Student Do: Factory vs. Constructor (15 min)

* Direct students to the activity instructions found in `18-Stu_Factory-Vs-Constructor/README.md`.

* Break your students into pairs that will work together on this activity.

  ```md
  # ğŸ—ï¸ Refactor the Lesson Class to a Factory Function

  Work with a partner to implement the following user story:

  * As a developer, I want to move away from an inheritance-based approach and start using a composition-based approach so that my application's tree hierarchy is less rigid.

  * As a teacher, I want to be able to add a new lesson with a title and description to the collection of lessons I can teach.

  ## Acceptance Criteria

  * It's done when the `Lesson` class is a factory function, making the application less rigid in case we decide to add new features.

  * It's done when I can call the `information` method on the `Lesson` function and it correctly logs the private variable.

  ## ğŸ’¡ Hints

  What scope does your inner function have access to? 

  ## ğŸ† Bonus

  If you have completed this activity, work through the following challenge with your partner to further your knowledge:

  * What are the three paradigms of JavaScript? 

  Use [Google](https://www.google.com) or another search engine to research this.

  ```

* While breaking everyone into groups, be sure to remind students and instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students who need extra help.

### 14. Instructor Review: Factory vs. Constructor (10 min) 

* Ask the class the following questions (â˜ï¸) and call on students for the answers (ğŸ™‹):

  * â˜ï¸ How comfortable do you feel with factory functions vs. constructor functions? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help!

* Use the prompts and talking points (ğŸ”‘) below to review the following key points:

  * âœ”ï¸ Inheritance

  * âœ”ï¸ Composition

* Open `18-Stu_Factory-Vs-Constructor/Solved/index.js` in your IDE and explain the following: 

  * Create a function named `lesson` and two variables named `title` and `description`inside an object labeled `state`.

    ```js
    const lesson = function () {  
      const state = {
        title: 'Unit 17 - Computer Science',
        description: 'CS for JS',
      };

    };
    ```

  * ğŸ”‘ Instead of creating a method, we will create a function named `getInformation` that accepts the `state` as an argument.

  * We will return an inner function that logs the `title` and `description`.

    ```js
    const getInformation = (state) => ({
      information: () => console.log(state.title, state.description),
    });
    ```

  * Inside the `lesson` function, we must return the action function `getInformation`, passing in the `state` object.

    ```js
    const lesson = function () {  
      const state = {
        title: 'Unit 17 - Computer Science',
        description: 'CS for JS',
      };

      return { ...getInformation(state) };
    };
    ```

  * ğŸ”‘ There is no need to use the `new` keyword with a factory function.

    ```js
    const csForJS = lesson();
    csForJS.information();
    ```

* Ask the class the following questions (â˜ï¸) and call on students for the answers (ğŸ™‹):

  * â˜ï¸ Do factory functions use the `extends` keyword?

  * ğŸ™‹ No, they don't rely on inheritance.

  * â˜ï¸ What can we do if we don't completely understand this?

  * ğŸ™‹ We can refer to supplemental material, read the [Wikipedia article on composition over inheritance](https://en.wikipedia.org/wiki/Composition_over_inheritance), and stay for office hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 15. Instructor Demo: Event Delegation and Handling (5 min) 

* Open `19-Ins_Event-Delegation-Handling/index.html` in your browser and demonstrate the following:

  *  We should see five buttons, each having the label `clicks` followed by a number keeping track of how many times we click.

  *  If we click a button, we should see its respected value increase.

  *  Each button should track its own value.

* Open `19-Ins_Event-Delegation-Handling/index.html` in your IDE and explain the following: 

  * ğŸ”‘ Inside the HTML file, we can see five `<button>` elements inside a `<div>` element with the `id="container"`.

  * Each button has its own `data-count` attribute.

    ```html
      <body>
        <div id="container" style="margin: 5px;">
          <button class="btn btn-lg" data-count="0">Clicks: 0</button>
          <button class="btn btn-lg" data-count="0">Clicks: 0</button>
          <button class="btn btn-lg" data-count="0">Clicks: 0</button>
          <button class="btn btn-lg" data-count="0">Clicks: 0</button>
          <button class="btn btn-lg" data-count="0">Clicks: 0</button>
        </div>
    <script src="assets/js/script.js"></script>
    </body>
    ```

* Open `19-Ins_Event-Delegation-Handling/assets/js/script.js` in your IDE and explain the following: 

  * First we want to select the `container` in which the five buttons are housed.

  * ğŸ”‘ Remember that in event delegation, the event listener is attached to the parent element.

  * When a child element is clicked, the event will bubble up the DOM until it reaches the event listener.

    ```js
    const containerEl = document.getElementById('container');
    ```

  *  Let's create a function that accepts an `event` for an argument.

  *  Next we parse the `data-count` attribute into a number and store it in a `count` variable.

    ```js
    const clickHandler = function(event) {
      let count = parseInt(event.target.getAttribute('data-count'));
    }
    ```

  *  We create an `if...` statement that increases the `count` variable by 1 if the `button` element has been clicked.

  *  Finally, we update the `data-count` attribute and the display so that the correct value is being shown.

    ```js
    const clickHandler = function(event) {

      let count = parseInt(event.target.getAttribute('data-count'));

      if (event.target.matches('button')) {
      
        count++;
      
        event.target.setAttribute('data-count', count);

        event.target.textContent = `Clicks: ${count}`;
      }
    }
    ```

  * ğŸ”‘ The last task is to add an event listener to the container that holds the buttons.

      ```js
      containerEl.addEventListener('click', clickHandler);
      ```

* Ask the class the following questions (â˜ï¸) and call on students for the answers (ğŸ™‹):

  * â˜ï¸ How could we implement a closure to this event handler?

  * ğŸ™‹ We could encapsulate the `count` variable. 

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `20-Stu_Event-Delegation-Handling/README.md`.

### 16. Student Do: Event Delegation and Handling (15 min) 

* Direct students to the activity instructions found in `20-Stu_Event-Delegation-Handling/README.md`.

* Break your students into pairs that will work together on this activity.

  ```md
  # ğŸ“ Add Comments to Implementation of Using Closures for Event Delegation

  Work with a partner to add comments that describe the functionality of the code found in [script.js](./Unsolved/assets/js/script.js).

  ## ğŸ“ Notes

  Refer to the documentation: 
  
  [MDN Web Docs on closures](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures)

  * What is a practical use for closures?

  ---

  ## ğŸ† Bonus

  If you have completed this activity, work through the following challenge with your partner to further your knowledge:

  * Why is it important to minimize the number of variables in the global namespace? 

  Use [Google](https://www.google.com) or another search engine to research this.

  ```

* While breaking everyone into groups, be sure to remind students and instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students who need extra help.

### 17. Instructor Review: Event Delegation and Handling (15 min)

* Ask the class the following questions (â˜ï¸) and call on students for the answers (ğŸ™‹):

  * â˜ï¸ How comfortable do you feel with event handling and delegation using closures? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help!

* Use the prompts and talking points (ğŸ”‘) below to review the following key points:

  * âœ”ï¸ Event delegation

  * âœ”ï¸ Closures

* Open `20-Stu_Event-Delegation-Handling/Solved/assets/js/script.js` in your IDE and explain the following: 

  * ğŸ”‘ Create a variable that holds the `button` element.

  * Instead of selecting the container that holds the buttons, we will select each button individually.

    ```js
    const buttons = document.getElementsByTagName('button');
    ```

  * Let's create a function with a `count` variable set to zero.

    ```js
    const clickHandler = function () {

      let count = 0;

    ```

  * Next, we leverage closures by returning a function that increments the `count` variable by one.

  * The `this` keyword is referring to the `button` element that is being clicked.

    ```js
    const clickHandler = function () {

      let count = 0;

      return function () { 

        count++; 

        this.textContent = `Clicks: ${count}`;
      };
    ```
  
  * We are using a `for...loop` to attach an event listener to each `button` element.

  * ğŸ”‘ Now each button has its own reference to `count` instead of a reference to a global variable or attribute.

  * ğŸ”‘ Instead of doing a costly read on the DOM, we now only read and mutate the private `count` variable.

    ```js
    for (let i = 0; i < buttons.length; i++) {

      buttons[i].addEventListener('click', clickHandler());

    }
    ```

* If we open `20-Stu_Event-Delegation-Handling/Solved/index.html` in the browser, we should see the following:

  * The buttons still work, but now each button leverages closures.

  * ğŸ”‘ We no longer need to rely on the event to bubble up the DOM until it reaches a listener, which avoids costly reads on the DOM.

* Ask the class the following questions (â˜ï¸) and call on students for the answers (ğŸ™‹):

  * â˜ï¸ Do the buttons need to be inside a container to work with closures?

  * ğŸ™‹ No, we attach the event listener to each button, avoiding event bubbling.

  * â˜ï¸ What can we do if we don't completely understand this?

  * ğŸ™‹ We can refer to supplemental material, read the [MDN Web Docs on closures](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures), and stay for office hours to ask for help.

* Answer any questions before ending the class.

### 18. END (0 min)

How did todayâ€™s lesson go? Your feedback is important. Please take 5 minutes to complete this [anonymous survey](https://forms.gle/RfcVyXiMmZQut6aJ6).

---

Â© 2021 Trilogy Education Services, LLC, a 2U, Inc. brand. Confidential and Proprietary. All Rights Reserved.
