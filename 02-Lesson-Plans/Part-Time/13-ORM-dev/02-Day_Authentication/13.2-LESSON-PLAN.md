# 13.2 Part-Time Lesson Plan: Object Relational Mapping (ORM)

## Overview 

In today's class, students will revisit RESTful routes and ensure they respond with proper HTTP status codes. Along with `async / await`, they will incorporate `try / catch` in order to properly catch the errors and return them to the user. Students will incorporate validators to the Sequelize models in order to prevent bad data from being saved into the database. Students will learn about password hashing using `bcrypt`, using hooks, and creating a login route in order for users to securely login. They will create a custom method that cooresponds to a custom route. 

## Instructor Notes

* Complete activities `11-Ins_RESTful-Routes` through `20-Stu_Instance-Method`.

* Be sure to prepare and read over the activities before your class begins. Try to anticipate any questions students may have.

* You will be using MySQL for today's activities. Be sure to have your MySQL server up and running. Go ahead and create the database `user_db` ahead of time, or demonstrate it live in class.

* All of the activities will be using Insomnia Core to test the routes, instead of relying on a front end. Be sure to have it installed and ready for all activities. 

* Remind students to do a `git pull` of the class repo to have today's activities ready and open in VS Code. 

* If you are comfortable doing so, live code the solutions to the activities. If not, no worries. Use the solutions provided and follow the prompts and talking points for review. 

* Let students know that the Bonus for each activity is meant to give them "food for thought". Rather than extra coding practice, it is a self-study on related topics that are beyond the scope of this unit for those who want to dig deeper and further their knowledge on this topic.

## Learning Objectives

By the end of class, students will be able to:

* Ensure routes respond with proper HTTP status code 

* Utilize validation tools on a Sequelize model

* Utilize `bcrypt` to encrypt a password

* Incorporate hooks before and after calls are executed in Sequelize

* Create and run a custom method on a Sequelize instance

## Time Tracker

| Start  | #   | Activity Name                       | Duration |
|---     |---  |---                                  |---       |
| 6:30PM | 1   | Instructor Do: Stoke Curiosity      | 0:10     |
| 6:40PM | 2   | Instructor Demo: RESTful Routes     | 0:05     |
| 6:45PM | 3   | Student Do: RESTful Routes          | 0:15     |
| 7:00PM | 4   | Instructor Review: RESTful Routes   | 0:10     |
| 7:10PM | 5   | Instructor Demo: Validation         | 0:05     |
| 7:15PM | 6   | Student Do: Validation              | 0:15     |
| 7:30PM | 7   | Instructor Review: Validation       | 0:10     |
| 7:40PM | 8   | Instructor Demo: Password Hashing   | 0:05     |
| 7:45PM | 9   | Student Do: Password Hashing        | 0:15     |
| 8:00PM | 10  | BREAK                               | 0:15     |
| 8:15PM | 11  | Instructor Review: Password Hashing | 0:10     |
| 8:25PM | 12  | Instructor Demo: Hooks              | 0:05     |
| 8:30PM | 13  | Student Do: Hooks                   | 0:15     |
| 8:45PM | 14  | Instructor Review: Hooks            | 0:10     |
| 8:55PM | 15  | Instructor Demo: Instance Method    | 0:05     |
| 9:00PM | 16  | Student Do: Instance Method         | 0:15     |
| 9:15PM | 17  | Instructor Review: Instance Method  | 0:15     |
| 9:30PM | 18  | END                                 | 0:00     |

---

## Class Instruction

### 1. Instructor Do: Stoke Curiosity (10 min)

* Welcome students to class.

* The topic of today's lesson is authentication. Using the prompts below, have a discussion about the importance of securing data.

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ In this day and age, it is becoming very important to secure sensitive data. What are some sensitive data that you would like to protect?

  * 🙋 Banking information. Social security number. Tax information. Credit card information.

  * ☝️ On the internet, one of the most important pieces of data you would want to protect is your password. What can happen if your password is compromised?

  * 🙋 Our online accounts can be hacked. Sensitive data will be exposed. Identity theft can happen. 

  * ☝️ Unfortunately, this happens all the time and we hear about data breaches on the news. Can you recall a recent data breach? Or maybe a time when your account was hacked?

  * 🙋 {Answers will vary, but a quick Google search of "data breaches this year" will show a list of businesses that were affected this current year.}

  * ☝️ As a user, that's why it is so important to change your passwords frequently and use secure passwords. But as web developers, what can we do to prevent data breaches?

  * 🙋 We can use `bcrypt` to securely hash and salt passwords in our application. 
  
* Answer any questions before proceeding to the next activity.

### 2. Instructor Demo: RESTful Routes (5 min) 

* Navigate to `11-Ins_RESTful-Routes` and run `npm install`. Be sure to change the `.env.EXAMPLE` file into your own `.env` file with your credentials. 

* Run `npm start` from the command line and demonstrate the following in Insomnia Core: 

  * 🔑 Before we look at the code, let's create a user in our database. We can do that by making a POST request to `localhost:3001/api/users/` and providing the following data in JSON format in Insomnia Core:

  ```json
  {
    "username": "user1",
    "email": "user1@email.com",
    "password": "Password123"
  }
  ```

  * 🔑 We can check if that was saved correctly by making a GET request to that same URL `localhost:3001/api/users/`. We should see the following response as well as a `200 OK` status code:

  ```json
  [
    {
      "id": 1,
      "username": "user1",
      "email": "user1@email.com",
      "password": "Password123"
    }
  ]
  ```

* Open `11-Ins_RESTful-Routes/routes/api/userRoutes.js` in your IDE and explain the following:

  * As you can see, both routes are using `async/await` and are functional. However the POST route uses `try/catch` and proper HTTP status codes in order to catch any errors and respond with the correct status code.

  ```js
  router.post('/', async (req, res) => {
    // the route will 'try' to do this action first:
    try {
      const userData = await User.create(req.body);
      // 200 status code means the request is successful
      res.status(200).json(userData);

    // if there are any errors, it will 'catch' it here:
    } catch (err) {
      // 400 status code means the server could not understand the request
      res.status(400).json(err);
    }
  });
  ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How would we build this?

  * 🙋 We will need to use `try/catch` to catch any errors and send back the proper status codes along with the JSON response. 

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `12-Stu_RESTful-Routes/README.md`.

### 3. Student Do: RESTful Routes (15 min) 

* Direct students to the activity instructions found in `12-Stu_RESTful-Routes/README.md`.

* Break your students into pairs that will work together on this activity.

```md
# 🐛 Routes send back 200 status code every time

Work with a partner to resolve the following issue(s):

* As a developer, I want to see proper HTTP status codes returned so I can be aware of any errors.

* As a developer, I want to use `try/catch` to properly catch errors when using `async/await`.

## Expected Behavior

* When there is no error with the request, the 200 status code is returned.

* When there is an internal server error, the 500 status code is returned.

* When a user does not exist in the database, the 404 status code is returned along with a message "No user found with this id!".

## Actual Behavior

* Whether there is an error with the request or if the user does not exist in the database, the 200 status code is returned.

## Steps to Reproduce the Problem

1. Run `npm start` in your command line to start the server.

2. Open Insomnia Core and make a GET request to `api/users/10`.

3. Notice the 200 status code returned.

## Assets

The following code block demonstrates the expected JSON response:

{
  "message": "No user with this id!"
}

---

## 💡 Hint(s)

* How do we return HTTP status codes?

## 🏆 Bonus

* If you have fully completed the above tasks, here is something you and your partner can work through as an added challenge to further your knowledge:

  * What other principles make up "REST"?

* Use [Google](https://www.google.com) or another search engine to research the above.
```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students that need extra help while circulating through room.

### 4. Instructor Review: RESTful Routes (10 min) 

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How comfortable do you feel with `try/catch` and `HTTP status codes`? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help!

* Use the prompts and talking points below to review the following key (🔑) points:

  * ✔️ `try/catch`

  * ✔️ `200` status code

  * ✔️ `500` status code 

  * ✔️ `404` status code 

* Open `12-Stu_RESTful-Routes/Solved/routes/api/userRoutes.js` in your IDE and explain the following: 

  * Here we see a GET route to get one user by its `id`, a PUT route to update a user, and a DELETE route to delete a user.

  * 🔑 Remember we need to incorporate `try/catch` into all three routes.

  * 🔑 First, if there is no error with the request, the `200 OK` status code is returned.

  ```js
  res.status(200).json(userData);
  ```

  * 🔑 If there is an internal server error, the `500 Internal Server Error` status code is returned.

  ```js
  catch (err) {
    res.status(500).json(err);
  }
  ```
  
  * 🔑 If the user does not exist in the database, the `404 Not Found` status code is returned. But first, in order to check if the user exists in the database or not, we need to use an `if` statement:

  ```js
  // GET a user
  router.get('/:id', async (req, res) => {
    try {
      const userData = await User.findByPk(req.params.id);
      if (!userData) {
        res.status(404).json({ message: 'No user with this id!' });
        return;
      }
      res.status(200).json(userData);
    } catch (err) {
      res.status(500).json(err);
    }
  });
  ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ What are some other common HTTP status codes?

  * 🙋 The `400 Bad Request` status code is used when the server cannot understand the request due to invalid syntax. 
  
  * 🙋 The `401 Unauthorized` status code is used when the user must authenticate itself first to get the requested response. 
  
  * 🙋 The `403 Forbidden` status code is when the user does not have access rights to the content, but unlike the `401`, the user's identity is known to the server.

  * ☝️ What can we do if we don't completely understand this?

  * 🙋 We can refer to supplemental material, read the [MDN Web Docs on HTTP Response Status Codes](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status), and stick around for Office Hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 5. Instructor Demo: Validation (5 min) 

* Run `npm start` from the command line and demonstrate the following in Insomnia Core: 

  * When it comes to securing and ensuring the quality of our data, it is important to prevent any bad data from being saved in our database. For example, what if someone tries to sign up with the same email address twice? Or what if the password is too short or not secure enough?

  * 🔑 Let's try to create a new user but the email address is not in the right email format:

  ```json
  {
    "username": "test1",
    "email": "test1",
    "password": "Password123"
  }
  ```

  * 🔑 We will get a `400 Bad Request` status code returned with an error:

  ```json
  {
    "name": "SequelizeValidationError",
    "errors": [
      {
        "message": "Validation isEmail on email failed",
        "type": "Validation error",
      }
    ]
    }
  ```

  * 🔑 This time we will create a new user with a correct email address:

  ```json
  {
    "username": "test1",
    "email": "test1@email.com",
    "password": "Password123"
  }
  ```

  * 🔑 That worked! But let's try to create another user with that same email address:

  ```json
  {
    "username": "test2",
    "email": "test1@email.com",
    "password": "Password123"
  }
  ```

  * 🔑 We get another `400 Bad Request` status code returned with a new error:

  ```json
  {
    "name": "SequelizeUniqueConstraintError",
    "errors": [
      {
        "message": "user.email must be unique",
        "type": "unique violation",
      }
    ]
  }
  ```

  * In this way, we can use validators and constraints on a Sequelize model to prevent bad data from entering our database.

* Open `13-Ins_Validation/models/User.js` in your IDE and explain the following:

  * We see a `User` model with an `id`, `username`, `email`, and `password`. In the `email` attribute, we see the constraint `unique` set to `true`. This will prevent duplicate email addresses from being saved in the database:

  ```js
  email: {
    type: DataTypes.STRING,
    unique: true,
  }
  ```

  * Constraints are rules defined at the SQL level. If a constraint check fails, an error will be thrown by the database and Sequelize will forward this error to JavaScript.

  * Next, we also see a model validator to check if the email is in the correct email format.

  ```js
  email: {
    type: DataTypes.STRING,
    unique: true,
    validate: {
      isEmail:true,
    }
  }
  ```

  * Validations are checks performed in the Sequelize level, in pure JavaScript. Validations are automatically run on `create`, `update` and `save`.

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How would we build this?

  * 🙋 We will need to add validators and constraints to the `User` model in order to prevent any bad data from being saved in the database. 

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `14-Stu_Validation/README.md`.

### 6. Student Do: Validation (15 min) 

* Direct students to the activity instructions found in `14-Stu_Validation/README.md`.

* This activity uses unit tests to guide the students in creating the right validators and constraints. If needed, demonstrate how to run `npm run test` to run the unit tests.

* Break your students into pairs that will work together on this activity.

```md
# 📖 Add validations and constraints to the User model

Work with a partner to implement the following user story:

* As a developer, I want to add validations and constraints to the User model in order to prevent bad data from being saved in the database.

## Acceptance Criteria

* It's done when it prevents `null` values from being entered for the username, email and password fields.

* It's done when it prevents the password from being shorter than 8 characters.

* It's done when it prevents the username from having any other characters other than letters and numbers. 

## 📝 Note(s)

Refer to the documentation: 

* [Sequelize Manual on Validations and Constraints](https://sequelize.org/master/manual/validations-and-constraints.html)

---

## 💡 Hint(s)

* Run `npm run test` in your command line to run the unit tests. Use the tests to guide you.

* What are some built-in validators that we can use to accomplish this?

## 🏆 Bonus

* If you have fully completed the above tasks, here is something you and your partner can work through as an added challenge to further your knowledge:

  * What are regular expressions?

* Use [Google](https://www.google.com) or another search engine to research the above.
```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students that need extra help while circulating through room.

### 7. Instructor Review: Validation (10 min) 

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How comfortable do you feel with `validations` and `constraints` for your models in Sequelize? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help!

* Use the prompts and talking points below to review the following key (🔑) points:

  * ✔️ `allowNull`

  * ✔️ `isAlphanumeric`

  * ✔️ `len`

* Open `14-Stu_Validation/Solved/models/User.js` in your IDE and explain the following: 

  * 🔑 First, we want to make sure we prevent `null` values from being entered for all fields. For that we use the `allowNull` constraint and set it to `false`.

  ```js
  username: {
    type: DataTypes.STRING,
    // prevents null values
    allowNull: false,
  },
  email: {
    type: DataTypes.STRING,
    allowNull: false,
  },
  password: {
    type: DataTypes.STRING,
    allowNull: false,
  },
    ```

  * 🔑 Next, for the password, we want to make sure it is longer than 8 characters. So we use a build-in validator called `len` and specify the character count:

  ```js
  password: {
    type: DataTypes.STRING,
    allowNull: false,
    // must be longer than 8 characters
    validate: {
      len: [8],
    },
  },
  ```

  * 🔑 Finally, for the username, we only want to allow letters and numbers, no symbols or other characters. For that, we use another build-in validator called `isAlphanumeric` and set it to `true`:

  ```js
  username: {
    type: DataTypes.STRING,
    allowNull: false,
    // will only allow alphanumeric characters
    validate: {
      isAlphanumeric: true,
    },
  },
  ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How can we be more specific about what we allow to be saved in our database?

  * 🙋 We can use RegEx, or regular expressions. 

  * ☝️ What can we do if we don't completely understand this?

  * 🙋 We can refer to supplemental material, read the [Sequelize Manual on Validations and Constraints](https://sequelize.org/master/manual/validations-and-constraints.html), and stick around for Office Hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 8. Instructor Demo: Password Hashing (5 min) 

* Open `15-Ins_Password-Hashing/routes/api/userRoutes.js` in your IDE and demonstrate the following:

  * 🔑 Like we discussed in the beginning of class, password hashing is very important in securing the user's data in our database. An application's first interaction with a user's password occurs the moment that user creates an account. At that time, we must intervene and hash the plaintext password before it is stored in the database. To do this, we use a node package called, `bcrypt`. 

  * 🔑 First, we import `bcrypt` into the `userRoutes.js` file by adding the `require` expression at the top of the file, as shown in the following code:

  ```js
  const bcrypt = require('bcrypt');
  ```

  * 🔑 In the POST route to create a new user, we take the data for a new user from `req.body` and assign it to `newUser`:

  ```js
  router.post('/', async (req, res) => {
    try {
      const newUser = req.body;
  ```

  * 🔑 Then, in the `bcrypt` hash function, we pass in the `req.body.password`, which is the plaintext password the user entered. We also pass in a `saltRound` value of 10. The resulting hashed password is then saved as the `newUser.password`.

  ```js
  router.post('/', async (req, res) => {
    try {
      const newUser = req.body;
      newUser.password = await bcrypt.hash(req.body.password, 10);
  ```

  * We then create a new user using the `newUser` data with the hashed password and save it in the database.

  ```js
  router.post('/', async (req, res) => {
    try {
      const newUser = req.body;
      newUser.password = await bcrypt.hash(req.body.password, 10);
      const userData = await User.create(newUser);
  ```

* Run `npm start` in your command line and demonstrate the following in Insomnia Core:

  * We will make a POST request to create a new user and notice that the password is "Password123" in plaintext:

  ```json
  {
    "username": "test2",
    "email": "test2@email.com",
    "password": "Password123"
  }
  ```

  * When we see the returned data, we see that the password that is actually saved in the database is hashed:

  ```json
  {
    "id": 4,
    "username": "test2",
    "email": "test2@email.com",
    "password": "$2b$10$pQgQagcm85YW1b/0j5MrU.iH2iSCsne.FAMjcxp6izuXEJH.lgiqS"
  }
  ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How would we build this?

  * 🙋 We will need to use `bcrypt` to hash the password before saving a new user in the database.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `16-Stu_Password-Hashing/README.md`.

### 9. Student Do: Password Hashing (15 min) 

* Direct students to the activity instructions found in `16-Stu_Password-Hashing/README.md`.

* Break your students into pairs that will work together on this activity.

```md
# 📐 Add Comments to Implementation of the login route

Work with a partner to add comments describing the functionality of the code found in [user-routes.js](./Unsolved/routes/api/user-routes.js).

## 📝 Note(s)

Refer to the documentation: 

[NPM Docs on bcrypt](https://www.npmjs.com/package/bcrypt)

---

## 🏆 Bonus

* If you have fully completed the above tasks, here is something you and your partner can work through as an added challenge to further your knowledge:

  * How can we persist a login state?

* Use [Google](https://www.google.com) or another search engine to research the above.
```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students that need extra help while circulating through room.

### 10. BREAK (15 min)

### 11. Instructor Review: Password Hashing (10 min) 

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How comfortable do you feel with `password hashing using bcrypt`? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help!

* Use the prompts and talking points below to review the following key (🔑) points:

  * ✔️ `findOne()`

  * ✔️ `res.status(404)`

  * ✔️ `bcrypt.compare()`

  * ✔️ `res.status(400)`

* Open `16-Stu_Password-Hashing/Solved/routes/api/userRoutes.js` in your IDE and explain the following: 

  * For this reverse engineering activity, we had to add comments describing the `login` route.

  * 🔑 First, we need to search the database for a user with the provided email that the user used to login. We do that by using `.findOne()`:

  ```js
  router.post('/login', async (req, res) => {
    try {
      const userData = await User.findOne({ where: { email: req.body.email } });
  ```

  * 🔑 If we cannot find anything in the database with that email address, we need to return a `404` status code with an error message. 
  
  * However, be careful not to specify that the login failed because of a wrong email or password. Otherwise it is easier for someone who was trying to hack into the system to know which part of the login info they got wrong!

  ```js
  if (!userData) {
    res.status(404).json({ message: 'Login failed. Please try again!' });
    return;
  }
  ```

  * 🔑 If the user is found in the database, then we use `bcrypt.compare()` to compare the provided password and the hashed password that is saved in the database.

  ```js
  const validPassword = await bcrypt.compare(
    req.body.password,
    userData.password
  );
  ```

  * 🔑 If the password does not match, then we need to return a `400` status code with an error message. Again, we shouldn't specify what was wrong with the login info provided.

  ```js
  if (!validPassword) {
    res.status(400).json({ message: 'Login failed. Please try again!' });
    return;
  }
  ```

  * If everything goes well, we return a `200` status code with a success message.

  ```js
  res.status(200).json({ message: 'You are now logged in!' });
  ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ Rather than doing this in the routes, where is a better place to handle password hashing?

  * 🙋 The User model!

  * ☝️ What can we do if we don't completely understand this?

  * 🙋 We can refer to supplemental material, read the [NPM Docs on bcrypt](https://www.npmjs.com/package/bcrypt), and stick around for Office Hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 12. Instructor Demo: Hooks (5 min) 

* Open `17-Ins_Hooks/models/User.js` in your IDE and demonstrate the following:
  
  * 🔑 As we've seen so far, Sequelize offers many tools that make it easier for us to communicate with our database. Hooks are another tool that help us preform actions before and after calls in Sequelize are executed. Hooks are also called lifecycle events, because they help us control the sequence in which actions are preformed. 

  * 🔑 There is a long list of hooks that are available to us through Sequelize and we will only touch on a `beforeCreate()` and `beforeUpdate()` today. I encourage you to Google other hooks that are available to you. 

  * 🔑 There are a few ways to declare hooks. Today, I will demonstrate how to declare a hook via the `.init()` method. You'll find the documentation for the other two ways to programmatically add hooks in the Sequelize Docs.

  * 🔑 Let's take a look at the `User.js` file. It is set up the same way that the other `User.js` files that we've used today except that it now includes `hooks:` between where the model attributes are defined and where the connection instance is passed.

  ```js
  //model attributes are added above
    {
    hooks: {
      beforeCreate(newUserData) {
        newUserData.email = newUserData.email.toLowerCase();
        return newUserData;
      },
      beforeUpdate(newUserData) {
        newUserData.email = newUserData.email.toLowerCase();
        return newUserData;
      },
    },
    //connection instance is passed below
  ```

  * 🔑 Notice that we've added two separate methods, `beforeCreate` and `beforeUpdate`. We are passing `newUserData` into each so that whenever a user instance is created or updated, our hooks have access to the user's data.

  * 🔑 The `beforeCreate` method accepts `newUserData`, uses `newUserData` to set the user's email to lower case, then returns `newUserData`. Next, we will check to see that this is working.

  ```js
   beforeCreate(newUserData) {
        newUserData.email = newUserData.email.toLowerCase();
        return newUserData;
      },
  ```

* Run `npm start` from the command line and demonstrate the following in Insomnia Core: 

  * 🔑 We will make a POST request to `http://localhost:3001/api/users` to create a new user. Notice that the email address is capitalized in the body of the request:

  ```json
  {
    "username": "test",
    "email": "TEST@email.com",
    "password": "Password123"
  }
  ```

  * 🔑 When the data is returned, we should see that the email address has been stored in lower case. 

  ```json
  {
    "username": "test",
    "email": "test@email.com",
    "password": "Password123"
  }
  ```
  * 🔑 Great! `beforeCreate` is working. Let's return to `User.js` and take a look at `beforeUpdate`. It is almost identical to `beforeCreate` except for the method name.

  ```js
  beforeUpdate(newUserData) {
        newUserData.email = newUserData.email.toLowerCase();
        return newUserData;
      },
  ``` 

  * 🔑 There is one other small difference, located in `userRoutes.js`. 
  
  * 🔑 Open `17-Ins_Hooks/routes/api/userRoutes.js` and scroll down to the `PUT` route. Notice that we've added an option, `individualHooks: true`, to the query call. This option will select the record that is about to be updated and emit `beforeUpdate` on the instance.

  ```js
  router.put('/:id', async (req, res) => {
    try {
      const userData = await User.update(req.body, {
        where: {
          id: req.params.id,
        },
        individualHooks: true
      });

  ```
* Demonstrate the following in Insomnia Core:

 * 🔑 We will make a PUT request to `http://localhost:3001/api/users/1` to update our user, who accidentally entered the wrong email address:

  ```json
  {
    "username": "test",
    "email": "TEST1234@email.com",
    "password": "Password123"
  }
  ```

  * 🔑 When the data is returned, we should see that the email address has been updated and stored in lower case. 

  ```json
  {
    "username": "test",
    "email": "test1234@email.com",
    "password": "Password123"
  }
  ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How would we build this?

  * 🙋 We will need to add hooks to the `User` model to preform actions on instances before they are created, updated, etc. 

  * 🙋 If necessary, we will need to add options to our query call in `userRoutes.js` to make sure that the hooks are properly emitted on each instance.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `18-Stu_Hooks/README.md`.

### 13. Student Do: Hooks (15 min)

* Direct students to the activity instructions found in `18-Stu_Hooks/README.md`.

* Break your students into pairs that will work together on this activity.

```md
# 🏗️ Use hooks to hash a password

Work with a partner to implement the following user story:

* As a user, I want to be able to login with my password.

* As a user, I want to be able to change my password.

* As a user, I want to know that my password is being stored securely.

## Acceptance Criteria

* It's done when User.int() includes hooks to hash the user's password before it is created.

* It's done when User.int() includes hooks to hash the user's password before it is updated.


## 💡 Hint(s)

* What did you learn about hashing a password, async/await, try/catch in previous lessons? 

* What are 3 methods for adding hooks to your code? How is adding a hook via init() different from the other options?

## 🏆 Bonus

* If you have fully completed the above tasks, here is something you and your partner can work through as an added challenge to further your knowledge:

  * Hooks are considered "middleware" in programming terms. What are some other examples of middleware used in Node applications?

* Use [Google](https://www.google.com) or another search engine to research the above.

```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students that need extra help while circulating through room.

### 14. Instructor Review: Hooks (10 min) 

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How comfortable do you feel with using `hooks` in Sequelize? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help!

* Use the prompts and talking points below to review the following key (🔑) points:

  * ✔️ `beforeCreate`

  * ✔️ `beforeUpdate`

  * ✔️ `async`
  
  * ✔️ `await`

  * ✔️ `bcrypt`

* Open `18-Stu_Hooks/Solved/models/User.js` in your IDE and explain the following: 

  * 🔑 First, we want to make sure that a user can create a porfile and that their password will be stored securely with `bcrypt` before the record is stored. We accomplish this by creating a `beforeCreate` hook in the `User.js` file.

    ```js
    hooks: {
      beforeCreate(newUserData) {
    
      }
    }
    ```

  * 🔑 Next, we set the user's password equal to a hashed password, using `bcrypt`. Then we return `newUserData`.

  ```js
   beforeCreate(newUserData) {
        newUserData.password = bcrypt.hash(newUserData.password, 10);
        return newUserData;
      }
  ```
   * 🔑 Finally, we add `async` and `await` into our method, to write cleaner code that enables promise-based behavior.

   ```js
  async beforeCreate(newUserData) {
        newUserData.password = await bcrypt.hash(newUserData.password, 10);
        return newUserData;
      }
   ```
 * 🔑 We can repeat the previous steps to create the `beforeUpdate` method.

   ```js
   async beforeUpdate(updatedUserData) {
        updatedUserData.password = await bcrypt.hash(
          updatedUserData.password,
          10
        );
        return updatedUserData;
      },
   ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ What are some other commonly used hooks that are available to us?

  * 🙋 `afterCreate`, `afterUpdate`, `beforeDestroy`, `afterDestroy`, etc.

  * ☝️ What can we do if we don't completely understand this?

  * 🙋 We can refer to supplemental material, read the [Sequelize Manual on Hooks](https://sequelize.org/master/manual/hooks.html), and stick around for Office Hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 15. Instructor Demo: Instance Methods (5 min) 

* Open `19-Ins_Instance_Methods/models/User.js` in your IDE and demonstrate the following:

  * 🔑 Sometimes we need to work with data that is stored within an instance. For example, maybe we want to know if a user in a pet adoption database currently has any pets. We don't want to use 'GET' to return all of that user's information because we only need to know if that user has pets or not. This is where instance methods can be useful.

  * 🔑 Sequelize allows us to write instance methods within models (in our case, the `User` model) to give us access to specific data that we can then return to users. Let's take a look at `User.js`. In this example, in order to create a user instance for our pet adoption database, they must include the number of pets that they currently have.

```js
User.init(
  {
    id: {
      type: DataTypes.INTEGER,
      allowNull: false,
      primaryKey: true,
      autoIncrement: true,
    },
    username: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    email: {
      type: DataTypes.STRING,
      allowNull: false,
      unique: true,
      validate: {
        isEmail: true,
      },
    },
    password: {
      type: DataTypes.STRING,
      allowNull: false,
      validate: {
        len: [8],
      },
    },
    numberOfPets: {
      type: DataTypes.INTEGER,
    },
  },
```

  * 🔑 Let's test out the code to see what a user's record looks like. 
 

* Run `npm start` from the command line and demonstrate the following in Insomnia Core: 

 * 🔑 We will make a POST request to `http://localhost:3001/api/users` to create a new user. We've set `numberOfPets` equal to 2, because our user has 2 pets:

  ```json
  {
    "username": "test",
    "email": "test@email.com",
    "password": "Password123",
    "numberOfPets": 2
  }
  ```

  * 🔑 When the data is returned, we should see that the user's pets have been stored in the record. 

  ```json
  {
    "username": "test",
    "email": "test@email.com",
    "password": "Password123",
    "numberOfPets": 2
  }
  ```

  * 🔑 We can imagine that many of the users in this pet adoption database might not have pets yet, so let's create another instance to reflect that.

  ```json
  {
    "username": "test2",
    "email": "test2@email.com",
    "password": "Password890",
    "numberOfPets": 0
  }
  ```

  * 🔑 When the data is returned, we should see that the user's pets have been stored in the record as `"numberOfPets": 0`. 

  ```json
  {
    "username": "test2",
    "email": "test2@email.com",
    "password": "Password890",
    "numberOfPets": 0
  }
  ```

  * 🔑 Okay, so we created our users, but how do we check to see if a user has pets or not? We need to create an instance method.

  * 🔑 Let's take a look at the user model in `User.js`. Notice that we've added a simple instance method called, `hasPets`. Inside of the instance method we use a conditional statement to check if `this.numberOfPets` (where `this` represents one particular user) is greater than 0. If the number is greater than 0, it returns true, otherwise, it returns false.

  ```js
  class User extends Model {
    // This instance method uses a conditional statement to check if a user has pets
    hasPets() {
     if (this.numberOfPets > 0) {
        return true;
      } else {
       return false;
      }
    }
  }
  ```
   * 🔑 Sidenote: Instance methods can only be used on one instance of a class (in our case, one user). Class methods, or static methods, can be called on an entire class (in our case, all users).

 * 🔑 Great! Our instance method checks to see if a user has any pets. But now we need to make sure that our user can use this method. In order to do that, we also need to write a custom route.

  * 🔑 Open `19-Ins_Instance_Methods/routes/api/userRoutes.js` in your IDE and demonstrate the following:

   * 🔑 Notice that we've included a new route specifically for our instance method, `hasPets`. First, we find a user using their primary key (provided by params). If userData evaluates as false (no user exists with that primary key), then we will send an error message. If a user does exist at the primary key, we get to use the instance method that we wrote in `User.js` to see if the user has pets. If `petData` evaluates as false ( the user has 0 pets), then the user will receive the message, "This person has no pets." Otherwise, the user will see the message "This person has pets!"

   ```js
  router.post('/:id/hasPets', async (req, res) => {
    try {
      const userData = await User.findByPk(req.params.id);
      if (!userData) {
        res.status(404).json({ message: 'No user with this id!' });
        return;
      }
      const petData = await userData.hasPets(req.body.numberOfPets);
      
      if (!petData) {
        res.status(400).json({ message: 'This person has no pets.' });
        return;
      }
      res.json({ message: 'This person has pets!' });
    } catch (err) {
      res.status(400).json(err);
    }
  });
   ```
   * 🔑 Let's test out the instance method and the route on the users that we just created. 
 

* Run `npm start` from the command line and demonstrate the following in Insomnia Core: 

 * 🔑 We will make a POST request to `http://localhost:3001/api/users/1/hasPets` to check our route and instance method.

  * 🔑 When the data is returned, we should see the following message, because the first user we created did have pets. 

  ```json
  {
    "message": "This person has pets!"
  }
  ```
 * 🔑 Now let's check our second user. We will make a POST request to `http://localhost:3001/api/users/2/hasPets`.

  * 🔑 When the data is returned, we should see the following message, because the second user we created did not have pets. 

  ```json
  {
    "message": "This person has no pets."
  }
  ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How would we build this?

  * 🙋 We will add an instance method inside the user model in `User.js` return specific data about one instance. 

  * 🙋 We will add a corresponding route in `userRoutes.js` so that we have access to the data returned by the instance method. 

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `18-Stu_Instance_Methods/README.md`.

### 16. Student Do: Instance Methods (15 min) 

* Direct students to the activity instructions found in `18-Stu_Instance_Methods/README.md`.

* Break your students into pairs that will work together on this activity.

```md
# 🏗️ Create a custom instance method

Work with a partner to implement the following user story:

* As a user, I want to login to my account with my password.

* As a developer, I want to allow a user to login to their account securely so that their password information isn't compromised. 

## Acceptance Criteria

* It's done when the model includes an instance method.

* It's done when the instance method compares the user's input with the user's hashed password.

## 💡 Hint(s)

* What tools does bcrypt offer to help us compare user input to a hashed password?

## 🏆 Bonus

* If you have fully completed the above tasks, here is something you and your partner can work through as an added challenge to further your knowledge:

  * How can we DRY up our code using Sequelize's static model methods?

* Use [Google](https://www.google.com) or another search engine to research the above.
```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students that need extra help while circulating through room.

### 17. Instructor Review: Instance Methods (15 min)

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How comfortable do you feel with adding instance methods to your models? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help!

* Use the prompts and talking points below to review the following key (🔑) points:

  * ✔️ `checkPassword()`

  * ✔️ `compareSync`

  * ✔️ @TODO { THE OTHER }

* Open `18-Stu_Instance_Methods/Solved/models/User.js` in your IDE and explain the following: 

  * 🔑First, we want to write an instance method inside the user model in `User.js`. In this case, the shell of instance method has been provided.

    ```js
    class User extends Model {
      checkPassword(loginPw) {
        
       }
    }
    ```
  * Open `18-Stu_Instance_Methods/Solved/routes/api/userRoutes.js` in your IDE and explain the following: 

  * 🔑 Notice that the `checkPassword` instance method is used in the `/login` route located in `userRoutes.js`. First we find one user record with an email address that matches the one provided by the user logging in. If an account with that email address doesn't exist, the user will recieve an error message. If the user does exist, we will use the `checkpassword()` instance method to compare the user's input to the password stored in the record by passing in user input as an argument. If `checkPassword()` evaluates as false, the user will receive an error message. If `checkPassword()` evaluates as true, the user will be logged in.

  ```js
  router.post('/login', async (req, res) => {
    try {
      const userData = await User.findOne({ where: { email: req.body.email } });
      if (!userData) {
        res
          .status(400)
          .json({ message: 'Incorrect email or password, please try again' });
        return;
      }
      const validPassword = await userData.checkPassword(req.body.password);
      if (!validPassword) {
        res
          .status(400)
          .json({ message: 'Incorrect email or password, please try again' });
        return;
      }
      res.json({ user: userData, message: 'You are now logged in!' });
    } catch (err) {
      res.status(400).json(err);
    }
  });
  ```

  * 🔑 Understanding how `checkPassword()` is being used in the `/login` route can give us clues to what the instance method needs to accomplish. We can tell for the `/login` route that our instance method will need to take in the user's password (from the body of the post request) as an argument and then determine if it matches the password stored in that user's record.

  * Open `18-Stu_Instance_Methods/Solved/models/User.js` in your IDE and explain the following: 

  * 🔑`bcrypt` offers a method called, `compareSync` that allows us to easily check a password. It takes two arguments, `loginPw` (the password the user sent in the body of the `POST` request) and `this.password` (the password stored in this particular user record). 

  ```js
    class User extends Model {
      checkPassword(loginPw) {
        bcrypt.compareSync(loginPw, this.password);
       }
    }
   ```

  * 🔑 Remember the `/login` route expects `checkPassword()` to evaluate as either `true` or `false`. `compareSync` returns a boolean, so all we need to do is return it in the instance method.

  ```js
  class User extends Model {
    checkPassword(loginPw) {
      return bcrypt.compareSync(loginPw, this.password);
    }
  }
  ```
   * Let's check to make sure that our code is working.

   * Run `npm start` from the command line and demonstrate the following in Insomnia Core: 

  * 🔑 We will make a POST request to `http://localhost:3001/api/users` to create a new user:

  ```json
  {
    "username": "test",
    "email": "test@email.com",
    "password": "Password123"
  }
  ```

  * 🔑 When the data is returned, notice that the password is hashed because `User.js` includes a `beforeCreate` hook that uses `bcrypt` to hash the user's password. 

  ```json
  {
    "id": 1,
    "username": "test",
    "email": "test@email.com",
    "password": "$2b$10$ItAeYIqhuEzADqxHsMe6Mu.r3lzZ.Ewb0gnWw0md3OkRsqPnFKbbG"
  }
  ```
  * 🔑 Now, we will make a POST request to `http://localhost:3001/api/users/login` to login.

  ```json
  {
    "email": "test@email.com",
    "password": "Password123"
  }
  ```
* 🔑 If our code is working, we should see the following when the data is returned: 

 ```json
 {
  "user": {
    "id": 1,
    "username": "test",
    "email": "test@email.com",
    "password": "$2b$10$ItAeYIqhuEzADqxHsMe6Mu.r3lzZ.Ewb0gnWw0md3OkRsqPnFKbbG"
  },
  "message": "You are now logged in!"
}
  ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ When do you need to incorporate an instance method into your model?

  * 🙋 When you need to get data or do something related to one specific instance of a model.

  * ☝️ What can we do if we don't completely understand this?

  * 🙋 We can refer to supplemental material, read the [Sequelize Manual on Model Instances](https://sequelize.org/master/manual/model-instances.html), and stick around for Office Hours to ask for help.

* Answer any questions before ending the class.

### 18. END (0 min)

How did today’s lesson go? Your feedback is important. Please take 5 minutes to complete [this anonymous survey](https://forms.gle/RfcVyXiMmZQut6aJ6).

---
© 2020 Trilogy Education Services, LLC, a 2U, Inc. brand.  Confidential and Proprietary.  All Rights Reserved.