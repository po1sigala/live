# 13.2 Part-Time Lesson Plan: Object-Relational Mapping (ORM)

## Overview 

In today's class, students will continue to learn Sequelize and be formally introduced to RESTful API paradigms. Along with `async` and `await`, they will incorporate `try...catch` to properly catch the errors and return them to the user. Students will incorporate validators and constraints to the Sequelize models to prevent bad data from being saved into the database. Students will learn about password hashing using `bcrypt`, incorporating Hooks, and creating a login route for users to securely log in. They will create a custom method that corresponds to a custom route. 

## Instructor Notes

* In this lesson, students will complete activities `11-Ins_RESTful-Routes` through `20-Stu_Instance-Method`.

* Do a quick Google search of "data breaches this year" to look up a list of businesses that were affected this year. You can refer to this list as you are doing the `Stoke Curiosity` section.

* Be sure to prepare and read over the activities before your class begins. Try to anticipate any questions students might have.

* You will be using MySQL for today's activities. Be sure to have your MySQL server up and running. Go ahead and create the database `user_db` ahead of time, or demonstrate it live in class.

* All of the activities will be using Insomnia Core to test the routes, instead of relying on a front end. Be sure to have it installed and ready for all activities. 

* Remind students to do a `git pull` of the class repo to have today's activities ready and open in VS Code. 

* If you are comfortable doing so, live-code the solutions to the activities. If not, just use the solutions provided and follow the prompts and talking points for review.

* Let students know that the Bonus at the end of each activity is not meant to be extra coding practice, but instead is a self-study on topics beyond the scope of this unit for those who want to further their knowledge. 

## Learning Objectives

By the end of class, students will be able to:

* Use `try...catch` to catch errors.

* Ensure HTTP requests respond with the correct status code.

* Use validation tools on a Sequelize model.

* Use `bcrypt` to encrypt a password.

* Automate functionality using Sequelize Hooks.

* Create and run a custom method on a Sequelize instance.

## Time Tracker

| Start  | #   | Activity Name                       | Duration |
|---     |---  |---                                  |---       |
| 6:30PM | 1   | Instructor Do: Stoke Curiosity      | 0:10     |
| 6:40PM | 2   | Instructor Demo: RESTful Routes     | 0:05     |
| 6:45PM | 3   | Student Do: RESTful Routes          | 0:15     |
| 7:00PM | 4   | Instructor Review: RESTful Routes   | 0:10     |
| 7:10PM | 5   | Instructor Demo: Validation         | 0:05     |
| 7:15PM | 6   | Student Do: Validation              | 0:15     |
| 7:30PM | 7   | Instructor Review: Validation       | 0:10     |
| 7:40PM | 8   | Instructor Demo: Password Hashing   | 0:05     |
| 7:45PM | 9   | Student Do: Password Hashing        | 0:15     |
| 8:00PM | 10  | BREAK                               | 0:15     |
| 8:15PM | 11  | Instructor Review: Password Hashing | 0:10     |
| 8:25PM | 12  | Instructor Demo: Hooks              | 0:05     |
| 8:30PM | 13  | Student Do: Hooks                   | 0:15     |
| 8:45PM | 14  | Instructor Review: Hooks            | 0:10     |
| 8:55PM | 15  | Instructor Demo: Instance Method    | 0:05     |
| 9:00PM | 16  | Student Do: Instance Method         | 0:15     |
| 9:15PM | 17  | Instructor Review: Instance Method  | 0:15     |
| 9:30PM | 18  | END                                 | 0:00     |

---

## Class Instruction

### 1. Instructor Do: Stoke Curiosity (10 min)

* Welcome students to class.

* The topic of today's lesson is authentication. Using the prompts provided, have a discussion about the importance of securing data.

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ In this day and age, it is becoming very important to secure sensitive data. What are some sensitive data that you would like to protect?

  * 🙋 Banking information. Social security number. Tax information. Credit card information.

  * ☝️ On the internet, one of the most important pieces of data you would want to protect is your password. What can happen if your password is compromised?

  * 🙋 Your online accounts can be hacked. Sensitive data will be exposed. Identity theft can happen. 

  * ☝️ Unfortunately, this happens all the time and we hear about data breaches on the news. Can you recall a recent data breach? Or maybe a time when your account was hacked?

  * 🙋 Answers will vary. Refer to the Google results you looked up, per the Instructor Notes section.

  * ☝️ As a user, that's why it is so important to change your passwords frequently and use secure passwords. But as web developers, what can we do to prevent data breaches?

  * 🙋 We can scramble the password that the user uses so that it doesn't resemble the user's password when we save it in the database. This is called password hashing.
  
  * 🙋 But on top of that, we can also **salt** passwords, meaning that we can add additional random data to the hashed password to truly make it unique.
  
  * 🙋 The ideal authentication platform should use both hashing and salting, and we will learn how to do just that in this class using a node package called `bcrypt`!
  
* Answer any questions before proceeding to the next activity.

### 2. Instructor Demo: RESTful Routes (5 min) 

* Navigate to `11-Ins_RESTful-Routes` and run `npm install`. Be sure to change the `.env.EXAMPLE` file into your own `.env` file with your credentials. 

* Give a brief explanation of RESTful routes and the four primary HTTP methods that are used.

  * We use HTTP verbs to give more meaning to requests. Notice how they correspond to the CRUD operations. 

  * GET requests will read (or "get") a specific resource.

  * POST requests will create a new resource.

  * PUT requests will update an existing resource.

  * DELETE requests will delete an existing resource. 

  * In return, we use HTTP status codes for the responses we get back.

* Run `npm start` from the command line and demonstrate the following in Insomnia Core: 

  * 🔑 Before we look at the code, let's create a user in the database. We can do that by making a POST request to `localhost:3001/api/users/` and providing the following JSON data as the body of the request in Insomnia Core:

    ```json
    {
      "username": "user1",
      "email": "user1@email.com",
      "password": "Password123"
    }
    ```

  * 🔑 We can check if that was saved correctly by making a GET request to that same URL `localhost:3001/api/users/`. We should see the following response as well as a `200 OK` status code:

    ```json
    [
      {
        "id": 1,
        "username": "user1",
        "email": "user1@email.com",
        "password": "Password123"
      }
    ]
    ```

* Open `11-Ins_RESTful-Routes/routes/api/userRoutes.js` in your IDE and explain the following:

  * As you can see, both routes are using `async` and `await` and are fully functional. However, the POST route uses a `catch` block to catch any and all errors that might happen in the `try` block, as shown in the following example: 

    ```js
    // the route will 'try' to do this action first
    try {
      const userData = await User.create(req.body);
      res.status(200).json(userData);

    // if there are any errors, it will 'catch' all of them here:
    } catch (err) {
      res.status(400).json(err);
      }
    ```

  * `try...catch` not only makes the code easier to read, but it will allow us to catch all of the errors in one place.

  * Also, the point of using `async` and `await` is to avoid callbacks, so it doesn't make sense to use the `.catch()` callback to catch errors, like in the GET route. Refer to the following example:

    ```js
    router.get('/', async (req, res) => {
      const userData = await User.findAll().catch((err) => {
        res.json(err);
      });
      res.json(userData);
    });
    ```

  * Note also in the POST route, we incorporated proper HTTP status codes to know exactly what kind of error happened with the server. We use the `.status(xxx)` syntax to return the status code along with the error in JSON format, as follows:

    ```js
    catch (err) {
      // 400 status code means the server could not understand the request
      res.status(400).json(err);
    }
    ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How would we build this?

  * 🙋 We will need to use `try...catch` to catch the errors and send back the proper status codes along with the JSON response. 

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `12-Stu_RESTful-Routes/README.md`.

### 3. Student Do: RESTful Routes (15 min) 

* Direct students to the activity instructions found in `12-Stu_RESTful-Routes/README.md`.

* Break your students into pairs that will work together on this activity.

```md
# 🐛 Routes Return 200 Status Code Every Time

Work with a partner to resolve the following issues:

* As a developer, I want to see proper HTTP status codes returned so I can be aware of any errors.

* As a developer, I want to use `try...catch` to properly catch errors when using `async` and `await`.

## Expected Behavior

* When there is no error with the request, the 200 status code is returned.

* When there is an internal server error, the 500 status code is returned.

* When a user does not exist in the database, the 404 status code is returned along with the following message:

  {
    "message": "No user with this id!"
  }

## Actual Behavior

* Whether there is an error with the request or if the user does not exist in the database, the 200 status code is returned.

## Steps to Reproduce the Problem

1. Run `npm start` in your command line to start the server.

2. Open Insomnia Core and make a GET request to `api/users/10`.

3. Notice the 200 status code returned.

---

## 💡 Hints

How do we return HTTP status codes?

## 🏆 Bonus

If you have completed this activity, work through the following challenge with your partner to further your knowledge:

* What are some other common HTTP status codes?

Use [Google](https://www.google.com) or another search engine to research this.
```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students that need extra help. 

### 4. Instructor Review: RESTful Routes (10 min) 

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How comfortable do you feel with `try...catch` and `HTTP status codes`? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help!

* Use the prompts and talking points below to review the following key (🔑) points:

  * ✔️ `try...catch`

  * ✔️ `200` status code

  * ✔️ `500` status code 

  * ✔️ `404` status code 

* Open `12-Stu_RESTful-Routes/Solved/routes/api/userRoutes.js` in your IDE and explain the following: 

  * Here we see a GET route to get one user by its `id`, a PUT route to update a user, and a DELETE route to delete a user.

  * 🔑 Remember we incorporated `try...catch` into all three routes to catch all of the errors that might happen in the `try` block.

  * 🔑 First, if there is no error with the request, the `200 OK` status code is returned, as follows:

    ```js
    res.status(200).json(userData);
    ```

  * 🔑 If there is an internal server error, the `500 Internal Server Error` status code is returned, as follows:

    ```js
    catch (err) {
      res.status(500).json(err);
    }
    ```
  
  * 🔑 If the user does not exist in the database, the `404 Not Found` status code is returned. But first, to check if the user exists in the database or not, we need to use an `if` statement, like in the following example:

    ```js
    // GET a user
    router.get('/:id', async (req, res) => {
      try {
        const userData = await User.findByPk(req.params.id);
        if (!userData) {
          res.status(404).json({ message: 'No user with this id!' });
          return;
        }
        res.status(200).json(userData);
      } catch (err) {
        res.status(500).json(err);
      }
    });
    ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ Why should we use `try...catch` to catch errors when using `async` and `await`?

  * 🙋 The Promise might take some time before it rejects; so in that case, there will be a delay before `await` throws an error. Because the point of `async` and `await` is to avoid using callbacks, we can use `try...catch` instead of using a `.catch()` callback to catch that error. Also we can wrap multiple lines in the `try` block, so that we can catch any and all errors in the `catch` block. 

  * ☝️ How can the status codes be used to enhance the user experience on the front end?

  * 🙋 As a user, if I get a `4xx` status code returned, I would know I caused the error, whereas if I get a `5xx` status code returned, I would know that the server has a problem.

  * ☝️ What can we do if we don't completely understand this?

  * 🙋 We can refer to supplemental material, read the [Wikipedia article on REST](https://en.wikipedia.org/wiki/Representational_state_transfer#Applied_to_web_services) and [MDN Web Docs on HTTP Response Status Codes](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status), and stick around for office hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 5. Instructor Demo: Validation (5 min) 

* Navigate to `13-Ins_Validation` and run `npm start` from the command line. Be sure to change the `.env.EXAMPLE` file into your own `.env` file with your credentials. 

* Demonstrate the following in Insomnia Core:

  * When it comes to securing and ensuring the quality of the data, it is important to prevent any bad data from being saved in the database. For example, what if the password is too short or not secure enough? Or, what if someone tries to sign up with the same email address twice? 

  * 🔑 Let's try to create a new user with the email address in the wrong email format. Make a POST request to `localhost:3001/api/users/` and provide the following JSON data as the body of the request in Insomnia Core:

    ```json
    {
      "username": "test1",
      "email": "test1",
      "password": "Password123"
    }
    ```

  * 🔑 We will get a `400 Bad Request` status code returned with an error, as follows:

    ```json
    {
      "name": "SequelizeValidationError",
      "errors": [
        {
          "message": "Validation isEmail on email failed",
          "type": "Validation error",
        }
      ]
      }
    ```

  * 🔑 This time we will create a new user with a correct email address, as shown in the following example:

    ```json
    {
      "username": "test1",
      "email": "test1@email.com",
      "password": "Password123"
    }
    ```

  * 🔑 That worked! But let's try to create another user with that same email address, as follows:

    ```json
    {
      "username": "test2",
      "email": "test1@email.com",
      "password": "Password123"
    }
    ```

  * 🔑 We get another `400 Bad Request` status code returned with a new error, as follows:

    ```json
    {
      "name": "SequelizeUniqueConstraintError",
      "errors": [
        {
          "message": "user.email must be unique",
          "type": "unique violation",
        }
      ]
    }
    ```

  * In this way, we can use validators and constraints on a Sequelize model to prevent bad data from entering the database.

* Open `13-Ins_Validation/models/User.js` in your IDE and explain the following:

  * We see a `User` model with an `id`, `username`, `email`, and `password`. In the `email` attribute, we see the constraint `unique` set to `true`, as follows:

    ```js
    email: {
      type: DataTypes.STRING,
      unique: true,
    }
    ```

    This will prevent duplicate email addresses from being saved in the database.

  * Constraints are rules defined at the SQL level. If a constraint check fails, an error will be thrown by the database and Sequelize will forward this error to JavaScript.

  * Next, we also see a model validator to check if the email is in the correct email format, as follows: 

    ```js
    email: {
      type: DataTypes.STRING,
      unique: true,
      validate: {
        isEmail:true,
      }
    }
    ```

  * Validations are checks performed in the Sequelize level, in pure JavaScript. Validations are automatically run on `create`, `update` and `save`.

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How would we build this?

  * 🙋 We will need to add validators and constraints to the `User` model to prevent any bad data from being saved in the database. 

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `14-Stu_Validation/README.md`.

### 6. Student Do: Validation (15 min) 

* Direct students to the activity instructions found in `14-Stu_Validation/README.md`.

* This activity uses **unit tests** to guide the students in creating the right validators and constraints. 

* If needed, explain what the `npm run test` script does and demonstrate how to run `npm run test` to run the unit tests.

* Break your students into pairs that will work together on this activity.

```md
# 📖 Add Validations and Constraints to the User Model

Work with a partner to implement the following user story:

* As a developer, I want to add validations and constraints to the User model to prevent bad data from being saved in the database.

## Acceptance Criteria

* It's done when it prevents `null` values from being entered for the username, email, and password fields.

* It's done when it prevents the password from being shorter than eight characters.

* It's done when it prevents the username from having any other characters other than letters and numbers. 

## 📝 Notes

Refer to the documentation: 

* [Sequelize Manual on Validations and Constraints](https://sequelize.org/master/manual/validations-and-constraints.html)

---

## 💡 Hints

* Run `npm run test` in your command line to run the unit tests. Use the tests to guide you.

* What built-in validators can we use to accomplish this?

## 🏆 Bonus

If you have completed this activity, work through the following challenge with your partner to further your knowledge:

* What are regular expressions?

Use [Google](https://www.google.com) or another search engine to research this.
```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students that need extra help.

### 7. Instructor Review: Validation (10 min) 

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How comfortable do you feel with validations and constraints for your models in Sequelize? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help!

* Use the prompts and talking points below to review the following key (🔑) points:

  * ✔️ `allowNull`

  * ✔️ `isAlphanumeric`

  * ✔️ `len`

* Open `14-Stu_Validation/Solved/models/User.js` in your IDE and explain the following: 

  * 🔑 First, we want to make sure we prevent `null` values from being entered for all fields. For that we use the `allowNull` constraint and set it to `false`, as follows:

    ```js
    username: {
      type: DataTypes.STRING,
      // prevents null values
      allowNull: false,
    },
    email: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    password: {
      type: DataTypes.STRING,
      allowNull: false,
    },
      ```

  * 🔑 Next, for the password, we want to make sure it is longer than eight characters. So we use a build-in validator called `len` and specify the character count, as shown in the following example:

    ```js
    password: {
      type: DataTypes.STRING,
      allowNull: false,
      // must be longer than 8 characters
      validate: {
        len: [8],
      },
    },
    ```

  * 🔑 Finally, for the username, we only want to allow letters and numbers, no symbols or other characters. For that, we use another build-in validator called `isAlphanumeric` and set it to `true`, as shown in the following example:

    ```js
    username: {
      type: DataTypes.STRING,
      allowNull: false,
      // will only allow alphanumeric characters
      validate: {
        isAlphanumeric: true,
      },
    },
    ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How can the `isAlphanumeric` validator be written using regular JavaScript?

  * 🙋 We can break it down by saying we will only allow letters between A and Z as well as numbers 0 to 9. That kind of logic is what RegEx, or regular expressions, uses when finding patterns in text.

  * ☝️ What can we do if we don't completely understand this?

  * 🙋 We can refer to supplemental material, read the [Sequelize Manual on Validations and Constraints](https://sequelize.org/master/manual/validations-and-constraints.html), and stick around for office hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 8. Instructor Demo: Password Hashing (5 min) 

* Navigate to `15-Ins_Password-Hashing` and be sure to change the `.env.EXAMPLE` file into your own `.env` file with your credentials. 

* Open `15-Ins_Password-Hashing/routes/api/userRoutes.js` in your IDE and demonstrate the following:

  * Like we discussed in the beginning of class, password hashing is very important in securing the user's data in the database. An application's first interaction with a user's password occurs the moment that user creates an account. 
  
  * At that time, we must intervene and hash the plaintext password before it is stored in the database. To do this, we use a node package called, `bcrypt`. 

  * 🔑 First, we import `bcrypt` into the `userRoutes.js` file by adding the `require` expression at the top of the file, as shown in the following code:

    ```js
    const bcrypt = require('bcrypt');
    ```

  * 🔑 In the POST route to create a new user, we take the data for a new user from `req.body` and assign it to `newUser`, as shown in the following code:

    ```js
    router.post('/', async (req, res) => {
      try {
        const newUser = req.body;
    ```

  * 🔑 Then, in the `bcrypt` hash function, we pass in the `req.body.password`, which is the plaintext password the user entered. We also pass in a `saltRound` value of 10. The resulting hashed password is then saved as the `newUser.password`, as follows:

    ```js
    router.post('/', async (req, res) => {
      try {
        const newUser = req.body;
        newUser.password = await bcrypt.hash(req.body.password, 10);
    ```

  * We then create a new user using the `newUser` data with the hashed password and save it in the database, as follows:

    ```js
    router.post('/', async (req, res) => {
      try {
        const newUser = req.body;
        newUser.password = await bcrypt.hash(req.body.password, 10);
        const userData = await User.create(newUser);
    ```

* Run `npm start` in your command line and demonstrate the following in Insomnia Core:

  * We will make a POST request to `localhost:3001/api/users/` to create a new user and notice that the password is "Password123" in plaintext, as shown in the following example:

    ```json
    {
      "username": "test2",
      "email": "test2@email.com",
      "password": "Password123"
    }
    ```

  * When we see the returned data, we see that the password that is actually saved in the database is hashed and salted&mdash;as shown in the following example:

    ```json
    {
      "id": 4,
      "username": "test2",
      "email": "test2@email.com",
      "password": "$2b$10$pQgQagcm85YW1b/0j5MrU.iH2iSCsne.FAMjcxp6izuXEJH.lgiqS"
    }
    ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How would we build this?

  * 🙋 We will need to use `bcrypt` to hash the password before saving a new user in the database.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `16-Stu_Password-Hashing/README.md`.

### 9. Student Do: Password Hashing (15 min) 

* Direct students to the activity instructions found in `16-Stu_Password-Hashing/README.md`.

* Break your students into pairs that will work together on this activity.

```md
# 📐 Add Comments to Implementation of the Login Route

Work with a partner to add comments describing the functionality of the code found in [Unsolved](./Unsolved/routes/api/user-routes.js).

## 📝 Notes

Refer to the documentation: 

[NPM Docs on bcrypt](https://www.npmjs.com/package/bcrypt)

---

## 🏆 Bonus

If you have completed this activity, work through the following challenge with your partner to further your knowledge:

* How can we persist a login state?

Use [Google](https://www.google.com) or another search engine to research this.
```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students that need extra help. 

### 10. BREAK (15 min)

### 11. Instructor Review: Password Hashing (10 min) 

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How comfortable do you feel with password hashing using `bcrypt`? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help!

* Use the prompts and talking points below to review the following key (🔑) points:

  * ✔️ `findOne()`

  * ✔️ `res.status(404)`

  * ✔️ `bcrypt.compare()`

  * ✔️ `res.status(400)`

* Open `16-Stu_Password-Hashing/Solved/routes/api/userRoutes.js` in your IDE and explain the following: 

  * For this reverse engineering activity, we had to add comments describing the `login` route.

  * 🔑 First, we need to search the database for a user with the provided email that the user used to login. We do that by using `.findOne()`, as follows:

    ```js
    router.post('/login', async (req, res) => {
      try {
        const userData = await User.findOne({ where: { email: req.body.email } });
    ```

  * 🔑 If we cannot find anything in the database with that email address, we need to return a `404` status code with an error message. 
  
  * However, be careful not to specify that the login failed because of a wrong email or password. Otherwise it is easier for someone who was trying to hack into the system to know which part of the login info they got wrong! Refer to the following message for an example:

    ```js
    if (!userData) {
      res.status(404).json({ message: 'Login failed. Please try again!' });
      return;
    }
    ```

  * 🔑 If the user is found in the database, then we use `bcrypt.compare()` to compare the provided password and the hashed password that is saved in the database, as follows:

    ```js
    const validPassword = await bcrypt.compare(
      req.body.password,
      userData.password
    );
    ```

  * 🔑 If the password does not match, then we need to return a `400` status code with an error message. Again, we shouldn't specify what was wrong with the login info provided. See the following message for an example:

    ```js
    if (!validPassword) {
      res.status(400).json({ message: 'Login failed. Please try again!' });
      return;
    }
    ```

  * If everything goes well, we return a `200` status code with a success message, as follows:

    ```js
    res.status(200).json({ message: 'You are now logged in!' });
    ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ Rather than doing this in the routes, where is a better place to handle password hashing?

  * 🙋 The User model! Because the password is directly related to the User model, it is better to handle the password hashing using Hooks in the model file.

  * ☝️ What can we do if we don't completely understand this?

  * 🙋 We can refer to supplemental material, read the [NPM Docs on bcrypt](https://www.npmjs.com/package/bcrypt), and stick around for office hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 12. Instructor Demo: Hooks (5 min) 

* Navigate to `17-Ins_Hooks` and be sure to change the `.env.EXAMPLE` file into your own `.env` file with your credentials. 

* Open `17-Ins_Hooks/models/User.js` in your IDE and demonstrate the following:
  
  * As we've seen so far, Sequelize offers many tools that make it easier for us to communicate with the database. Hooks are another tool that help us preform actions before and after calls in Sequelize are executed. 

  * 🔑 There is a long list of Hooks that are available to us through Sequelize but we will only touch on `beforeCreate()` and `beforeUpdate()` today. 

  * 🔑 There are a few ways to declare Hooks. For this activity, we will declare a Hook via the `.init()` method in the User model. 

  * 🔑 When including Hooks via the `.init()` method, we add them between where the model attributes are defined and where the connection instance is passed, as follows:

    ```js
    User.init(
      {
        //model attributes
      },
      {
        hooks: {
          // hooks
        },
        ///connection instance
      }
    );
    ```

  * For the `beforeCreate()` and `beforeUpdate()` Hooks, we are passing `newUserData` into each so that whenever a user instance is created or updated, the Hooks have access to the user's data.

  * 🔑 The `beforeCreate()` method accepts `newUserData`, uses `toLowerCase()` to set the user's email address to lower case, and then returns `newUserData` with the newly formatted email address&mdash;as shown in the following example:

    ```js
    beforeCreate: async (newUserData) {
      newUserData.email = await newUserData.email.toLowerCase();
      return newUserData;
    },
    ```

  * 🔑 `beforeUpdate()`is identical to `beforeCreate()` in the User model, as follows:

    ```js
    beforeUpdate: async (newUserData) {
      newUserData.email = await newUserData.email.toLowerCase();
      return newUserData;
    },
    ``` 

  * However, there is one small difference regarding the `beforeUpdate()` Hook, located in `userRoutes.js`. 

  * Open `17-Ins_Hooks/routes/api/userRoutes.js` and scroll down to the PUT route. 

  * We add the option `individualHooks: true` because the `.update()` method could potentially match more than one entry and we want the Hook to run on each match. Refer to the following code for an example:

    ```js
    router.put('/:id', async (req, res) => {
      try {
        const userData = await User.update(req.body, {
          where: {
            id: req.params.id,
          },
          individualHooks: true
        });
    ```

* To test the Hooks, run `npm start` from the command line and demonstrate the following in Insomnia Core: 

  * 🔑 We will make a POST request to `http://localhost:3001/api/users` to create a new user. Notice that the email address is capitalized in the body of the request, as follows:

    ```json
    {
      "username": "test",
      "email": "TEST@email.com",
      "password": "Password123"
    }
    ```

  * 🔑 When the data is returned, we should see that the email address has been saved in lower case, as follows:

    ```json
    {
      "username": "test",
      "email": "test@email.com",
      "password": "Password123"
    }
    ```

  * 🔑 We will make a PUT request to `http://localhost:3001/api/users/1` to update the user we just created, as shown in the following example:

    ```json
    {
      "username": "test",
      "email": "TEST1234@email.com",
      "password": "Password123"
    }
    ```

  * 🔑 When the data is returned, we should see that the email address has been updated and stored in lower case, as shown in the following example: 

    ```json
    {
      "username": "test",
      "email": "test1234@email.com",
      "password": "Password123"
    }
    ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How can we use Hooks to automate `bcrypt` password hashing for users?

  * 🙋 We will need to add Hooks to the `User` model to hash passwords for user instances before they are created or updated.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `18-Stu_Hooks/README.md`.

### 13. Student Do: Hooks (15 min)

* Direct students to the activity instructions found in `18-Stu_Hooks/README.md`.

* Break your students into pairs that will work together on this activity.

```md
# 🏗️ Use Hooks to Hash a Password

Work with a partner to implement the following user story:

* As a user, I want to be able to login with my password.

* As a user, I want to be able to change my password.

* As a user, I want to know that my password is being stored securely.

## Acceptance Criteria

* It's done when `User.int()` includes Hooks to hash the user's password before it is created.

* It's done when `User.int()` includes Hooks to hash the user's password before it is updated.

## 💡 Hints

* What did you learn about hashing a password, `async` and `await`, and `try...catch` in previous lessons? 

* What are three methods for adding Hooks to your code? How is adding a Hook via `init()` different from the other options?

## 🏆 Bonus

If you have completed this activity, work through the following challenge with your partner to further your knowledge:

* Hooks are considered **middleware** in programming terms. What are some other examples of middleware used in Node applications?

Use [Google](https://www.google.com) or another search engine to research this.
```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students that need extra help. 

### 14. Instructor Review: Hooks (10 min) 

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How comfortable do you feel with using Hooks in Sequelize? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help!

* Use the prompts and talking points below to review the following key (🔑) points:

  * ✔️ `beforeCreate()`

  * ✔️ `beforeUpdate()`

  * ✔️ Use `bcrypt` to hash password inside Hooks

* Open `18-Stu_Hooks/Solved/models/User.js` in your IDE and explain the following: 

  * 🔑 We create a `beforeCreate()` Hook in the `User.js` file to make sure that a user can create a profile and that their password will be stored securely with `bcrypt` before the record is stored, as shown in the following example:

    ```js
    beforeCreate: async (newUserData) => {
      newUserData.password = await bcrypt.hash(newUserData.password, 10);
      return newUserData;
    }  
    ```

  * 🔑 The user's password is set as equal to a hashed password, using `bcrypt`. Then `newUserData` is returned, as follows:

    ```js
    beforeCreate: async (newUserData) => {
      newUserData.password = await bcrypt.hash(newUserData.password, 10);
      return newUserData;
    }   
    ```

  * `async` and `await` are included in the method, to write cleaner code that enables Promise-based behavior, as follows:

    ```js
    beforeCreate: async (newUserData) => {
      newUserData.password = await bcrypt.hash(newUserData.password, 10);
      return newUserData;
    }  
    ```
  
  * 🔑 We can repeat the previous steps to create the `beforeUpdate()` method, as follows:

    ```js
    beforeUpdate: async (updatedUserData) => {
      updatedUserData.password = await bcrypt.hash(updatedUserData.password, 10);
      return updatedUserData;
    }
    ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ What are some other commonly used Hooks that are available to us?

  * 🙋 `afterCreate`, `afterUpdate`, `beforeDestroy`, `afterDestroy`, etc.

  * ☝️ What can we do if we don't completely understand this?

  * 🙋 We can refer to supplemental material, read the [Sequelize Manual on Hooks](https://sequelize.org/master/manual/hooks.html), and stick around for office hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 15. Instructor Demo: Instance Methods (5 min) 

* Navigate to `19-Ins_Instance-Method` and be sure to change the `.env.EXAMPLE` file into your own `.env` file with your credentials. 

* Open `19-Ins_Instance-Method/models/User.js` in your IDE and demonstrate the following:

  * 🔑 Sometimes we need to work with data that is stored within an instance. For example, maybe we want to know if a user in a pet adoption database currently has any pets. 
  
  * We don't want to use 'GET' to return all of that user's information because we only need to know if that user has pets or not. This is where instance methods can be useful.

  * 🔑 Sequelize allows us to write instance methods within models (in this example, the `User` model) to give us access to specific data that we can then return to users. 
  
  * Let's look at `User.js`. In the following example, to create a user instance for the pet adoption database, we must include the number of pets that we currently have:

    ```js
    User.init(
      {
        // previous model attributes above...
        
        numberOfPets: {
          type: DataTypes.INTEGER,
        },
      },
    )
    ```

* Run `npm start` from the command line and demonstrate the following in Insomnia Core: 

  * 🔑 We will make a POST request to `http://localhost:3001/api/users` to create a new user. We've set `numberOfPets` equal to 2, as follows, because the user has two pets:

    ```json
    {
      "username": "test",
      "email": "test@email.com",
      "password": "Password123",
      "numberOfPets": 2
    }
    ```

  * 🔑 When the data is returned, we should see that the user's pets have been stored in the record, as follows: 

    ```json
    {
      "username": "test",
      "email": "test@email.com",
      "password": "Password123",
      "numberOfPets": 2
    }
    ```

  * We can imagine that many of the users in this pet adoption database might not have pets yet, so let's create another user to reflect that. See the following code for an example:

    ```json
    {
      "username": "test2",
      "email": "test2@email.com",
      "password": "Password890",
      "numberOfPets": 0
    }
    ```

  * When the data is returned, we should see that this user's pets have been stored in the record as `"numberOfPets": 0`. Refer to the following code for an example:

    ```json
    {
      "username": "test2",
      "email": "test2@email.com",
      "password": "Password890",
      "numberOfPets": 0
    }
    ```

  * We created the users, now we want to check to see if a user has pets or not without returning ALL of their information by creating an instance method.

  * 🔑 Let's look at the user model in `User.js`. Notice that we have a simple instance method called, `hasPets` at the top. 
  
  * Inside of the instance method we use a conditional statement to check if `this.numberOfPets` (where `this` represents one particular user) is greater than 0. If the number is greater than 0, it returns `true`. Otherwise, it returns `false`. Refer to the following statement for an example:

    ```js
    class User extends Model {
      // This instance method uses a conditional statement to check if a user has pets
      hasPets() {
      if (this.numberOfPets > 0) {
          return true;
        } else {
        return false;
        }
      }
    }
    ```

  * The instance method checks to see if a user has any pets, but now we need to make sure that the user can actually use this method. To do that, we also need to write a custom route.

* 🔑 Open `19-Ins_Instance_Method/routes/api/userRoutes.js` in your IDE and demonstrate the following:

  * 🔑 Notice that we've included a new route specifically for the instance method, `hasPets`, as follows: 

    ```js
    router.post('/:id/hasPets', async (req, res) => {

    }
    ```
  
  * First, we find a user using their primary key (provided by params). If `userData` evaluates as `false` (no user exists with that primary key), then we will send an error message&mdash;as shown in the following example:

    ```js
    try {
      const userData = await User.findByPk(req.params.id);
      if (!userData) {
        res.status(404).json({ message: 'No user with this id!' });
        return;
      }
    ```
  
  * If a user does exist at the primary key, we get to use the instance method that we wrote in `User.js` to see if that user has pets, as follows: 

    ```js
    const petData = await userData.hasPets(req.body.numberOfPets);
    ```
  
  * If `petData` evaluates as false (the user has 0 pets), then the user will receive the message, "This person has no pets." See the following code for an example:
  
    ```js
    if (!petData) {
      res.status(400).json({ message: 'This person has no pets.' });
      return;
    }
    ```

  * Otherwise, the user will see the message "This person has pets!" The code here should look something like the following example:

  ```js
  res.json({ message: 'This person has pets!' });
  ```
  
* If you have time, run `npm start` from the command line and demonstrate the following in Insomnia Core: 

  * 🔑 We will make a POST request to `http://localhost:3001/api/users/1/hasPets` to check the route and instance method.

  * 🔑 When the data is returned, we should see the following message, because the first user we created did have pets: 

    ```json
    {
      "message": "This person has pets!"
    }
    ```

  * 🔑 Now let's check the second user. We will make a POST request to `http://localhost:3001/api/users/2/hasPets`.

  * 🔑 When the data is returned, we should see the following message, because the second user we created had 0 pets: 

    ```json
    {
      "message": "This person has no pets."
    }
    ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How would we retrun specific data about one instance?

  * 🙋 We will add an instance method inside the model to return specific data about one instance. 

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `20-Stu_Instance-Method/README.md`.

### 16. Student Do: Instance Methods (15 min) 

* Direct students to the activity instructions found in `20-Stu_Instance-Method/README.md`.

* Break your students into pairs that will work together on this activity.

```md
# 🏗️ Create a Custom Instance Method

Work with a partner to implement the following user story:

* As a user, I want to log in to my account with my password.

* As a developer, I want to allow a user to log in to their account securely so that their password information isn't compromised 

## Acceptance Criteria

* It's done when the model includes an instance method.

* It's done when the instance method compares the user's input with the user's hashed password.

## 💡 Hints

* What tools does bcrypt offer to help us compare user input to a hashed password?

## 🏆 Bonus

If you have completed this activity, work through the following challenge with your partner to further your knowledge:

* How can we DRY up the code using Sequelize's static model methods?

Use [Google](https://www.google.com) or another search engine to research this.
```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students that need extra help. 

### 17. Instructor Review: Instance Methods (15 min)

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How comfortable do you feel with adding `instance methods` to your models? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help!

* Use the prompts and talking points below to review the following key (🔑) points:
  
  * ✔️ Build out the instance method `checkPassword()`

  * ✔️ Use `bcrypt.compareSync()` to check the user's password

* Open `20-Stu_Instance-Methods/Solved/routes/api/userRoutes.js` in your IDE and explain the following: 

  * The `checkPassword()` instance method is used in the `/login` route. Understanding how `checkPassword()` is being used in the `/login` route can give us clues to what the instance method needs to accomplish. 

  * We can tell from the `/login` route that the instance method will need to take in the user's password (from `req.body`) as an argument and then determine if it matches the password stored in that user's record&dash;as shown in the following example.

    ```js
    router.post('/login', async (req, res) => {
      
      const validPassword = await userData.checkPassword(req.body.password);
      if (!validPassword) {
        res
          .status(400)
          .json({ message: 'Incorrect email or password, please try again' });
        return;
      }
      res.json({ user: userData, message: 'You are now logged in!' });
      };
    ```

* Open `20-Stu_Instance-Methods/Solved/models/User.js` in your IDE and explain the following: 

  * 🔑 First, we want to write the instance method `checkPassword()` inside the user model in `User.js`, as follows: 

    ```js
    class User extends Model {
      checkPassword(loginPw) {
        
        }
    }
    ```

  * 🔑 `bcrypt` offers a method called `compareSync()` that allows us to easily check a password. As shown in the following example, it takes two arguments&mdash;`loginPw` (the password sent in the body of the POST request) and `this.password` (the password stored in this particular user record): 

    ```js
    class User extends Model {
      checkPassword(loginPw) {
        bcrypt.compareSync(loginPw, this.password);
        }
    }
    ```

  * Remember the `/login` route expects `checkPassword()` to evaluate as either `true` or `false`. `compareSync` returns a Boolean, so all we need to do is return it in the instance method, as follows:

    ```js
    class User extends Model {
      checkPassword(loginPw) {
        return bcrypt.compareSync(loginPw, this.password);
      }
    }
    ```
  
* If you have time, run `npm start` from the command line and demonstrate the following in Insomnia Core: 

  * We will make a POST request to `http://localhost:3001/api/users` to create a new user, as shown in the following example:

    ```json
    {
      "username": "test",
      "email": "test@email.com",
      "password": "Password123"
    }
    ```

  * When the data is returned, notice that the password is hashed because `User.js` includes a `beforeCreate` Hook that uses `bcrypt` to hash the user's password, as follows: 

    ```json
    {
      "id": 1,
      "username": "test",
      "email": "test@email.com",
      "password": "$2b$10$ItAeYIqhuEzADqxHsMe6Mu.r3lzZ.Ewb0gnWw0md3OkRsqPnFKbbG"
    }
    ```

  * Now, we will make a POST request to `http://localhost:3001/api/users/login` to log in, as shown in the following example:

    ```json
    {
      "email": "test@email.com",
      "password": "Password123"
    }
    ```

  * If the code is working, we should see the following message when the data is returned:  

    ```json
    {
      "user": {
        "id": 1,
        "username": "test",
        "email": "test@email.com",
        "password": "$2b$10$ItAeYIqhuEzADqxHsMe6Mu.r3lzZ.Ewb0gnWw0md3OkRsqPnFKbbG"
      },
      "message": "You are now logged in!"
    }
    ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ When do you need to incorporate an instance method into your model?

  * 🙋 When you need to get data or do something related to one specific instance of a model.

  * ☝️ What can we do if we don't completely understand this?

  * 🙋 We can refer to supplemental material, read the [Sequelize Manual on Model Instances](https://sequelize.org/master/manual/model-instances.html), and stick around for office hours to ask for help.

* Answer any questions before ending the class.

### 18. END (0 min)

How did today’s lesson go? Your feedback is important. Please take 5 minutes to complete this [anonymous survey](https://forms.gle/RfcVyXiMmZQut6aJ6).

---
© 2020 Trilogy Education Services, LLC, a 2U, Inc. brand. Confidential and Proprietary. All Rights Reserved. 