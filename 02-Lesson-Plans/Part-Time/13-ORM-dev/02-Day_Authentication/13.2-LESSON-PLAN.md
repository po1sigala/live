# 13.2 Part-Time Lesson Plan: Object Relational Mapping (ORM)

## Overview 

In today's class, students will continue to learn Sequelize and be formally introduced to RESTful API paradigms. Along with `async / await`, they will incorporate `try / catch` in order to properly catch the errors and return them to the user. Students will incorporate validators and constraints to the Sequelize models in order to prevent bad data from being saved into the database. Students will learn about password hashing using `bcrypt`, incorporating hooks, and creating a login route in order for users to securely login. They will create a custom method that corresponds to a custom route. 

## Instructor Notes

* Complete activities `11-Ins_RESTful-Routes` through `20-Stu_Instance-Method`.

* Do a quick Google search of "data breaches this year" to look up a list of businesses that were affected this year. You can refer to this list as you are doing the `Stoke Curiosity` section.

* Be sure to prepare and read over the activities before your class begins. Try to anticipate any questions students may have.

* You will be using MySQL for today's activities. Be sure to have your MySQL server up and running. Go ahead and create the database `user_db` ahead of time, or demonstrate it live in class.

* All of the activities will be using Insomnia Core to test the routes, instead of relying on a front end. Be sure to have it installed and ready for all activities. 

* Remind students to do a `git pull` of the class repo to have today's activities ready and open in VS Code. 

* If you are comfortable doing so, live code the solutions to the activities. If not, no worries. Use the solutions provided and follow the prompts and talking points for review. 

* Let students know that the Bonus for each activity is meant to give them "food for thought". Rather than extra coding practice, it is a self-study on related topics that are beyond the scope of this unit for those who want to dig deeper and further their knowledge on this topic.

## Learning Objectives

By the end of class, students will be able to:

* Utilize `try/catch` to catch errors

* Ensure HTTP requests respond with the correct status code

* Utilize validation tools on a Sequelize model

* Utilize `bcrypt` to encrypt a password

* Automate functionality using Sequelize hooks

* Create and run a custom method on a Sequelize instance

## Time Tracker

| Start  | #   | Activity Name                       | Duration |
|---     |---  |---                                  |---       |
| 6:30PM | 1   | Instructor Do: Stoke Curiosity      | 0:10     |
| 6:40PM | 2   | Instructor Demo: RESTful Routes     | 0:05     |
| 6:45PM | 3   | Student Do: RESTful Routes          | 0:15     |
| 7:00PM | 4   | Instructor Review: RESTful Routes   | 0:10     |
| 7:10PM | 5   | Instructor Demo: Validation         | 0:05     |
| 7:15PM | 6   | Student Do: Validation              | 0:15     |
| 7:30PM | 7   | Instructor Review: Validation       | 0:10     |
| 7:40PM | 8   | Instructor Demo: Password Hashing   | 0:05     |
| 7:45PM | 9   | Student Do: Password Hashing        | 0:15     |
| 8:00PM | 10  | BREAK                               | 0:15     |
| 8:15PM | 11  | Instructor Review: Password Hashing | 0:10     |
| 8:25PM | 12  | Instructor Demo: Hooks              | 0:05     |
| 8:30PM | 13  | Student Do: Hooks                   | 0:15     |
| 8:45PM | 14  | Instructor Review: Hooks            | 0:10     |
| 8:55PM | 15  | Instructor Demo: Instance Method    | 0:05     |
| 9:00PM | 16  | Student Do: Instance Method         | 0:15     |
| 9:15PM | 17  | Instructor Review: Instance Method  | 0:15     |
| 9:30PM | 18  | END                                 | 0:00     |

---

## Class Instruction

### 1. Instructor Do: Stoke Curiosity (10 min)

* Welcome students to class.

* The topic of today's lesson is authentication. Using the prompts below, have a discussion about the importance of securing data.

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ In this day and age, it is becoming very important to secure sensitive data. What are some sensitive data that you would like to protect?

  * 🙋 Banking information. Social security number. Tax information. Credit card information.

  * ☝️ On the internet, one of the most important pieces of data you would want to protect is your password. What can happen if your password is compromised?

  * 🙋 Our online accounts can be hacked. Sensitive data will be exposed. Identity theft can happen. 

  * ☝️ Unfortunately, this happens all the time and we hear about data breaches on the news. Can you recall a recent data breach? Or maybe a time when your account was hacked?

  * 🙋 { Answers will vary. Refer to the Google results you looked up, per Instructor Notes. }

  * ☝️ As a user, that's why it is so important to change your passwords frequently and use secure passwords. But as web developers, what can we do to prevent data breaches?

  * 🙋 We can "scramble" the password that the user uses so that it doesn't resemble the user's password when we save it in our database. This is called password hashing.
  
  * 🙋 But on top of that, we can also "salt" our passwords, meaning we can add additional random data to the hashed password to truly make it unique.
  
  * 🙋 The ideal authentication platform should use both hashing and salting, and we will learn how to do just that in this class using a node package called `bcrypt`!
  
* Answer any questions before proceeding to the next activity.

### 2. Instructor Demo: RESTful Routes (5 min) 

* Navigate to `11-Ins_RESTful-Routes` and run `npm install`. Be sure to change the `.env.EXAMPLE` file into your own `.env` file with your credentials. 

* Run `npm start` from the command line and demonstrate the following in Insomnia Core: 

  * 🔑 Before we look at the code, let's create a user in our database. We can do that by making a POST request to `localhost:3001/api/users/` and providing the following JSON data as the body of the request in Insomnia Core:

  ```json
  {
    "username": "user1",
    "email": "user1@email.com",
    "password": "Password123"
  }
  ```

  * 🔑 We can check if that was saved correctly by making a GET request to that same URL `localhost:3001/api/users/`. We should see the following response as well as a `200 OK` status code:

  ```json
  [
    {
      "id": 1,
      "username": "user1",
      "email": "user1@email.com",
      "password": "Password123"
    }
  ]
  ```

* Open `11-Ins_RESTful-Routes/routes/api/userRoutes.js` in your IDE and explain the following:

  * As you can see, both routes are using `async/await` and are fully functional. However the POST route uses a `catch` block to catch any and _all_ errors that may happen in the `try` block. 

  ```js
  // the route will 'try' to do this action first
  try {
    const userData = await User.create(req.body);
    res.status(200).json(userData);

  // if there are any errors, it will 'catch' all of them here:
  } catch (err) {
    res.status(400).json(err);
    }
  ```

  * `try/catch` not only makes the code easier to read, but it will allow us to catch all of the errors in one place.

  * Also, the point of using `async/await` is to avoid callbacks, so it doesn't make sense to use the `.catch()` callback to catch errors, like in the GET route:

  ```js
  router.get('/', async (req, res) => {
    const userData = await User.findAll().catch((err) => {
      res.json(err);
    });
    res.json(userData);
  });
  ```

  * Note also in the POST route, we incorporated proper HTTP status codes in order to know exactly what kind of error happened with the server. We use the `.status(xxx)` syntax to return the status code along with the error in JSON format.

  ```js
  catch (err) {
    // 400 status code means the server could not understand the request
    res.status(400).json(err);
  }
  ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How would we build this?

  * 🙋 We will need to use `try/catch` to catch the errors and send back the proper status codes along with the JSON response. 

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `12-Stu_RESTful-Routes/README.md`.

### 3. Student Do: RESTful Routes (15 min) 

* Direct students to the activity instructions found in `12-Stu_RESTful-Routes/README.md`.

* Break your students into pairs that will work together on this activity.

```md
# 🐛 Routes send back 200 status code every time

Work with a partner to resolve the following issue(s):

* As a developer, I want to see proper HTTP status codes returned so I can be aware of any errors.

* As a developer, I want to use `try/catch` to properly catch errors when using `async/await`.

## Expected Behavior

* When there is no error with the request, the 200 status code is returned.

* When there is an internal server error, the 500 status code is returned.

* When a user does not exist in the database, the 404 status code is returned along with a message "No user found with this id!".

## Actual Behavior

* Whether there is an error with the request or if the user does not exist in the database, the 200 status code is returned.

## Steps to Reproduce the Problem

1. Run `npm start` in your command line to start the server.

2. Open Insomnia Core and make a GET request to `api/users/10`.

3. Notice the 200 status code returned.

## Assets

The following code block demonstrates the expected JSON response:

{
  "message": "No user with this id!"
}

---

## 💡 Hint(s)

* How do we return HTTP status codes?

## 🏆 Bonus

* If you have fully completed the above tasks, here is something you and your partner can work through as an added challenge to further your knowledge:

  * What are some other common HTTP status codes?

* Use [Google](https://www.google.com) or another search engine to research the above.
```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students that need extra help while circulating through room.

### 4. Instructor Review: RESTful Routes (10 min) 

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How comfortable do you feel with `try/catch` and `HTTP status codes`? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help!

* Use the prompts and talking points below to review the following key (🔑) points:

  * ✔️ `try/catch`

  * ✔️ `200` status code

  * ✔️ `500` status code 

  * ✔️ `404` status code 

* Open `12-Stu_RESTful-Routes/Solved/routes/api/userRoutes.js` in your IDE and explain the following: 

  * Here we see a GET route to get one user by its `id`, a PUT route to update a user, and a DELETE route to delete a user.

  * 🔑 Remember we incorporated `try/catch` into all three routes to catch all of the errors that might happen in the `try` block.

  * 🔑 First, if there is no error with the request, the `200 OK` status code is returned.

  ```js
  res.status(200).json(userData);
  ```

  * 🔑 If there is an internal server error, the `500 Internal Server Error` status code is returned.

  ```js
  catch (err) {
    res.status(500).json(err);
  }
  ```
  
  * 🔑 If the user does not exist in the database, the `404 Not Found` status code is returned. But first, in order to check if the user exists in the database or not, we need to use an `if` statement:

  ```js
  // GET a user
  router.get('/:id', async (req, res) => {
    try {
      const userData = await User.findByPk(req.params.id);
      if (!userData) {
        res.status(404).json({ message: 'No user with this id!' });
        return;
      }
      res.status(200).json(userData);
    } catch (err) {
      res.status(500).json(err);
    }
  });
  ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ Why should we use `try/catch` to catch errors when using `async/await`?

  * 🙋 Sometimes, the promise may take some time before it rejects; so in that case, there will be a delay before `await` throws an error. Since the point of `async/await` is to avoid using callbacks, we can use `try/catch` instead of using a `.catch()` callback to catch that error. Also we can wrap multiple lines in the `try` block, so that we can catch any and _all_ errors in the `catch` block. 

  * ☝️ How can the status codes be used to enhance the user experience on the front end?

  * 🙋 As a user, if I get a `4xx` status code returned, I would know I caused the error, whereas if I get a `5xx` status code returned, I would know that the server has a problem.

  * ☝️ What can we do if we don't completely understand this?

  * 🙋 We can refer to supplemental material, read the [MDN Web Docs on HTTP Response Status Codes](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status), and stick around for Office Hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 5. Instructor Demo: Validation (5 min) 

* Navigate to `13-Ins_Validation` and run `npm start` from the command line. Be sure to change the `.env.EXAMPLE` file into your own `.env` file with your credentials. 

* Demonstrate the following in Insomnia Core:

  * When it comes to securing and ensuring the quality of our data, it is important to prevent any bad data from being saved in our database. For example, what if the password is too short or not secure enough? Or, what if someone tries to sign up with the same email address twice? 

  * 🔑 Let's try to create a new user with the email address in the wrong email format. Make a POST request to `localhost:3001/api/users/` and provide the following JSON data as the body of the request in Insomnia Core:

  ```json
  {
    "username": "test1",
    "email": "test1",
    "password": "Password123"
  }
  ```

  * 🔑 We will get a `400 Bad Request` status code returned with an error:

  ```json
  {
    "name": "SequelizeValidationError",
    "errors": [
      {
        "message": "Validation isEmail on email failed",
        "type": "Validation error",
      }
    ]
    }
  ```

  * 🔑 This time we will create a new user with a correct email address:

  ```json
  {
    "username": "test1",
    "email": "test1@email.com",
    "password": "Password123"
  }
  ```

  * 🔑 That worked! But let's try to create another user with that same email address:

  ```json
  {
    "username": "test2",
    "email": "test1@email.com",
    "password": "Password123"
  }
  ```

  * 🔑 We get another `400 Bad Request` status code returned with a new error:

  ```json
  {
    "name": "SequelizeUniqueConstraintError",
    "errors": [
      {
        "message": "user.email must be unique",
        "type": "unique violation",
      }
    ]
  }
  ```

  * In this way, we can use validators and constraints on a Sequelize model to prevent bad data from entering our database.

* Open `13-Ins_Validation/models/User.js` in your IDE and explain the following:

  * We see a `User` model with an `id`, `username`, `email`, and `password`. In the `email` attribute, we see the constraint `unique` set to `true`. This will prevent duplicate email addresses from being saved in the database:

  ```js
  email: {
    type: DataTypes.STRING,
    unique: true,
  }
  ```

  * Constraints are rules defined at the SQL level. If a constraint check fails, an error will be thrown by the database and Sequelize will forward this error to JavaScript.

  * Next, we also see a model validator to check if the email is in the correct email format.

  ```js
  email: {
    type: DataTypes.STRING,
    unique: true,
    validate: {
      isEmail:true,
    }
  }
  ```

  * Validations are checks performed in the Sequelize level, in pure JavaScript. Validations are automatically run on `create`, `update` and `save`.

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How would we build this?

  * 🙋 We will need to add validators and constraints to the `User` model in order to prevent any bad data from being saved in the database. 

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `14-Stu_Validation/README.md`.

### 6. Student Do: Validation (15 min) 

* Direct students to the activity instructions found in `14-Stu_Validation/README.md`.

* This activity uses **unit tests** to guide the students in creating the right validators and constraints. 

* If needed, explain what the `npm run test` script does and demonstrate how to run `npm run test` to run the unit tests.

* Break your students into pairs that will work together on this activity.

```md
# 📖 Add validations and constraints to the User model

Work with a partner to implement the following user story:

* As a developer, I want to add validations and constraints to the User model in order to prevent bad data from being saved in the database.

## Acceptance Criteria

* It's done when it prevents `null` values from being entered for the username, email and password fields.

* It's done when it prevents the password from being shorter than 8 characters.

* It's done when it prevents the username from having any other characters other than letters and numbers. 

## 📝 Note(s)

Refer to the documentation: 

* [Sequelize Manual on Validations and Constraints](https://sequelize.org/master/manual/validations-and-constraints.html)

---

## 💡 Hint(s)

* Run `npm run test` in your command line to run the unit tests. Use the tests to guide you.

* What are some built-in validators that we can use to accomplish this?

## 🏆 Bonus

* If you have fully completed the above tasks, here is something you and your partner can work through as an added challenge to further your knowledge:

  * What are regular expressions?

* Use [Google](https://www.google.com) or another search engine to research the above.
```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students that need extra help while circulating through room.

### 7. Instructor Review: Validation (10 min) 

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How comfortable do you feel with `validations` and `constraints` for your models in Sequelize? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help!

* Use the prompts and talking points below to review the following key (🔑) points:

  * ✔️ `allowNull`

  * ✔️ `isAlphanumeric`

  * ✔️ `len`

* Open `14-Stu_Validation/Solved/models/User.js` in your IDE and explain the following: 

  * 🔑 First, we want to make sure we prevent `null` values from being entered for all fields. For that we use the `allowNull` constraint and set it to `false`.

  ```js
  username: {
    type: DataTypes.STRING,
    // prevents null values
    allowNull: false,
  },
  email: {
    type: DataTypes.STRING,
    allowNull: false,
  },
  password: {
    type: DataTypes.STRING,
    allowNull: false,
  },
    ```

  * 🔑 Next, for the password, we want to make sure it is longer than 8 characters. So we use a build-in validator called `len` and specify the character count:

  ```js
  password: {
    type: DataTypes.STRING,
    allowNull: false,
    // must be longer than 8 characters
    validate: {
      len: [8],
    },
  },
  ```

  * 🔑 Finally, for the username, we only want to allow letters and numbers, no symbols or other characters. For that, we use another build-in validator called `isAlphanumeric` and set it to `true`:

  ```js
  username: {
    type: DataTypes.STRING,
    allowNull: false,
    // will only allow alphanumeric characters
    validate: {
      isAlphanumeric: true,
    },
  },
  ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How can the `isAlphanumeric` validator be written using regular JavaScript?

  * 🙋 We can break it down by saying we will only allow letters between a to z as well as numbers 0 to 9. That kind of logic is what RegEx, or regular expressions, uses when finding patterns in text.

  * ☝️ What can we do if we don't completely understand this?

  * 🙋 We can refer to supplemental material, read the [Sequelize Manual on Validations and Constraints](https://sequelize.org/master/manual/validations-and-constraints.html), and stick around for Office Hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 8. Instructor Demo: Password Hashing (5 min) 

* Navigate to `15-Ins_Password-Hashing` and be sure to change the `.env.EXAMPLE` file into your own `.env` file with your credentials. 

* Open `15-Ins_Password-Hashing/routes/api/userRoutes.js` in your IDE and demonstrate the following:

  * Like we discussed in the beginning of class, password hashing is very important in securing the user's data in our database. An application's first interaction with a user's password occurs the moment that user creates an account. 
  
  * At that time, we must intervene and hash the plaintext password before it is stored in the database. To do this, we use a node package called, `bcrypt`. 

  * 🔑 First, we import `bcrypt` into the `userRoutes.js` file by adding the `require` expression at the top of the file, as shown in the following code:

  ```js
  const bcrypt = require('bcrypt');
  ```

  * 🔑 In the POST route to create a new user, we take the data for a new user from `req.body` and assign it to `newUser`:

  ```js
  router.post('/', async (req, res) => {
    try {
      const newUser = req.body;
  ```

  * 🔑 Then, in the `bcrypt` hash function, we pass in the `req.body.password`, which is the plaintext password the user entered. We also pass in a `saltRound` value of 10. The resulting hashed password is then saved as the `newUser.password`.

  ```js
  router.post('/', async (req, res) => {
    try {
      const newUser = req.body;
      newUser.password = await bcrypt.hash(req.body.password, 10);
  ```

  * We then create a new user using the `newUser` data with the hashed password and save it in the database.

  ```js
  router.post('/', async (req, res) => {
    try {
      const newUser = req.body;
      newUser.password = await bcrypt.hash(req.body.password, 10);
      const userData = await User.create(newUser);
  ```

* Run `npm start` in your command line and demonstrate the following in Insomnia Core:

  * We will make a POST request to `localhost:3001/api/users/` to create a new user and notice that the password is "Password123" in plaintext:

  ```json
  {
    "username": "test2",
    "email": "test2@email.com",
    "password": "Password123"
  }
  ```

  * When we see the returned data, we see that the password that is actually saved in the database is hashed and salted:

  ```json
  {
    "id": 4,
    "username": "test2",
    "email": "test2@email.com",
    "password": "$2b$10$pQgQagcm85YW1b/0j5MrU.iH2iSCsne.FAMjcxp6izuXEJH.lgiqS"
  }
  ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How would we build this?

  * 🙋 We will need to use `bcrypt` to hash the password before saving a new user in the database.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `16-Stu_Password-Hashing/README.md`.

### 9. Student Do: Password Hashing (15 min) 

* Direct students to the activity instructions found in `16-Stu_Password-Hashing/README.md`.

* Break your students into pairs that will work together on this activity.

```md
# 📐 Add Comments to Implementation of the login route

Work with a partner to add comments describing the functionality of the code found in [user-routes.js](./Unsolved/routes/api/user-routes.js).

## 📝 Note(s)

Refer to the documentation: 

[NPM Docs on bcrypt](https://www.npmjs.com/package/bcrypt)

---

## 🏆 Bonus

* If you have fully completed the above tasks, here is something you and your partner can work through as an added challenge to further your knowledge:

  * How can we persist a login state?

* Use [Google](https://www.google.com) or another search engine to research the above.
```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students that need extra help while circulating through room.

### 10. BREAK (15 min)

### 11. Instructor Review: Password Hashing (10 min) 

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How comfortable do you feel with `password hashing using bcrypt`? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help!

* Use the prompts and talking points below to review the following key (🔑) points:

  * ✔️ `findOne()`

  * ✔️ `res.status(404)`

  * ✔️ `bcrypt.compare()`

  * ✔️ `res.status(400)`

* Open `16-Stu_Password-Hashing/Solved/routes/api/userRoutes.js` in your IDE and explain the following: 

  * For this reverse engineering activity, we had to add comments describing the `login` route.

  * 🔑 First, we need to search the database for a user with the provided email that the user used to login. We do that by using `.findOne()`:

  ```js
  router.post('/login', async (req, res) => {
    try {
      const userData = await User.findOne({ where: { email: req.body.email } });
  ```

  * 🔑 If we cannot find anything in the database with that email address, we need to return a `404` status code with an error message. 
  
  * However, be careful not to specify that the login failed because of a wrong email or password. Otherwise it is easier for someone who was trying to hack into the system to know which part of the login info they got wrong!

  ```js
  if (!userData) {
    res.status(404).json({ message: 'Login failed. Please try again!' });
    return;
  }
  ```

  * 🔑 If the user is found in the database, then we use `bcrypt.compare()` to compare the provided password and the hashed password that is saved in the database.

  ```js
  const validPassword = await bcrypt.compare(
    req.body.password,
    userData.password
  );
  ```

  * 🔑 If the password does not match, then we need to return a `400` status code with an error message. Again, we shouldn't specify what was wrong with the login info provided.

  ```js
  if (!validPassword) {
    res.status(400).json({ message: 'Login failed. Please try again!' });
    return;
  }
  ```

  * If everything goes well, we return a `200` status code with a success message.

  ```js
  res.status(200).json({ message: 'You are now logged in!' });
  ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ Rather than doing this in the routes, where is a better place to handle password hashing?

  * 🙋 The User model! Since the password is directly related to the User model, it is better to handle the password hashing using hooks in the model file.

  * ☝️ What can we do if we don't completely understand this?

  * 🙋 We can refer to supplemental material, read the [NPM Docs on bcrypt](https://www.npmjs.com/package/bcrypt), and stick around for Office Hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 12. Instructor Demo: Hooks (5 min) 

* Navigate to `17-Ins_Hooks` and be sure to change the `.env.EXAMPLE` file into your own `.env` file with your credentials. 

* Open `17-Ins_Hooks/models/User.js` in your IDE and demonstrate the following:
  
  * As we've seen so far, Sequelize offers many tools that make it easier for us to communicate with our database. Hooks are another tool that help us preform actions before and after calls in Sequelize are executed. 

  * 🔑 There is a long list of hooks that are available to us through Sequelize but we will only touch on `beforeCreate()` and `beforeUpdate()` today. 

  * 🔑 There are a few ways to declare hooks. For this activity, we will declare a hook via the `.init()` method in the User model. 

  * 🔑 When including hooks via the `.init()` method, we add them between where the model attributes are defined and where the connection instance is passed.

  ```js
  User.init(
    {
      //model attributes
    },
    {
      hooks: {
        // hooks
      },
      ///connection instance
    }
  );
  ```

  * For the `beforeCreate()` and `beforeUpdate()` hooks, we are passing `newUserData` into each so that whenever a user instance is created or updated, the hooks have access to the user's data.

  * 🔑 The `beforeCreate()` method accepts `newUserData`, uses `toLowerCase()` to set the user's email to lower case, then returns `newUserData` with the newly formatted email.

  ```js
  beforeCreate: async (newUserData) {
    newUserData.email = await newUserData.email.toLowerCase();
    return newUserData;
  },
  ```

  * 🔑 `beforeUpdate()`is identical to `beforeCreate()` in the User model.

  ```js
  beforeUpdate: async (newUserData) {
    newUserData.email = await newUserData.email.toLowerCase();
    return newUserData;
  },
  ``` 

  * However there is one small difference regarding the `beforeUpdate()` hook, located in `userRoutes.js`. 

  * Open `17-Ins_Hooks/routes/api/userRoutes.js` and scroll down to the PUT route. 

  * We add the option `individualHooks: true` because the `.update()` method could potentially match more than one entry and we want the hook to run on each match.

  ```js
  router.put('/:id', async (req, res) => {
    try {
      const userData = await User.update(req.body, {
        where: {
          id: req.params.id,
        },
        individualHooks: true
      });
  ```

* To test the hooks, run `npm start` from the command line and demonstrate the following in Insomnia Core: 

  * 🔑 We will make a POST request to `http://localhost:3001/api/users` to create a new user. Notice that the email address is capitalized in the body of the request:

  ```json
  {
    "username": "test",
    "email": "TEST@email.com",
    "password": "Password123"
  }
  ```

  * 🔑 When the data is returned, we should see that the email address has been saved in lower case. 

  ```json
  {
    "username": "test",
    "email": "test@email.com",
    "password": "Password123"
  }
  ```

  * 🔑 We will make a PUT request to `http://localhost:3001/api/users/1` to update the user we just created:

  ```json
  {
    "username": "test",
    "email": "TEST1234@email.com",
    "password": "Password123"
  }
  ```

  * 🔑 When the data is returned, we should see that the email address has been updated and stored in lower case. 

  ```json
  {
    "username": "test",
    "email": "test1234@email.com",
    "password": "Password123"
  }
  ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How can we use hooks to automate `bcrypt` password hashing for users?

  * 🙋 We will need to add hooks to the `User` model to hash passwords for user instances before they are created or updated.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `18-Stu_Hooks/README.md`.

### 13. Student Do: Hooks (15 min)

* Direct students to the activity instructions found in `18-Stu_Hooks/README.md`.

* Break your students into pairs that will work together on this activity.

```md
# 🏗️ Use hooks to hash a password

Work with a partner to implement the following user story:

* As a user, I want to be able to login with my password.

* As a user, I want to be able to change my password.

* As a user, I want to know that my password is being stored securely.

## Acceptance Criteria

* It's done when User.int() includes hooks to hash the user's password before it is created.

* It's done when User.int() includes hooks to hash the user's password before it is updated.


## 💡 Hint(s)

* What did you learn about hashing a password, async/await, try/catch in previous lessons? 

* What are 3 methods for adding hooks to your code? How is adding a hook via init() different from the other options?

## 🏆 Bonus

* If you have fully completed the above tasks, here is something you and your partner can work through as an added challenge to further your knowledge:

  * Hooks are considered "middleware" in programming terms. What are some other examples of middleware used in Node applications?

* Use [Google](https://www.google.com) or another search engine to research the above.
```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students that need extra help while circulating through room.

### 14. Instructor Review: Hooks (10 min) 

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How comfortable do you feel with using `hooks` in Sequelize? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help!

* Use the prompts and talking points below to review the following key (🔑) points:

  * ✔️ `beforeCreate()`

  * ✔️ `beforeUpdate()`

* Open `18-Stu_Hooks/Solved/models/User.js` in your IDE and explain the following: 

  * We create a `beforeCreate()` hook in the `User.js` file to make sure that a user can create a profile and that their password will be stored securely with `bcrypt` before the record is stored.

  ```js
  beforeCreate: async (newUserData) => {
    newUserData.password = await bcrypt.hash(newUserData.password, 10);
    return newUserData;
  }  
  ```

  * 🔑 The user's password is set as equal to a hashed password, using `bcrypt`. Then `newUserData` is returned.

  ```js
   beforeCreate: async (newUserData) => {
    newUserData.password = await bcrypt.hash(newUserData.password, 10);
    return newUserData;
  }   
  ```

  * `async` and `await` are included in the method, to write cleaner code that enables promise-based behavior.

  ```js
  beforeCreate: async (newUserData) => {
    newUserData.password = await bcrypt.hash(newUserData.password, 10);
    return newUserData;
  }  
  ```
  
  * 🔑 We can repeat the previous steps to create the `beforeUpdate()` method.

  ```js
  beforeUpdate: async (updatedUserData) => {
    updatedUserData.password = await bcrypt.hash(updatedUserData.password, 10);
    return updatedUserData;
  }
  ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ What are some other commonly used hooks that are available to us?

  * 🙋 `afterCreate`, `afterUpdate`, `beforeDestroy`, `afterDestroy`, etc.

  * ☝️ What can we do if we don't completely understand this?

  * 🙋 We can refer to supplemental material, read the [Sequelize Manual on Hooks](https://sequelize.org/master/manual/hooks.html), and stick around for Office Hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 15. Instructor Demo: Instance Methods (5 min) 

* Navigate to `19-Ins_Instance-Method` and be sure to change the `.env.EXAMPLE` file into your own `.env` file with your credentials. 

* Open `19-Ins_Instance-Method/models/User.js` in your IDE and demonstrate the following:

  * 🔑 Sometimes we need to work with data that is stored within an instance. For example, maybe we want to know if a user in a pet adoption database currently has any pets. 
  
  * We don't want to use 'GET' to return all of that user's information because we only need to know if that user has pets or not. This is where instance methods can be useful.

  * 🔑 Sequelize allows us to write instance methods within models (in our example, the `User` model) to give us access to specific data that we can then return to users. 
  
  * Let's take a look at `User.js`. In this example, in order to create a user instance for our pet adoption database, we must include the number of pets that we currently have.

  ```js
  User.init(
    {
      // previous model attributes above...
      
      numberOfPets: {
        type: DataTypes.INTEGER,
      },
    },
  )
  ```

* Run `npm start` from the command line and demonstrate the following in Insomnia Core: 

  * 🔑 We will make a POST request to `http://localhost:3001/api/users` to create a new user. We've set `numberOfPets` equal to 2, because our user has 2 pets:

  ```json
  {
    "username": "test",
    "email": "test@email.com",
    "password": "Password123",
    "numberOfPets": 2
  }
  ```

  * 🔑 When the data is returned, we should see that the user's pets have been stored in the record. 

  ```json
  {
    "username": "test",
    "email": "test@email.com",
    "password": "Password123",
    "numberOfPets": 2
  }
  ```

  * We can imagine that many of the users in this pet adoption database might not have pets yet, so let's create another user to reflect that.

  ```json
  {
    "username": "test2",
    "email": "test2@email.com",
    "password": "Password890",
    "numberOfPets": 0
  }
  ```

  * When the data is returned, we should see that this user's pets have been stored in the record as `"numberOfPets": 0`. 

  ```json
  {
    "username": "test2",
    "email": "test2@email.com",
    "password": "Password890",
    "numberOfPets": 0
  }
  ```

  * We created our users, now we want to check to see if a user has pets or not without returning ALL of their information by creating an instance method.

  * 🔑 Let's take a look at the user model in `User.js`. Notice that we have a simple instance method called, `hasPets` at the top. 
  
  * Inside of the instance method we use a conditional statement to check if `this.numberOfPets` (where `this` represents one particular user) is greater than 0. If the number is greater than 0, it returns `true`, otherwise, it returns `false`.

  ```js
  class User extends Model {
    // This instance method uses a conditional statement to check if a user has pets
    hasPets() {
     if (this.numberOfPets > 0) {
        return true;
      } else {
       return false;
      }
    }
  }
  ```

  * Our instance method checks to see if a user has any pets. But now we need to make sure that our user can use this method. In order to do that, we also need to write a custom route.

* 🔑 Open `19-Ins_Instance_Method/routes/api/userRoutes.js` in your IDE and demonstrate the following:

  * 🔑 Notice that we've included a new route specifically for our instance method, `hasPets`. 

  ```js
  router.post('/:id/hasPets', async (req, res) => {

  }
  ```
  
  * First, we find a user using their primary key (provided by params). If `userData` evaluates as `false` (no user exists with that primary key), then we will send an error message. 

  ```js
  try {
    const userData = await User.findByPk(req.params.id);
    if (!userData) {
      res.status(404).json({ message: 'No user with this id!' });
      return;
    }
  ```
  
  * If a user does exist at the primary key, we get to use the instance method that we wrote in `User.js` to see if the user has pets. 

  ```js
  const petData = await userData.hasPets(req.body.numberOfPets);
  ```
  
  * If `petData` evaluates as false (the user has 0 pets), then the user will receive the message, "This person has no pets." 
  
  ```js
  if (!petData) {
    res.status(400).json({ message: 'This person has no pets.' });
    return;
  }
  ```

  * Otherwise, the user will see the message "This person has pets!"

  ```js
  res.json({ message: 'This person has pets!' });
  ```
  
* If you have time, run `npm start` from the command line and demonstrate the following in Insomnia Core: 

  * 🔑 We will make a POST request to `http://localhost:3001/api/users/1/hasPets` to check our route and instance method.

  * 🔑 When the data is returned, we should see the following message, because the first user we created did have pets. 

  ```json
  {
    "message": "This person has pets!"
  }
  ```
  * 🔑 Now let's check our second user. We will make a POST request to `http://localhost:3001/api/users/2/hasPets`.

  * 🔑 When the data is returned, we should see the following message, because the second user we created did not have pets. 

  ```json
  {
    "message": "This person has no pets."
  }
  ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How would we build this?

  * 🙋 We will add an instance method inside the user model in `User.js` return specific data about one instance. 

  * 🙋 We will add a corresponding route in `userRoutes.js` so that we have access to the data returned by the instance method. 

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `20-Stu_Instance-Method/README.md`.

### 16. Student Do: Instance Methods (15 min) 

* Direct students to the activity instructions found in `20-Stu_Instance-Method/README.md`.

* Break your students into pairs that will work together on this activity.

```md
# 🏗️ Create a custom instance method

Work with a partner to implement the following user story:

* As a user, I want to login to my account with my password.

* As a developer, I want to allow a user to login to their account securely so that their password information isn't compromised 

## Acceptance Criteria

* It's done when the model includes an instance method.

* It's done when the instance method compares the user's input with the user's hashed password.

## 💡 Hint(s)

* What tools does bcrypt offer to help us compare user input to a hashed password?

## 🏆 Bonus

* If you have fully completed the above tasks, here is something you and your partner can work through as an added challenge to further your knowledge:

  * How can we DRY up our code using Sequelize's static model methods?

* Use [Google](https://www.google.com) or another search engine to research the above.
```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students that need extra help while circulating through room.

### 17. Instructor Review: Instance Methods (15 min)

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How comfortable do you feel with adding `instance methods` to your models? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help!

* Use the prompts and talking points below to review the following key (🔑) points:
  
  * ✔️ Build out `checkPassword()`

  * ✔️ Use `bcrypt.compareSync()` to check the user's password

* Open `20-Stu_Instance-Methods/Solved/routes/api/userRoutes.js` in your IDE and explain the following: 

  * The `checkPassword()` instance method is used in the `/login` route. Understanding how `checkPassword()` is being used in the `/login` route can give us clues to what the instance method needs to accomplish. 

  ```js
  router.post('/login', async (req, res) => {
    
    const validPassword = await userData.checkPassword(req.body.password);
    if (!validPassword) {
      res
        .status(400)
        .json({ message: 'Incorrect email or password, please try again' });
      return;
    }
    res.json({ user: userData, message: 'You are now logged in!' });
    };
  ```

  * We can tell from the `/login` route that our instance method will need to take in the user's password (from `req.body`) as an argument and then determine if it matches the password stored in that user's record.

* Open `20-Stu_Instance-Methods/Solved/models/User.js` in your IDE and explain the following: 

  * 🔑 First, we want to write the instance method `checkPassword()` inside the user model in `User.js`. 

  ```js
  class User extends Model {
    checkPassword(loginPw) {
      
      }
  }
  ```

  * 🔑 `bcrypt` offers a method called, `compareSync()` that allows us to easily check a password. It takes two arguments, `loginPw` (the password the user sent in the body of the POST request) and `this.password` (the password stored in this particular user record). 

  ```js
  class User extends Model {
    checkPassword(loginPw) {
      bcrypt.compareSync(loginPw, this.password);
      }
  }
  ```

  * Remember the `/login` route expects `checkPassword()` to evaluate as either `true` or `false`. `compareSync` returns a boolean, so all we need to do is return it in the instance method.

  ```js
  class User extends Model {
    checkPassword(loginPw) {
      return bcrypt.compareSync(loginPw, this.password);
    }
  }
  ```
  
* If you have time, run `npm start` from the command line and demonstrate the following in Insomnia Core: 

  * We will make a POST request to `http://localhost:3001/api/users` to create a new user:

  ```json
  {
    "username": "test",
    "email": "test@email.com",
    "password": "Password123"
  }
  ```

  * When the data is returned, notice that the password is hashed because `User.js` includes a `beforeCreate` hook that uses `bcrypt` to hash the user's password. 

  ```json
  {
    "id": 1,
    "username": "test",
    "email": "test@email.com",
    "password": "$2b$10$ItAeYIqhuEzADqxHsMe6Mu.r3lzZ.Ewb0gnWw0md3OkRsqPnFKbbG"
  }
  ```

  * Now, we will make a POST request to `http://localhost:3001/api/users/login` to login.

  ```json
  {
    "email": "test@email.com",
    "password": "Password123"
  }
  ```

  * If our code is working, we should see the following when the data is returned: 

  ```json
  {
    "user": {
      "id": 1,
      "username": "test",
      "email": "test@email.com",
      "password": "$2b$10$ItAeYIqhuEzADqxHsMe6Mu.r3lzZ.Ewb0gnWw0md3OkRsqPnFKbbG"
    },
    "message": "You are now logged in!"
  }
  ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ When do you need to incorporate an instance method into your model?

  * 🙋 When you need to get data or do something related to one specific instance of a model.

  * ☝️ What can we do if we don't completely understand this?

  * 🙋 We can refer to supplemental material, read the [Sequelize Manual on Model Instances](https://sequelize.org/master/manual/model-instances.html), and stick around for Office Hours to ask for help.

* Answer any questions before ending the class.

### 18. END (0 min)

How did today’s lesson go? Your feedback is important. Please take 5 minutes to complete [this anonymous survey](https://forms.gle/RfcVyXiMmZQut6aJ6).

---
© 2020 Trilogy Education Services, LLC, a 2U, Inc. brand.  Confidential and Proprietary.  All Rights Reserved.