# 10.2 Lesson Plan: Test-Driven-Development (6:30 PM)

## Overview

Today's class introduces students to test-driven-development and unit testing JavaScript applications.

## Instructor Notes

## Learning Objectives

* Explain the benefits of test-driven-development

* Use unit tests before as a way to define code requirements for code that hasn't been written yet

* Write unit tests for pre-existing JavaScript functions

* Use mocks to test side effects such as reading/writing to the file system, printing to the console, and AJAX requests

* Use the Arrange, Act, Assert pattern to structure test code

## Slides

## Time Tracker

[Unit 10-OOP Day 2 Time Tracker](https://docs.google.com/spreadsheets/d/1JjwCYWyW_cclj4VaWPol4IVudyp4jNGR057ugv_0znQ/edit?usp=sharing)

- - -

## Class Instruction

### 1. Instructor Do: Introduce Testing (10 mins)

* Welcome students to class.

* Ask the class the following question(s) and call on students for the corresponding answer(s):

  * ☝️ So far, how have we known that our code is working?

  * 🙋 We ran it and checked if it did what it was supposed to do.

  * ☝️ So far, how do we known that that by adding new code to our applications, we didn't break something, somewhere else?

  * 🙋 We ran the app and clicked around and make sure everything still worked.

  * ☝️ Have you ever done this and still pushed up a bug without realizing it?

  * 🙋 Yes.

  * ☝️ Could manual testing be a lot of work, especially for very large applications?

  * 🙋 Yes.

  * ☝️ Do we think there's a better way?

  * 🙋 We could write automated tests.

* Go over the following points with the class:
  
  * Since automated tests are written with code and can be run quickly before new code is merged in, we can be more certain that new code works and doesn't break existing code.

  * As a new developer at a company, writing tests is a common first task as it gives you a chance to explore and understand the codebase.

  * Tests force us to write better, more understandable and maintainable code that's easier to change.

  * Every application would benefit from automated tests, so its important to understand testing web applications.
  
  * It's possible to make an entire career out of writing tests, so if any students really enjoy today's material, that may be a career path they'll want to learn more about.

* Take a few minutes to answer any questions students may be before proceeding to the next activity.

### 2. Students Do: TDD Research (10 min)

* Direct students to work in pairs to spend the next few minutes researching test-driven-development and its benefits.

### 3. Instructor Do: Review TDD Research (5 min)

* Ask the class the following question(s) and call on students for the corresponding answer(s):

  * ☝️ What is test-driven-development?

  * 🙋 Test-driven-development is a practice in which tests are written before application code is written. Initially all of the tests fail, but then we implement the functionality we're testing for one piece at a time.

  * ☝️ Why is it helpful to write tests before writing application code?

  * 🙋 By writing tests first, we can define the requirements our application should have ahead of time so we know to what to focus on. We're also more sure that each piece piece of functionality works before moving on to the next.

  * ☝️ What are some other benefits of TDD?

  * 🙋 Test-driven-development encourages modular, cohesive, and loosely coupled code.

  * ☝️ What does that mean?
  
  * 🙋 When code is modular, it's separated by responsibility into different files and functions. When code is cohesive, the code that its collocated with is of related functionality. When code is loosely coupled, it means that it isn't very entangled or dependent on other parts of the codebase. When a codebase is all three, it's usually easier to understand and update without breaking.

  * ☝️ What are some drawbacks of TDD?

  * 🙋 Building applications can take longer if we need to write a lot of tests first. It can also be difficult to write tests for a problem that we're uncertain how to solve right away.

* Take a moment to answer any remaining questions.

### 4. Students Do: Testing Dissect (10 min)

* Direct students to the next activity, found in [01-Activities/08-Stu_TDD-Dissect](../../../../01-Class-Content/10-oop/01-Activities/08-Stu_TDD-Dissect).

```md
# TDD Dissect

In this activity you will work with a partner to dissect the provided testing example.

## Instructions

* Open the `index.js` file in your code editor and try to guess what what the code does. Ask yourself: what do you think will be printed to the console in this example?

* Run the `index.js` file in your terminal. Was your guess correct? Ask yourself: how do you think the method chaining is achieved?

* Open the `arithmetic.js` file in your code editor. What do you think the significance of the `plus` and `minus` methods returning `new Arithmetic` is? How does this relate to the method chaining you saw in the `index.js` file?

* Open `test/arithmetic.test.js`. Ask yourself: what is the significance of the `expect` function? What does `toEqual` do? What about the `describe` and `it` functions? Where are these coming from?

* Once you've had some time to consider the above, run `npm run test` in your terminal and examine the output. Do you have a better idea of what the `describe` and `it` functions might be used for?

* Have any conclusions as well as remaining questions ready to share during the activity review.
```

### 5. Instructor Do: Review TDD Dissect (5 mins)

* Use the prompts and talking points below to demonstrate the following key point(s):

  * ✔️ We're using the Jest testing framework for our automated tests.

  * ✔️ Tests are organized into `describe` and `it` blocks. These are primarily for grouping tests by module, functionality, etc.

  * ✔️ Any file inside of the `test` folder ending with `.test.js` gets run by Jest automatically when we run the `npm run test` script.

  * ✔️ The `expect` function is used for assertions. Assertions are essentially statements that are used to verify that our code is doing what we "expect" it to do.

  * ✔️ The `instanceof` operator can be used to determine if an object was created with a given constructor function.

* Open [08-Stu_TDD-Dissect/arithmetic.js](../../../../01-Class-Content/10-oop/01-Activities/08-Stu_TDD-Dissect/arithmetic.js) and explain the following:

  * The object created by the `Arithmetic` constructor function has a `number` property, and three methods: `plus`, `minus`, and `value`.

  ```js
  function Arithmetic(number = 0) {
    this.number = number;
  }

  Arithmetic.prototype.plus = function(num = 0) {
    const newNumber = this.number + num;

    return new Arithmetic(newNumber);
  };

  Arithmetic.prototype.minus = function(num = 0) {
    const newNumber = this.number - num;

    return new Arithmetic(newNumber);
  };

  Arithmetic.prototype.value = function() {
    return this.number;
  };
  ```

  * The `plus` and `minus` methods both return new `Arithmetic` objects containing an updated `number`.
  
* Open [08-Stu_TDD-Dissect/index.js](../../../../01-Class-Content/10-oop/01-Activities/08-Stu_TDD-Dissect/index.js) to demonstrate this:

  ```js
  const value = new Arithmetic(4)
    .plus(8)
    .plus(15)
    .minus(16)
    .minus(23)
    .plus(42)
    .plus(108)
    .value();

  console.log(value);
  ```

  * Since the `plus` and `minus` methods return a new `Arithmetic` object, it's possible to chain these methods. The `value` method simply returns the `number` of the `Arithmetic` object.

* Take a moment to answer any questions about the application code before transitioning to the test code.

* Open [08-Stu_TDD-Dissect/test/arithmetic.test.js](../../../../01-Class-Content/10-oop/01-Activities/08-Stu_TDD-Dissect/test/arithmetic.test.js) and explain the following:

  * 🔑 Jest will run files inside of the `test` folder that end in `.test.js`.

  * 🔑 Tests are grouped into `describe` and `it` blocks.

  ```js
  describe("Initialization", () => {
    it("should return an object containing a 'number' property when called with the 'new' keyword", () => {
      const obj = new Arithmetic();

      expect("number" in obj).toEqual(true);
    });
  ```

* The `describe` and `it` blocks are simply used for grouping. Run the `npm run test` command in your terminal to demonstrate the output:

  ```md
  PASS  test/arithmetic.test.js
    Arithmetic
      Initialization
        ✓ should return an object containing a 'number' property when called with the 'new' keyword (2ms)
        ✓ should set 'number' when created
        ✓ should default 'number' to 0
      plus
        ✓ should return a new 'Arithmetic' object
        ✓ should return a new 'Arithmetic' object that has an updated 'number' value
      minus
        ✓ should return a new 'Arithmetic' object
        ✓ should return a new 'Arithmetic' object that has an updated 'number' value
      value
        ✓ should return the 'Arithmetic' object's 'number' value

  Test Suites: 1 passed, 1 total
  Tests:       8 passed, 8 total
  Snapshots:   0 total
  Time:        1.482s
  Ran all test suites.
  ```

  * 🔑 The `describe` function is used to "describe" what is being tested. And `it` is used to "label" specific things we're testing for, ie "should return an object containing a 'number' property when called with the 'new' keyword".

  * 🔑 Since `describe` and `it` are just used for grouping, you can arrange these in whatever way makes the most sense to you and your team. You can nest `describe` functions inside of other `describe` functions, but `it` functions shouldn't be nested inside of each other should always go inside of `describe` functions.

* Go through a few of the test cases to demonstrate how the `expect` function is used.

  * 🔑 `expect` is what's referred to as an "assertion", it's used to check that our code is doing what it should, e.g.

  ```js
  it("should default 'number' to 0", () => {
    const obj = new Arithmetic();

    expect(obj.number).toEqual(0);
  });
  ```

  * This code checks that the object created by the `Arithmetic` constructor defaults its `number` property to `0` if not provided one.

* Demonstrate what happens if you change this to be another number and re-run the tests:

  ```md
  FAIL  test/arithmetic.test.js
    Arithmetic
      Initialization
        ✓ should return an object containing a 'number' property when called with the 'new' keyword (3ms)
        ✓ should set 'number' when created
        ✕ should default 'number' to 1 (1ms)
      plus
        ✓ should return a new 'Arithmetic' object
        ✓ should return a new 'Arithmetic' object that has an updated 'number' value
      minus
        ✓ should return a new 'Arithmetic' object
        ✓ should return a new 'Arithmetic' object that has an updated 'number' value
      value
        ✓ should return the 'Arithmetic' object's 'number' value (1ms)

    ● Arithmetic › Initialization › should default 'number' to 1

      expect(received).toEqual(expected) // deep equality

      Expected: 1
      Received: 0

        20 |       const obj = new Arithmetic();
        21 |
        22 |       expect(obj.number).toEqual(1);
           |                          ^
        23 |     });
        24 |   });
        25 |

        at Object.toEqual (test/arithmetic.test.js:22:26)

  Test Suites: 1 failed, 1 total
  Tests:       1 failed, 7 passed, 8 total
  Snapshots:   0 total
  Time:        0.935s, estimated 1s
  Ran all test suites.
  ```

  * 🔑 In order for a test to pass, its assertion should evaluate to be true.

  * 🔑 The `instanceof` operator can be used to determine if an object was created with a given constructor function.

  ```js
  it("should return a new 'Arithmetic' object", () => {
    const obj = new Arithmetic(9).minus(4);

    expect(obj instanceof Arithmetic).toEqual(true);
  });
  ```

  * For now, we're primarily concerned with testing that a function returns what it should in a variety of situations.

* Take a few minutes to answer lingering questions before the next activity.

### 6. Students Do: TDD (15 mins)

* Direct students to the next activity, found in [09-Stu_TDD/Unsolved](../../../../01-Class-Content/10-oop/01-Activities/09-Stu_TDD/Unsolved).

  ```md
  # TDD

  In this activity you will write tests outlining the expected functionality for application code that haven't been implemented yet.

  ## Instructions

  * Open the `algo.js` file and take a moment to examine the code.
    
    * The `Algo` constructor function has three empty methods: `reverse`, `isPalindrome`, and `capitalize`.

  * Now open the `test/algo.test.js` file.

    * This file contains `describe` blocks for each method on the `Algo` constructor.

  * Write code to test each method:

    * The `reverse` method should take a string as an argument and return a new reversed version of the string. e.g. "Hello" should return "elloH".

    * The `isPalindrome` method should take a string as an argument and return the boolean `true` if the provided string is a palindrome. A palindrome is a word that is the same backwards as it is forwards, e.g. "racecar". Return `false` is the string is not a palindrome.

    * The `capitalize` method should take a string as an argument and return a new string with the first letter of each word capitalized. e.g. "hello world!" should return "Hello World!".

  * **Important**: Write code for the tests only, the only file you will be modifying is `tests/algo.test.js`. Initially all of your tests will fail since these methods are empty, but using the tests you can define how each method _should_ work.

  ## 💡 Hint(s)

  * Use the previous example as a reference.
  ```

### 7. Instructor Do: Review TDD (5 mins)

* Use the prompts and talking points below to demonstrate the following key point(s):

  * ✔️ By providing our functions different inputs, we can make sure they work correctly by checking their return values.

  * ✔️ Tests can be a way to document a codebase and lay out application requirements.

* Go over the solution code:

  ```js
  const Algo = require("../algo");

  describe("Algo", () => {
    describe("reverse", () => {
      it("should reverse a given string", () => {
        const str = "Hello World!";
        const reversed = "!dlroW olleH";

        const result = new Algo().reverse(str);

        expect(result).toEqual(reversed);
      });
    });

    describe("isPalindrome", () => {
      it("should return true if a string is a palindrome", () => {
        const str = "racecar";

        const result = new Algo().isPalindrome(str);

        expect(result).toEqual(true);
      });

      it("should return false if a string is not a palindrome", () => {
        const str = "neon";

        const result = new Algo().isPalindrome(str);

        expect(result).toEqual(false);
      });
    });

    describe("capitalize", () => {
      it("should take a string and return a new string with the first letter of each word capitalized", () => {
        const str = "capitalize every first word of the string.";
        const capitalized = "Capitalize Every First Word Of The String.";

        const result = new Algo().capitalize(str);

        expect(result).toEqual(capitalized);
      });
    });
  });
  ```

  * 🔑 In each case, we're checking to see what the method returns given a certain input.

  * 🔑 Even though we haven't written code for these methods yet, it would be easy for someone to understand what the methods should do based on these tests.

* Ask the class the following question(s) and call on students for the corresponding answer(s):

  * ☝️ Do you think these are good tests?

  * 🙋 Yes, if they fail, it means the code isn't doing what it should.

  * ☝️ Do you think these are _enough_ tests?

  * 🙋 No, it doesn't account for things like empty strings, what should happen if given invalid arguments or edge cases like palindromes with different casing or spaces.

* Take a moment to answer any questions before the next activity.

### 8. Students Do: Make The Tests Pass (15 mins)

* Direct students to the next activity, found in [10-Stu_Pass-Tests/Unsolved](../../../../01-Class-Content/10-oop/01-Activities/10-Stu_Pass-Tests/Unsolved).

  ```md
  # Pass Tests

  In this activity you will be writing code to implement functionality for the Algo constructor you wrote tests for in the previous activity.

  ## Instructions

  * Open the `Unsolved/algo.js` file in your editor.

  * Starting with the `reverse`, method, write code to make the tests in `tests/algo.test.js` pass.

  * After completing each method, run `npm run test` in your terminal to verify you correctly implemented the method before moving on to the next one.
  ```

### 9. Instructor Do: Review Make The Tests Pass (5 mins)

* Use the prompts and talking points below to review the following key point(s):

  * ✔️ By having tests written already before writing code, we can be more certain that our code works.

  * ✔️ By having tests first, we can often code more quickly because we aren't performing manual tests to know if things are working.

* Open [02-Stu_Hello-Node/Solved/index.js](../../../../01-Class-Content/10-oop/01-Activities/10-Stu_Pass-Tests/Solved/algo.js) in your IDE and explain the following point(s):

  ```js
  function Algo() {}

  Algo.prototype.reverse = function(str) {
    return str
      .split("")
      .reverse()
      .join("");
  };

  Algo.prototype.isPalindrome = function(str) {
    return this.reverse(str) === str;
  };

  Algo.prototype.capitalize = function(str) {
    return str.split(" ").map(word => {
      return word.substring(0, 1).toUpperCase() + word.substring(1);
    }).join(" ");
  };
  ```

  * 🔑 Since we had tests written for each method, they should have been a little easier to implement since we didn't have to do any manual testing.

  * 🔑 Because we had tests written, we can be more reasonably sure that each method works as intended.

  * 🔑 Students may have implemented their methods differently, but that's okay as long as the outcome is the same. It's a good practice to not worry about testing specific implementation details.

* Take a moment to answer any remaining questions about the activity.

### 10. Instructor Do: Organizing Tests (10 mins)

* Use the prompts and talking points below to review the following key point(s):

  * ✔️ When writing tests, it's a good idea to have framework or set of guidelines that can be used for organizing tests and deciding what kinds of things to test for.

  * ✔️ The Arrange Act Assert pattern gives us a guide for how to organize test code in a way that makes sense to us and other.

  * ✔️ When considering what kinds of things to write tests for, it's a good idea to keep in mind positive, negative, and exception tests.

* * Open [11-Ins_Organizing-Tests](../../../../01-Class-Content/10-oop/01-Activities/11-Ins_Organizing-Tests) in your IDE and explain the following point(s):

  ```js
  function Todo(text) {
    if (typeof text !== "string" || !text.trim().length) {
      throw new Error("Expected parameter 'text' to be a non empty string");
    }

    this.text = text;
  }
  ```

  * The `todo.js` file contains a `Todo` constructor. This constructor creates an object with a provided `text` value. If `text` is not a string or is an empty string, an error is thrown.

  ```js
  function TodoList() {
    this.todos = [];
  }

  TodoList.prototype.addTodo = function(text) {
    this.todos.push(new Todo(text));
  };

  TodoList.prototype.getNextTodo = function() {
    return this.todos[0];
  };

  TodoList.prototype.completeNextTodo = function() {
    return this.todos.shift();
  };
  ```

  * The `todoList.js` file contains a `TodoList` constructor that creates an object with a `todos` property set to an empty array.

  * The `TodoList` has a `addTodo` method that adds a new `Todo` object to the array, a `getNextTodo` property that returns the first todo in the array, and a `completeNextTodo` method that removes the first todo in the list and returns it.

* Once you've covered the intended functionality of the `Todo` and `TodoList` constructor functions, open the [11-Ins_Organizing-Tests/test/todo.test.js](../../../../01-Class-Content/10-oop/01-Activities/11-Ins_Organizing-Tests/test/todo.test.js) file in your editor and point out the following key points:

  ```js
  it("should create an object with a 'text' property set to the 'text' argument provided when called with the 'new' keyword", () => {
    // Arrange
    const text = "Pick up milk";

    // Act
    const obj = new Todo(text);

    // Assert
    expect(obj.text).toEqual(text);
  });
  ```

  * The tests are split into three parts: Arrange, Act, and Assert.

  * **Arrange**: Any kind of set up you need to run your test.

  * **Act**: Perform the action to be tested.

  * **Assert**: Perform the assertion.

  * Comments aren't necessary, but it's helpful to separate these with a newline character. Not every test will have all three sections, but keeping the AAA pattern in mind can make our tests a little more organized.

* Open [11-Ins_Organizing-Tests/test/todoList.test.js](../../../../01-Class-Content/10-oop/01-Activities/11-Ins_Organizing-Tests/test/todoList.test.js) file in your editor and point out the following key points:

  ```js
  it("should add a new 'Todo' object to its 'todos' array", () => {
    // Arrange
    const todoList = new TodoList();
    const todoText = "Mow Lawn";

    // Act
    todoList.addTodo(todoText);

    // Assert
    expect(todoList.todos.length).toEqual(1);
    expect(todoList.todos[0] instanceof Todo).toEqual(true);
    expect(todoList.todos[0].text).toEqual(todoText);
  });
  ```

  * This file contains a few **positive tests**. Positive tests are tests we run to make sure things work as intended in likely situations.

  ```js
  it("should return undefined if there are no todos", () => {
    // Arrange
    const todoList = new TodoList();
    let nextTodo;

    // Act
    nextTodo = todoList.getNextTodo();

    // Assert
    expect(typeof nextTodo).toEqual("undefined");
  });
  ```

  * This file contains a **negative test**. Negative tests are tests we run to check things work in edge cases or cases where the function should return a negative result -- e.g. checking if `isPalindrome` returns `false` for strings that aren't palindromes.


  ```js
  it("should throw an error if not provided text", () => {
    // Arrange
    const todoList = new TodoList();
    const err = new Error(
      "Expected parameter 'text' to be a non empty string"
    );
    const cb = () => todoList.addTodo();

    // Assert
    expect(cb).toThrowError(err);
  });
  ```

  * This file contains an **exception test**. Exception tests are tests we run to make sure than our code throws errors if/when it should.

  * Not every function will have all three (positive, negative, and exception tests), but keeping them in mind can help us decide what kinds of things we should be testing for.

* Take a minute to answer any questions about the AAA pattern and positive, negative, and exception tests.

### 11. Students Do: Structured Tests (15 mins)

* Direct students to the next activity, found in [11-Ins_Organizing-Tests/Unsolved](../../../../01-Class-Content/10-oop/01-Activities/11-Ins_Organizing-Tests/Unsolved).

  ```md
  # Structured Tests

  In this activity you will be writing code to test two constructor functions. You will attempt to follow the Arrange Act Assert pattern.

  ## Instructions

  * Open the `Unsolved/child.js` file and examine its contents.

    * This file exports a `Child` constructor function. The constructor function expects to be provided a name and an age.

    * If `name` is not a string or `name` is an empty string, an error is thrown.

    * If `age` is not a number, is `NaN` or is less than `0`, an error is thrown.

    * Otherwise these values are added to the created instance when the constructor is called.

  * Open the `Unsolved/dayCare.js` file and examine its contents:

    * This file requires the `Child` constructor function.

    * This file exports a `DayCare` constructor function.

    * The `DayCare` constructor has an empty `children` array, a capacity of 3, and an `ageLimit` of 6.

    * The `DayCare` constructor has an `addChild` method used for adding `Child` objects to the `children` array, and a `pickupChild` method used for removing a `Child` object from the `children` array.

  * Inside of the `Unsolved/test/child.test.js` file, write code to test that the `Child` constructor works as expected.

  * Inside of the `Unsolved/test/dayCare.test.js`, write code to test that the `DayCare` constructor and methods work as expected.

  * The only files you need to modify for this activity are `Unsolved/test/child.test.js` and `Unsolved/test/dayCare.test.js`.

  ## 💡 Hint(s)

  * After adding each test, run `npm run test` in your terminal to ensure the test passes.

  * When deciding what to test for, consider the following:

    * Positive tests: What happens when things go well?

    * Negative tests: What happens in edge cases or when things shouldn't work?

    * Exception tests: What happens in cases when an error should be thrown?
  ```

### 12. Instructor Do: Review Structured Tests (15 mins)

* Use the prompts and talking points below to demonstrate the following key point(s):

  * ✔️ We should use the AAA pattern to structure our tests.

  * ✔️ We should keep in mind positive, negative, and exception test cases when deciding what to test for.

* Open [12-Stu_Structured-Tests/Solved/test/child.test.js](../../../../01-Class-Content/10-oop/01-Activities/12-Stu_Structured-Tests/Solved/test/child.test.js) file in your editor and point out the following key points:

  ```js
  it("should not add a child if already at capacity", () => {
    const dayCare = new DayCare();
    const child = new Child("Alice", 4);
    dayCare.children = [
      new Child("Tammy", 1),
      new Child("Mark", 2),
      new Child("Alvin", 1)
    ];

    dayCare.addChild(child);

    expect(dayCare.children.length).toEqual(3);
  });
  ```

  * 🔑 By using the Arrange Act Assert pattern, we can organize our tests into three easy to understand parts.

  ```js
  it("should throw an error if not provided a Child object as an argument", () => {
    const err = new Error(
      "Expected parameter 'child' to be an instance of Child"
    );
    const cb = () => {
      const dayCare = new DayCare();
      dayCare.addChild();
    };

    expect(cb).toThrowError(err);
  });
  ```

  * 🔑 We would use the `toThrowError` or `toThrow` matcher to check than an error was thrown.

  ```js
  it("should not add a child if already at capacity", () => {
    const dayCare = new DayCare();
    const child = new Child("Alice", 4);
    dayCare.children = [
      new Child("Tammy", 1),
      new Child("Mark", 2),
      new Child("Alvin", 1)
    ];

    dayCare.addChild(child);

    expect(dayCare.children.length).toEqual(3);
  });
  ```

  * 🔑 We use negative tests to make sure things work as expected in edge cases.

* Ask the class the following question(s) and call on students for the corresponding answer(s):

  * ☝️ Why is it helpful for a function to purposefully throw an error?

  * 🙋 If we throw a helpful error message when a function is being misused, the issue is easier to track down than if we didn't throw the error and the misuse caused another unexpected error somewhere else in the code.

* Take a minute to answer any remaining questions.

### BREAK (15 mins)

### 13. Instructor Do: Introduce Mocks (10 mins)

* Direct students to the following activities to work through as groups: 
@TODO add URLs
    * 01-Stu_Create-Repository

    * 02-Stu_Protect-Master

    * 03-Stu_Branching-Pushing


### Lesson Plan Feedback

How did today’s lesson go? Your feedback is important. Please take 5 minutes to complete this anonymous survey.

[Class Survey](https://forms.gle/nYLbt6NZUNJMJ1h38)
