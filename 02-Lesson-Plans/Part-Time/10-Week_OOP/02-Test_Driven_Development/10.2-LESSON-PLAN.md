# 10.2 Part-Time Lesson Plan: Object-Oriented Programming (OOP)

## Overview 

Today's lesson plan will introduce students to test driven development, unit tests, and mock data. 

## Instructor Notes

* In this lesson, students will complete activities `11-Ins-TDD` through `20-Stu_Mock-Fs`.

* Testing frameworks often use a lot of specific methods that read like plain english. You may benefit from creating a few failing tests of your own and then write the code to make them pass to help refresh your memory. You may also benefit from installing the [Jest Snippets](https://marketplace.visualstudio.com/items?itemName=andys8.jest-snippets) plugin for VSCode.

* Remind students to do a `git pull` of the class repo to have today's activities ready and open in VS Code. 

* If you are comfortable doing so, live-code the solutions to the activities. If not, just use the solutions provided and follow the prompts and talking points for review.

* Let students know that the Bonus at the end of each activity is not meant to be extra coding practice, but instead is a self-study on topics beyond the scope of this unit for those who want to further their knowledge.

## Learning Objectives

By the end of class, students will be able to:

* Explain the benefits of test-driven-development (**TDD**).

* Use **unit tests** before as a way to define code requirements for code that hasn't been written yet.

* Write **unit tests** for pre-existing JavaScript functions.

* Use **mocks** to test side effects such as reading/writing to the file system, printing to the console, and AJAX requests.

* Use the Arrange, Act, Assert pattern to structure test code.

## Time Tracker
@TODO ADD ACTIVITY TITLES for Instructor Demo, Student Do, and Instructor Review
| Start  | #   | Activity Name                                           | Duration |
| ------ | --- | ------------------------------------------------------- | -------- |
| 6:30PM | 1   | Instructor Do: Stoke Curiosity                          | 0:10     |
| 6:40PM | 2   | Instructor Demo: TDD Dissect                            | 0:05     |
| 6:45PM | 3   | Student Do: TDD                                         | 0:15     |
| 7:00PM | 4   | Instructor Review: TDD                                  | 0:10     |
| 7:10PM | 5   | Instructor Demo: Pass Tests                             | 0:05     |
| 7:15PM | 6   | Student Do: Pass Tests                                  | 0:15     |
| 7:30PM | 7   | Instructor Review: Pass Tests                           | 0:10     |
| 7:40PM | 8   | Instructor Demo: Organizing Tests                       | 0:05     |
| 7:45PM | 9   | Student Do: Implement and Write Structured Tests        | 0:15     |
| 8:00PM | 10  | BREAK                                                   | 0:15     |
| 8:15PM | 11  | Instructor Review: Implement and Write Structured Tests | 0:10     |
| 8:25PM | 12  | Instructor Demo: Introduce Mocks                        | 0:05     |
| 8:30PM | 13  | Student Do: Implement our First Mock                    | 0:15     |
| 8:45PM | 14  | Instructor Review: Implement our First Mock             | 0:10     |
| 8:55PM | 15  | Instructor Demo: Module Mock                            | 0:05     |
| 9:00PM | 16  | Student Do: Mock and Spy on `fs` Module                 | 0:15     |
| 9:15PM | 17  | Instructor Review: Mock and Spy on `fs` Module          | 0:15     |
| 9:30PM | 18  | END                                                     | 0:00     |

---

## Class Instruction

### 1. Instructor Do: Stoke Curiosity (10 min)

* Welcome students to class.

* Test driven development is a process and methodology. In order to prime our brain for learning, let's go over some terms that we will see throughout this unit. We will also discuss a very simple flow of how test driven development works (TDD).

* Terms:
  * **Unit Tests**: Unit tests ensure reliability and expected behavior of things like functions or classes. Unit tests assert that the unit being tested returns the expected output.
  
  * **Integration Tests**: Integration tests ensure proper cooperation of units in your application. Integration tests may focus on an API, user input, or user interface that may have subsequent actions like writing to a database or logging output.
  
  * **End-To-End Tests**: End-to-end tests assert that the application will function as expected from the perspective of a user. These tests usually focus almost entirely on the user interface of an application.

* We will be creating tests *before* we write our code. This is the core concept of how TDD works. We let the need to make tests pass dictate how our code should be written. This flow sets up a contract-like expectation for yourself and other developers. It also keeps the development process focused.

* TDD Cycle: We are going to focus on the basics and expand on each step in this unit, but for now all you need to know are the basic steps to TDD:

  1. Write a failing test
  2. Make the test pass
  3. Refactor the implementation


### 2. Instructor Demo: TDD Dissect (5 min)

* Open `11-Ins_TDD/package.json` in your IDE and demonstrate the following:

  * We have included `jest` as a dependency in `package.json` and a special test script defined with a value of `jest`.

  ```json
   "scripts": {
    "test": "jest"
  },
  ...
    "devDependencies": {
    "jest": "^26.5.2"
  }
  ```

* Run `npm install` and  `npm run test` from the command line and demonstrate the following: 

  * 🔑 When we run our test, it checks in `package.json` for a script with the key `test`. As we just noted, test script is defined with a value of `jest`.

  * 🔑 When `jest` is invoked, it will look for files matching a specific pattern of `[filename].test.js`. It will find our one and only test in the `/tests` directory and run it.

  * We can see that everything is passing, now lets examine the actual tests.

* Open `11-Ins-TDD/tests/arithmetic.test.js` in your IDE and demonstrate the following:

  * We have created a `/tests/` folder and an `arithmetic.test.js` file that contains tests for `arithmetic.js`.

  * We we are importing an object called `Arithmetic` at the top of the file that connects our tests to `arithmetic.js`. 

  ```js
  const Arithmetic = require('./arithmetic');
  ```
  
  * Let's take a look at the first test. We start with a `describe` statement that contains several other `describe` statements. The parent `describe` statement groups together the related tests for different methods, which also helps with readability.

     ```js
      describe("Arithmetic", () => {
       describe("Initialization", () => {
        ...
       });
      });
       describe("plus", () => {
      ...
       });
      });
       describe("minus", () => {
        ...
       });
      });
       describe("value", () => {
         ...
       });
      });
     });
    ```

  * The `it` portion of this test describes how the function should behave in a successful test case. For example, our first `it` statement indicates that initialization `"should return an object containing a 'number' property when called with the 'new' keyword"`.

  * The following code block then creates a new instance of Arithmetic and uses the `expect` and `toEqual` methods to test values. In our case, we are testing to see that the key `number` has a truthy value in our newly created object.

    ```js
    describe("Arithmetic", () => {
      describe("Initialization", () => {
        it("should return an object containing a 'number' property when called with the 'new' keyword", () => {
        const obj = new Arithmetic();
        expect("number" in obj).toEqual(true);
    });
    ```
  * The other tests under the parent `describe` statement are formatted in the same way, but test other methods in `arithmetic.js` called `plus`, `minus`, and `value`.

  * Let's take a look at `arithmetic.js`. If we right click on the word `Arithmetic` at the top of the file and click "Go to definition", we will be brought to the file that declares all the methods we saw tests for in `arithmetic.test.js`.

  * 🔑 Remember, in a typical TDD cycle, we would write tests first and then write the code that we see here to help our tests pass.

  * Here, we see all of the methods that appeared in the tests in `arithmetic.test.js`. 

  ```js
  function Arithmetic(number = 0) {
  this.number = number;
  }

  Arithmetic.prototype.plus = function(num = 0) {
    const newNumber = this.number + num;

    return new Arithmetic(newNumber);
  };

  Arithmetic.prototype.minus = function(num = 0) {
    const newNumber = this.number - num;

    return new Arithmetic(newNumber);
  };

  Arithmetic.prototype.value = function() {
    return this.number;
  };
  ```
  * Remember, the first test expected `number`to be initialized with a value, and that is what the function `Arithmetic` appears to accomplish.

  ```js
  function Arithmetic(number = 0) {
  this.number = number;
  }
  ```
  * Before we check to see if our tests are working, let's check out `index.js`

* Navigate to `11-Ins-TDD/index.js` in your IDE and explain the following:

  * We see that `index.js` is importing `arithmetic.js` at the top of the file, just like in `arithmetic.test.js`.

  * When we look at the code in `index.js`, we can see the methods declared in `arithmetic.js` chained together, preforming specific operations one after another and finally, logging the value.

  ```js
  const value = new Arithmetic(4)
    .plus(8)
    .plus(15)
    .minus(16)
    .minus(23)
    .plus(42)
    .plus(108)
    .value();

    console.log(value);
  ```

  * If we run `node index.js` , we see the value, 138 logged in the console.
  
  * 🔑 Now that we understand how the tests are written, lets run our tests:

    ```bash
    npm run test
    ```
  
  * We should see the output in the terminal from our testing framework called `jest`. All the passing tests will appear in green and all failing tests will appear in red.

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How would we build this?

  * 🙋 We would first build the tests, and then create the code to make the tests pass.

  * ☝️ What is the significance of the `expect`, `it`, and `toEqual` methods in our testing framework?

  * 🙋 Each of these are methods that tell the testing framework what to expect in terms of output from our functions. You can learn more about how to use these by reading the [Jest Docs](https://jestjs.io/docs/en/expect#expectvalue)

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in [12-Stu-TDD](../../../../01-Class-Content/10-OOP/01-Activities/12-Stu_TDD/README.md).

### 3. Student Do: Test Driven Development (15 min)

* Direct students to the activity instructions found in [12-Stu-TDD](../../../../01-Class-Content/10-OOP/01-Activities/12-Stu_TDD/README.md).

* Break your students into pairs that will work together on this activity.

  ```md
  # 📖 Write Tests for Algorithms

  Work with a partner to implement the following user story:

  * As a developer, I want to create tests to define the expectations for algorithms that haven't been implemented yet. 

  ## Acceptance Criteria

  * It's done when the "reverse" test expects the string `"Hello World!"` to become `"!dlroW olleH"` after calling `new Algo().reverse()`.

  * It's done when the "isPalindrome" test expects the string `"racecar"` to return `true` and the string `"neon"` to return `false` after calling `new Algo().isPalindrome()`.

  * It's done when the "capitalize" test expects the string `"capitalize every first word of the string."` to become `"Capitalize Every First Word Of The String."` after calling `new Algo().capitalize()`.

  * It's done when the tests fail, because no code should be added to the `algo.js` file to fulfill the tests yet.

  ## 📝 Notes

  Refer to the documentation: 

  [Jest API documentation](https://jestjs.io/docs/en/api)

  ---

  ## 💡 Hints

  * How can we use the `describe`, `it` and `expect` functions in Jest to check for expected behavior?

  ## 🏆 Bonus

  If you have completed this activity, work through the following challenge with your partner to further your knowledge:

  * Where can you find some examples of well written tests? 

  Use [Google](https://www.google.com) or another search engine to research this.
  ```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students who need extra help.

### 4. Instructor Review: Test Driven Development (10 min)

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How comfortable do you feel with TDD? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help!

* Use the prompts and talking points (🔑) below to review the following key points:

  * ✔️ `describe()`

  * ✔️ `.it()`

  * ✔️ `.expect()`

  * ✔️ `.toEqual()`

* Open [12-Stu-TDD](../../../../01-Class-Content/10-OOP/01-Activities/12-Stu_TDD/Solved/) in your IDE and explain the following: 

  * We first require the file containing the functions we would like to test.

  ```js
  const Algo = require("../algo");
  ```

  * The `describe` function is provided for each of our tests. We see that our tests are wrapped in a parent `describe` function for `Algo`.

  ```js
  describe("Algo", () => {
  ```

  * 🔑  Now we can build tests for specific functionality, starting with `"reverse"`. The `it` method allows us to describe what the function should do in plain english.

  * Next, we define `str` as the starting string and `reversed` as `str` backwords, and `result` as the actual result of the `reverse` function.

   * 🔑 Finally, we pass `result` as an argument into `.expect()` and compare it to the value of `reversed` using the `.toEqual` method. In other words, we expect the value of `result` to equal the value of `reversed`!

  ```js
  describe("reverse", () => {
    it("should reverse a given string", () => {
      const str = "Hello World!";
      const reversed = "!dlroW olleH";

      const result = new Algo().reverse(str);

      expect(result).toEqual(reversed);
    });
  });
  ```

  * In each case, we're checking to see what the method returns given a certain input. We setup the same testing for `isPalindrome` and `capitalize`.
  
  * 🔑 The `describe` statement for `isPalindrome` contains two tests. We needed to to use `.it()` twice to test that `isPalindrome` returns true when a string is a Palindrom and false when it isn't.

  ```js
  describe("isPalindrome", () => {
    it("should return true if a string is a palindrome", () => {
      const str = "racecar";

      const result = new Algo().isPalindrome(str);

      expect(result).toEqual(true);
    });

    it("should return false if a string is not a palindrome", () => {
      const str = "neon";

      const result = new Algo().isPalindrome(str);

      expect(result).toEqual(false);
    });
  ```

  * We follow the same format for the test for `capitalize`. Notice again how Jest allows us to write readable tests that are easy to follow.

  ```js
    describe("capitalize", () => {
      it("should take a string and return a new string with the first letter of each word capitalized", () => {
        const str = "capitalize every first word of the string.";
        const capitalized = "Capitalize Every First Word Of The String.";

        const result = new Algo().capitalize(str);

        expect(result).toEqual(capitalized);
      });
    });
  });
  ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ When should we use the `describe` method?

  * 🙋 When we have several related tests that we wish to group together.

  * ☝️ Why should we write tests before writing code?

  * 🙋 This flow sets up a contract-like expectation for yourself and other developers. It keeps the development process focused. It helps you detect bugs early and write higher quality code.

* Answer any questions before proceeding to the next activity.

### 5. Instructor Demo: Pass Tests (5 min)

* Open `13-Ins_Pass-Tests/tests/fizz.test.js` in your IDE and demonstrate the following:

  * We are importing `fizz.js`, which tells us that the tests in this file should coorrespond to the code in `fizz.js`.

  * Just like in the previous activity, we have a group of tests bundled in a `describe` method.

  ```js
   const fizzBuzz = require('../fizz');
 
    describe('fizzBuzz', () => {
      ...
    }
  ```
  * The first test indicates that if a number in a given array is not a multiple of three or five, that number will be returned. In order to pass this test, we would need to write code that meets this requirement. 

  ```js
    it('should return the number if not a multiple of three or five', () => {
     expect(fizzBuzz([1])).toBe('1');
     expect(fizzBuzz([1, 2])).toBe('1, 2');
   });
  ```

   * The second and third tests indicate that if a number in a given array is a multiple of three or five, the strings 'fizz' and 'buzz' should be returned respectively.

    ```js
  it('should return Fizz if multiple of 3', () => {
    expect(fizzBuzz([3])).toBe('Fizz');
    expect(fizzBuzz([3, 6, 12])).toBe('Fizz, Fizz, Fizz');
  });

  it('should return Buzz if multiple of 5', () => {
    expect(fizzBuzz([10])).toBe('Buzz');
    expect(fizzBuzz([10, 20, 25])).toBe('Buzz, Buzz, Buzz');
  });
  ```

* Open `13-Ins_Pass-Tests/fizz.js` in your IDE and demonstrate the following:

  * When we look at the code in `fizz.js`, we see that `fizzBuzz` will map over an array of numbers that is provided as an argument and examine each of them individually using the variable `singleNum`.

  * Next we are checking to see if singleNum is divisible by three and 5 and setting the Boolean result as the value of variables called `multipleOf3` and `multipleOf5`. 

  ```js
  num.map((singleNum) => {
      const multipleOf3 = singleNum % 3 === 0;
      const multipleOf5 = singleNum % 5 === 0;
  ```

  * Then, we see a string of `if` statements that use `multipleOf3` and `multipleOf5` as conditions. If none of those conditions are met

  * If the number is divisible by three and five, return `fizzBuzz`
  ```js
        if (multipleOf3 && multipleOf5) {
        return 'FizzBuzz';
      }
  ```

  * Similarly, we add a few more conditionals to return just `fizz` or just `buzz`

  ```js
  it('should return Fizz if multiple of 3', () => {
    expect(fizzBuzz([3])).toBe('Fizz');
    expect(fizzBuzz([3, 6, 12])).toBe('Fizz, Fizz, Fizz');
  });

  it('should return Buzz if multiple of 5', () => {
    expect(fizzBuzz([10])).toBe('Buzz');
    expect(fizzBuzz([10, 20, 25])).toBe('Buzz, Buzz, Buzz');
  });
  ```

  * Finally, we check for a mixture of all kinds of output

  ```js
    it('should return a mixture of numbers and strings if passed multiples  and non-multiples of three or five', () => {
      expect(fizzBuzz([1, 2, 3, 5])).toBe('1, 2, Fizz, Buzz');
      expect(fizzBuzz([1, 2, 3, 5, 6, 10])).toBe('1, 2, Fizz, Buzz, Fizz, Buzz');
    expect(fizzBuzz([1, 2, 3, 5, 6, 10, 15])).toBe(
      '1, 2, Fizz, Buzz, Fizz, Buzz, FizzBuzz'
    );
  });
  ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How would we build this?

  * 🙋 Use this example and the previous example of how to write code to make tests pass properly. Because the tests are already written, we are going to start with the second step of making the code.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in [14-Stu_Pass-Tests](../../../../01-Class-Content/10-OOP/01-Activities/14-Stu_Pass-Tests/README.md)

### 6. Student Do: Pass Tests (15 min)

* Direct students to the activity instructions found in [14-Stu_Pass-Tests](../../../../01-Class-Content/10-OOP/01-Activities/14-Stu_Pass-Tests/README.md).

* Break your students into pairs that will work together on this activity.

```md
# 🏗️ Implement Code to Make Tests Pass

Work with a partner to implement the following user story:

* As a developer, I want to write code that will allow my tests to pass

## Acceptance Criteria

* It's done when I have written code for function in `algo.js`.

* It's done when I have ran `npm run test` in the terminal to verify that I correctly implemented each method before moving on.

* It's done when the tests in `tests/algo.test.js` pass.

---

## 💡 Hints

How can we use the tests themselves in `tests/algo.test.js` to give us clues on how to write our function?

## 🏆 Bonus

If you have completed this activity, work through the following challenge with your partner to further your knowledge:

* What part of our code in the `/Unsolved` folder is telling node what to do when we run `npm run test`?
```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students who need extra help.

### 7. Instructor Review: Pass Tests (10 min)

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How comfortable do you feel with TDD thus far? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help!

* Use the prompts and talking points (🔑) below to review the following key points:

  * ✔️ This exercise is not only good practice for understand how to make our code pass, but also great experience with some common interview questions

  * ✔️ Test driven development is a great way to break down a problem into it's most basic parts

  * ✔️ The tests that are written help us think about the inputs and outputs that each function is given and expected to return.

* Open [14-Stu_Pass-Tests](../../../../01-Class-Content/10-OOP/01-Activities/14-Stu_Pass-Tests/Solved/test/algo.test.js) in your IDE and explain the following: 

  * 🔑 Since we had tests written for each method, they will be easier to implement since we didn't have to do any manual testing.

  ```js
  function Algo() {}

  Algo.prototype.reverse = function(str) {
    return str
      .split("")
      .reverse()
      .join("");
  };
  ```

  * 🔑 Because we had tests written, we can be more reasonably sure that each method works as intended.

  ```js
  Algo.prototype.isPalindrome = function(str) {
    return this.reverse(str) === str;
  };
  ```

  * There can be multiple ways to implement methods. It is good practice to worry about testing specific implementation details.

  ```js
  Algo.prototype.capitalize = function(str) {
    return str.split(" ").map(word => {
      return word.substring(0, 1).toUpperCase() + word.substring(1);
    }).join(" ");
  };
  ```

  * ☝️ What is the benefit of writing tests before we write our code?

  * 🙋 This helps us ensure that our code will work. Writing tests first also allows for more rapid development because we will not have to manually test our code.

  * ☝️ What can we do if we don't completely understand this?

  * 🙋 We can refer to supplemental material, read the [Jest docs][(](https://jestjs.io/docs/en/getting-started)), and stick around for office hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 8. Instructor Demo: Organizing Tests (5 min)

* Navigate to `15-Organizing-Tests` in your terminal and demonstrate the following:

* Run `npm i` and then `npm run test` from the command line and demonstrate the following: 

  * 🔑 When we run the command `npm run test` we see that the output shows that we have ran a total of 2 tests.
  
  * The `todo.js` file contains a `Todo` constructor. This constructor creates an object with a provided `text` value. If `text` is not a string or is an empty string, an error is thrown.
  
  * 🔑 Notice that we are not using fat arrow functions for constructors since we need to make use of the `this` keyword. 

  ```js
  function Todo(text) {
    if (typeof text !== "string" || !text.trim().length) {
      throw new Error("Expected parameter 'text' to be a non empty string");
    }

    this.text = text;
  }
  ```

  * `todoList.js` has a constructor for a new todo list. Here we start out with only an empty array for `todos`:

  ```js
  function TodoList() {
    this.todos = [];
  }
  ```
  
  * The `TodoList` has a `addTodo` method that adds a new `Todo` object to the array, a `getNextTodo` property that returns the first todo in the array, and a `completeNextTodo` method that removes the first todo in the list and returns it. 

  ```js
  TodoList.prototype.addTodo = function(text) {
    this.todos.push(new Todo(text));
  };

  TodoList.prototype.getNextTodo = function() {
    return this.todos[0];
  };

  TodoList.prototype.completeNextTodo = function() {
    return this.todos.shift();
  };
  ```


* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How would we build this?

  * 🙋 We could use the Arrange Act Assert pattern as a guide for how to organize test code in a way that makes sense to us and others.

  * ☝️ How do we know what to test for?

  * 🙋 When considering what kinds of things to write tests for, it's a good idea to keep in mind positive, negative, and exception tests.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `16-Stu-Structured-Tests`.

### 9. Student Do: Implement and Write Structured Tests (15 min)

* Direct students to the activity instructions found in `16-Stu-Structured-Tests`.

* Break your students into pairs that will work together on this activity.

  ```md
  # 📐 Add Comments to Implementation of an Arrange Act Assert Pattern

  Work with a partner to add comments describing the functionality of the code found in [Unsolved/test](./Unsolved/test).

  ---

  ## 🏆 Bonus

  If you have completed this activity, work through the following challenge with your partner to further your knowledge:

  * How can you write these tests to ensure that another developer testing your code can understand what the tests are checking? 

  Use [Google](https://www.google.com) or another search engine to research this.
  ```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students who need extra help.

### 10. BREAK (15 min)

### 11. Instructor Review: Implement and Write Structured Tests (10 min) 

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How comfortable do you feel with structuring your tests? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help!

* Use the prompts and talking points (🔑) below to review the following key points:

  * ✔️ Arrange Act Assert pattern

  * ✔️ Positive, negative, and exception tests 

  * ✔️ `it(should ...)`

* Open `16-Stu_Structured-Tests/Solved/test/dayCare.test.js` in your IDE and explain the following: 

  * 🔑 By using the Arrange Act Assert pattern, we can organize our tests into three easy to understand parts.

  ```js
  it("should add a child to the 'children' array", () => {
    // arrange
    const child = new Child("Tammy", 1);
    const dayCare = new DayCare();

    // act
    dayCare.addChild(child);

    // assert
    expect(dayCare.children.length).toEqual(1);
    expect(dayCare.children[0]).toBe(child);
  });
  ```

  * 🔑 We use the `toThrowError` or `toThrow` matcher to check that an error was thrown. We wrap the code that will throw the error in a callback function so Jest will suppress the error.

  ```js
  it("should throw an error if not provided a Child object as an argument", () => {
    const err = new Error(
      "Expected parameter 'child' to be an instance of Child"
    );
    const cb = () => {
      const dayCare = new DayCare();
      dayCare.addChild();
    };

    expect(cb).toThrowError(err);
  });
  ```

  * 🔑 We use negative tests to make sure things work as expected in edge cases.

  ```js
  it("should not add a child if already at capacity", () => {
    const dayCare = new DayCare();
    const child = new Child("Alice", 4);
    dayCare.children = [
      new Child("Tammy", 1),
      new Child("Mark", 2),
      new Child("Alvin", 1)
    ];

    dayCare.addChild(child);

    expect(dayCare.children.length).toEqual(3);
  });
  ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ Why is it helpful for a function to intentionally throw an error?

  * 🙋 If we throw a helpful error message when a function is being misused, the issue is easier to track down than if we didn't throw the error and the misuse caused another unexpected error somewhere else in the code.

* Answer any questions before proceeding to the next activity.

### 12. Instructor Demo: Introduce Mocks (5 min)

* Open `17-Ins_Introduce_mocks/logger.js` in your IDE and demonstrate the following:

* Run `node index` from the command line and demonstrate the following: 

  * 🔑 We see that when we run the index file, our output is using colors for each line of output.

  * In order to print different colors to the console, there are special codes for each color that must be included as a first argument to the `console.log` method.

  ```js
  function Logger() {
    // This is just a way of adding methods to the prototype once in a loop
    // Rather than writing them all out for each color
    if (!this.init) {
      Logger.prototype.init = true;

      const colors = {
        black: "\x1b[30m",
        red: "\x1b[31m",
        green: "\x1b[32m",
        yellow: "\x1b[33m",
        blue: "\x1b[34m",
        magenta: "\x1b[35m",
        cyan: "\x1b[36m",
        white: "\x1b[37m"
      };
  ```

  * Rather than manually write out a method for each color, we're using a loop that runs only once the first time a `Logger` object is created with the constructor. This is called the "dynamic prototype pattern".

  ```js
  for (let key in colors) {
    Logger.prototype[key] = function(...args) {
      console.log(colors[key], ...args);
    };
  }
  ```
  * Open `17-Ins_Introduce-Mocks/index.js` to point out the following:

    * We first import a `Logger` constructor that creates an object capable of logging to the console in different colors. Run the example in your terminal to demonstrate this, and point out the logs themselves, explaining on a high-level how this is achieved.

    ```js
    const Logger = require("./logger");

    const log = new Logger();

    log.red("We can write to the console in different colors!");

    log.blue("We just need to provide an additional argument to the console.log method!");

    log.magenta("The first argument console.log needs is an 'ANSI Escape Code'");

    log.green("You can look these up at https://en.wikipedia.org/wiki/ANSI_escape_code#Colors");

    log.yellow("But they're just codes that represent different colors");

    log.cyan("The second argument console.log should receive is the message to be printed");
    ```

* Open `17-Ins_Introduce-Mocks/test/logger.test.js` file in your IDE and point out the following key points:

  * 🔑 In this file we're using the `jest.spyOn` method to mock and spy on the `console.log` method. We're also using the `mock.mockImplementation` method to replace `console.log`'s functionality with an empty function that does nothing.

  ```js
  it("should print in black", () => {
    const log = new Logger();
    const message = "Hello world!";
    const mock = jest.spyOn(console, "log");
    mock.mockImplementation(() => {});

    log.black(message);

    expect(mock).toBeCalledWith(colors.black, message);

    mock.mockRestore();
  });
  ```

  * 🔑 Since we're mocking the `console.log` method nothing will be printed to the console when the test is run, and we're able to spy on values provided to the `console.log` method. When `log.black` is called, we can verify that `console.log` was also called with the expected message and color.

* Finally, run `npm run test` to show the console log output from the tests.

 
* Ask the class the following questions (☝️) and call on students for the answers (🙋):
  
  * ☝️ Why might it be complicated to test something like a fetch request being called? Or writing to the filesystem?

  * 🙋 The results of a fetch request rely on something outside of our code that we can't always control. Reading and writing to the filesystem can be complicated because our tests may make changes that can impact the results of future tests

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `18-Stu-First-Mock`.

### 13. Student Do: Implement our First Mock (15 min)

* Direct students to the activity instructions found in `18-Stu-First-Mock`.

* Break your students into pairs that will work together on this activity.

```md
# 🐛 Running `npm run test` Results in Errors.

Work with a partner to resolve the following issue(s):

* As a developer, I would like to spy on the output of the `console.log` method in `dayCare.test.js`.

## Expected Behavior

* When we run `npm run test` in the console, we should not recieve an error

* When we run `npm run test` in the console, the Tests and Test Suites for `dayCare.test.js` should be passing

## Actual Behavior

* When we run `npm run test` in the console, we recieve the following error: "Cannot spyOn on a primitive value; undefined given"

* When we run `npm run test` in the console, the Tests and Test Suites for `dayCare.test.js` are not passing

## Steps to Reproduce the Problem

1. Navigate to the `Unsolved` folder in this activity.

2. Run `npm install` in your console.

3. Run `npm run test` in your console.

## Assets

The following image demonstrates the web application's appearance and functionality:

![Tests and Test Suites are passing, no messages are logged in the console, and there are no errors](./images/pass-test.png)

---

## 💡 Hints

* What does the error tell you about what is missing?

* How do we capture the value of `console.log`?

## 🏆 Bonus

If you have completed this activity, work through the following challenge with your partner to further your knowledge:

* Use the [Jest Docs](https://jestjs.io/docs/en/jest-object#jestspyonobject-methodname) to explain two or three other methods that can be used in conjunction with `.spyOn`.

Use [Google](https://www.google.com) or another search engine to research this.

```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students who need extra help.

### 14. Instructor Review: Implement our First Mock (10 min)

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How comfortable do you feel with using the spy on methods? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help!

* Use the prompts and talking points (🔑) below to review the following key points:

  * ✔️ `jest.spyOn()`

  * ✔️ `mock.mockImplementation()`

* Open `18-Stu_First-Mock/Solved/test/dayCare.test.js` in your IDE and explain the following: 

  * 🔑 We use `jest.spyOn()` and pass in the arguments, `console` and `"log"` to spy on the `console.log` method. 
  
  * 🔑 We pass in an empty function to `mock.mockImplementation()` in order to replace the functionality of the `console.log` method.

  * Now, we can use `expect(mock).toBeCalledWith()` to verify that it was called with the arguments we expect.

  ```js
  const mock = jest.spyOn(console, "log");
  mock.mockImplementation(() => {});

  dayCare.addChild(child);

  expect(dayCare.children.length).toEqual(0);
  expect(mock).toBeCalledWith(
    "Unable to add child, they are over the age limit"
  );
  ```

  * We can "unmock" `console.log` by using the `mock.mockRestore` method. It's a good idea to clean up any mocks we run at the end of a test to ensure the next test isn't affected.

  ```js
  mock.mockRestore();
  ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ What can mocks be used for? 

  * 🙋 Mocks can be used to replace code with side-effects, such as printing to the console, making fetch requests, writing/writing to the filesystem so it doesn't happen when tests are being run.

  * ☝️ What can we do if we don't completely understand this?

  * 🙋 We can refer to supplemental material, read the [Jest Docs](https://jestjs.io/docs/en/jest-object#jestspyonobject-methodname), and stick around for office hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 15. Instructor Demo: Module Mock { (5 min)

* Open `19-Ins-Module-Mock-Demo/movieSearch.js` in your IDE and demonstrate the following:

  * 🔑 This file exports a `MovieSearch` constructor that can be used to create an object used for searching the OMDB API.

  ```js
  const axios = require("axios");

  function MovieSearch() {}

  MovieSearch.prototype.buildUrl = function(movie) {
    return `https://www.omdbapi.com/?t=${movie}&apikey=trilogy`;
  };

  MovieSearch.prototype.search = function(movie) {
    return axios.get(this.buildUrl(movie));
  };
  ```
* Open `19-Ins-Module-Mock-Demo/test/movieSearch.test.js` in your IDE and demonstrate the following:

  * 🔑 We require axios and mock it, since we want to prevent actual AJAX requests from happening. This is one way of mocking a node module.

  ```js
  const axios = require("axios");
  const MovieSearch = require("../movieSearch");

  jest.mock("axios");
  ```

  * 🔑 We mock the return value of `axios.get` to be a new Promise object that resolves to an object that contains a `data` property that's set to an empty object. We're mocking the return value to this because it's similar to what we would get from the response from the OMDB API.

  ```js
  it("should search the OMDB API for a given movie", () => {
    const movie = new MovieSearch();
    const name = "Rocky";

    axios.get.mockReturnValue(
      new Promise(function(resolve) {
        resolve({ data: {} });
      })
    );

    expect(movie.search(name)).resolves.toEqual({ data: {} });
    expect(axios.get).lastCalledWith(movie.buildUrl(name));
  });
  ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How would we build this?

  * 🙋 We would first test out our API call to OMDB in something like Insomnia to ensure we understand what our mock should return and how to behave. Then we would import the package we need and wrap it using the `jest.mock()` method. We would then mock the return value of a promise by using `mockReturnValue()`.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `20-Stu-Mock-Fs`.

### 16. Student Do: Mock and Spy on `fs` Module (15 min)

* Direct students to the activity instructions found in `20-Stu-Mock-Fs`.

* Break your students into pairs that will work together on this activity.

```md
# 🏗️ Mock and Spy on `fs` Module

Work with a partner to implement the following user story:

* As an developer, I want to be able to write code to mock and spy on the `fs` module to ensure its called when expected with the correct arguments.

## Acceptance Criteria

* It's done when I have opened the `Unsolved/fileIO.js` file and understand it's contents.

  * It's done when I understand that this exports a `FileIO` constructor function with methods for reading and writing to the filesystem.

  * It's done when I understand that the `read` and `write` methods use the synchronous versions of `fs.readFile` and `fs.writeFile` and that no callback is required.

* It's done when I have opened `Unsolved/tests/fileIO/test.js` and added code to mock the `fs` module and it's `readFileSync` and `writeFileSync` methods so that they don't read from and write to the filesystem.

## 💡 Hints

How can we use the previous demonstration to aid in mocking node modules?

## 🏆 Bonus

If you have completed this activity, work through the following challenge with your partner to further your knowledge:

* How can we further our understanding by writing tests for a `FileIO.prototype.append` method that should append to a given file. How could we update the `Unsolved/fileIO.js` file to include this method using the `fs.appendFileSync` method?

Use [Google](https://www.google.com) or another search engine to research this.

---
2020 Trilogy Education Services, LLC, a 2U, Inc. brand. Confidential and Proprietary. All Rights Reserved.
```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students who need extra help.

### 17. Instructor Review: Mock and Spy on `fs` Module (15 min)

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How comfortable do you feel with mocking and spying on the `fs` module? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help!

* Use the prompts and talking points (🔑) below to review the following key points:

  * ✔️ Mocking node modules

  * ✔️ Avoiding touching the file system

* Open `20-Stu_Mock-Fs/Solved/test/fileIO.test.js` file in your editor and point out the following key points:

  * 🔑 We mock the `fs` module by requiring it and using the `jest.mock` method at the top of the file.

  ```js
  const fs = require("fs");
  const FileIO = require("../fileIO");

  jest.mock("fs");
  ```

  * 🔑 Since `fileIO.read` returns the result of `fs.readFileSync`, we can mock it's return value and verify it was called with the expected arguments without actually making a trip to the filesystem.

  ```js
  it("should call fs.readFileSync with the passed in 'file' argument", () => {
    const fileIO = new FileIO();
    const file = "message.txt";
    let data;

    fs.readFileSync.mockReturnValue("Hello World!");
    data = fileIO.read(file);

    expect(data).toEqual("Hello World!");
    expect(fs.readFileSync).lastCalledWith(file, "utf8");
  });
  ```

  * 🔑 When testing the `fileIO.write` method, we just need to know that the `fs.writeFileSync` method was called with the correct arguments. We aren't testing that the `fs` module works, only that it's being utilized as expected.

  ```js
  it("should call fs.writeFileSync with the passed in 'path' and 'data' arguments", () => {
    const fileIO = new FileIO();
    const path = "message.txt";
    const data = "Hello World!";
  
    fileIO.write(path, data);

    expect(fs.writeFileSync).lastCalledWith(path, data);
  });
  ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ What sort of complications can we avoid by mocking the fs module?

  * 🙋 We can avoid requiring our tests to read and write to the filesystem. Not only would this slow down tests, but it could influence how the next test runs.

  * ☝️ What can we do if we don't completely understand this?

  * 🙋 We can refer to supplemental material, read the [Jest Docs](https://jestjs.io/docs/en/jest-object#jestspyonobject-methodname), and stick around for office hours to ask for help.

* Answer any questions before ending the class.

### 18. END (0 min)

How did today’s lesson go? Your feedback is important. Please take 5 minutes to complete this [anonymous survey](https://forms.gle/RfcVyXiMmZQut6aJ6).

---
2020 Trilogy Education Services, LLC, a 2U, Inc. brand. Confidential and Proprietary. All Rights Reserved.