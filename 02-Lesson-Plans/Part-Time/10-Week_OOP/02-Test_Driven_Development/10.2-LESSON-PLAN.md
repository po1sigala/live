# 10.2 Part-Time Lesson Plan: 

## Overview 

Today's lesson plan will introduce students to test driven development, unit tests, and mock data. 

## Instructor Notes

* In this lesson, students will complete activities `XX-Ins_Demo-Title` through `20-Stu_Mock-Fs`.

* @TODO Every Instructor Notes block begins with the preceding bullet, which outlines the activities that will be covered during class.

* @TODO Empathize with the instructor. If you only had one hour to prepare for class, what are the things you would want to know up front? What are the potential pitfalls in class? Where are students going to get hung up? 

* @TODO Set the instructor up for success.

* Testing frameworks often use a lot of specific methods that read like plain english. You may benefit from creating a few failing tests of your own and then write the code to make them pass to help refresh your memory. You may also benefit from installing the [Jest Snippets](https://marketplace.visualstudio.com/items?itemName=andys8.jest-snippets) plugin for VSCode.

* Remind students to do a `git pull` of the class repo to have today's activities ready and open in VS Code. 

* If you are comfortable doing so, live-code the solutions to the activities. If not, just use the solutions provided and follow the prompts and talking points for review.

* Let students know that the Bonus at the end of each activity is not meant to be extra coding practice, but instead is a self-study on topics beyond the scope of this unit for those who want to further their knowledge.

## Learning Objectives

By the end of class, students will be able to:

* Explain the benefits of test-driven-development (**TDD**).

* Use **unit tests** before as a way to define code requirements for code that hasn't been written yet.

* Write **unit tests** for pre-existing JavaScript functions.

* Use **mocks** to test side effects such as reading/writing to the file system, printing to the console, and AJAX requests.

* Use the Arrange, Act, Assert pattern to structure test code.

## Time Tracker
@TODO ADD ACTIVITY TITLES for Instructor Demo, Student Do, and Instructor Review
| Start  | #   | Activity Name                  | Duration |
| ------ | --- | ------------------------------ | -------- |
| 6:30PM | 1   | Instructor Do: Stoke Curiosity | 0:10     |
| 6:40PM | 2   | Instructor Demo:               | 0:05     |
| 6:45PM | 3   | Student Do:                    | 0:15     |
| 7:00PM | 4   | Instructor Review:             | 0:10     |
| 7:10PM | 5   | Instructor Demo:               | 0:05     |
| 7:15PM | 6   | Student Do:                    | 0:15     |
| 7:30PM | 7   | Instructor Review:             | 0:10     |
| 7:40PM | 8   | Instructor Demo:               | 0:05     |
| 7:45PM | 9   | Student Do:                    | 0:15     |
| 8:00PM | 10  | BREAK                          | 0:15     |
| 8:15PM | 11  | Instructor Review:             | 0:10     |
| 8:25PM | 12  | Instructor Demo:               | 0:05     |
| 8:30PM | 13  | Student Do:                    | 0:15     |
| 8:45PM | 14  | Instructor Review:             | 0:10     |
| 8:55PM | 15  | Instructor Demo:               | 0:05     |
| 9:00PM | 16  | Student Do:                    | 0:15     |
| 9:15PM | 17  | Instructor Review:             | 0:15     |
| 9:30PM | 18  | END                            | 0:00     |

---

## Class Instruction

### 1. Instructor Do: Stoke Curiosity (10 min)

* Welcome students to class.

* Test driven development is a process and methodology. In order to prime our brain for learning, let's go over some terms that we will see throughout this unit. We will also discuss a very simple flow of how test driven development works (TDD).

* Terms:
  * **Unit Tests**: Unit tests ensure reliability and expected behavior of things like functions or classes. Unit tests assert that the unit being tested returns the expected output.
  
  * **Integration Tests**: Integration tests ensure proper cooperation of units in your application. Integration tests may focus on an API, user input, or user interface that may have subsequent actions like writing to a database or logging output.
  
  * **End-to-end Tests**: End-to-end tests assert that the application will function as expected from the perspective of a user. These tests usually focus almost entirely on the user interface of an application.

* We will be creating tests *before* we write our code. This is the core concept of how TDD works. We let the need to make tests pass dictate how our code should be written. This flow sets up a contract-like expectation for yourself and other developers. It also keeps the development process focused.

* TDD Cycle: We are going to focus on the basics and expand on each step in this unit, but for now all you need to know are the basic steps to TDD:

  1. Write a failing test
  2. Make the test pass
  3. Refactor the implementation


### 2. Instructor Demo: TDD Dissect (5 min)

* Open [11-Ins-TDD](../../../../01-Class-Content/10-OOP/01-Activities/11-Ins-TDD/index.js) in your IDE and demonstrate the following:

* Run `node index` from the command line and demonstrate the following: 

  * When we look at the code in `index.js`, we can see several methods chained together that seem to preform specific operations one after another.

  ```js
  const value = new Arithmetic(4)
    .plus(8)
    .plus(15)
    .minus(16)
    .minus(23)
    .plus(42)
    .plus(108)
    .value();
  ```

  * We also see that we are importing an object called `Arithmetic` at the top of the file.

  ```js
  const Arithmetic = require('./arithmetic');
  ```

  * We can tell by looking at the `new` keyword on line 3 that `value` is an instance of `Arithmetic`. This means that it will inherit the methods on the `Arithmetic` prototype chain.

  * 🔑 If we right click on the word `Arithmetic` at the top of the file and click "Go to definition", we will be brought to the file that declares all the methods we saw in `index.js`.

  ```js
  Arithmetic.prototype.plus = function(num = 0) {
    const newNumber = this.number + num;

    return new Arithmetic(newNumber);
  };

  Arithmetic.prototype.minus = function(num = 0) {
    const newNumber = this.number - num;

    return new Arithmetic(newNumber);
  };

  Arithmetic.prototype.value = function() {
    return this.number;
  };
  ```
  * In order to test that these methods take the provided input and return the correct output, we have created a `/tests/` folder and an `arithmetic.test.js` file.

  * 🔑 One important thing to remember is that while we are dissecting the code currently, the way you would go about building this is to create the tests first. Hence, the "test driven" part of TDD.

  * After importing `Arithmetic` just like we did in `index.js`, we start with a describe statement. This groups together several related tests and also helps with readability.

  * The `it` portion of this test describes how the function should behave in a successful test case. Consider our first it statement: 

    ```js
    describe("Arithmetic", () => {
    describe("Initialization", () => {
      it("should return an object containing a 'number' property when called with the 'new' keyword", () => {
        const obj = new Arithmetic();

        expect("number" in obj).toEqual(true);
      });
    ```

  * The following code block then creates a new instance of Arithmetic and uses the `expect` method to test values. In our case, we are testing to see that the key `number` has a truthy value in our newly created object.
  
  * 🔑 Now that we understand how the tests are written, lets run our tests:

    ```bash
    npm run test
    ```
  
  * We should see the output in the terminal from our testing framework called `jest`. All the passing tests will appear in green and all failing tests will appear in red.

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How would we build this?

  * 🙋 We would first build the tests, and then create the code to make the tests pass.

  * ☝️ What is the significance of the `expect`, `it`, and `toEqual` methods in our testing framework?

  * 🙋 Each of these are methods that tell the testing framework what to expect in terms of output from our functions. You can learn more about how to use these by reading the [Jest Docs](https://jestjs.io/docs/en/expect#expectvalue)

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in [12-Stu-TDD](../../../../01-Class-Content/10-OOP/01-Activities/12-Stu_TDD/README.md).

### 3. Student Do: Test Driven Development (15 min)

* Direct students to the activity instructions found in [12-Stu-TDD](../../../../01-Class-Content/10-OOP/01-Activities/12-Stu_TDD/README.md).

* Break your students into pairs that will work together on this activity.

  ```md
  # 🏗️ Implement Tests

  Work with a partner to implement the following user story:

  * As a developer, I want to create tests to define and test the expected output for code that hasn't been implemented yet. 

  ## Acceptance Criteria

  * It's done when I have written a test for the `reverse` method.
    * The `reverse` method should take a string as an argument and return a new reversed version of the string. e.g. "Hello" should return "elloH".

  * It's done when I have written a test for the `isPalindrome` method.
    * `isPalindrome` should take a string as an argument and return the boolean `true` if the provided string is a palindrome. A palindrome is a word that is the same backwards as it is forwards, e.g. "racecar". Return `false` is the string is not a palindrome.
    
  * It's done when I have written a test for the `capitalize` method.
    * The `capitalize` method should take a string as an argument and return a new string with the first letter of each word capitalized. e.g. "hello world!" should return "Hello World!".

  * **Important**: Write code for the tests only, the only file you will be modifying is `tests/algo.test.js`. Initially all of your tests will fail since these methods are empty, but using the tests you can define how each method _should_ work.

  ## 💡 Hints

  * How can we use the `describe`, `it` and `expect` functions in Jest to aid to check for expected behavior?

  * Is it normal for all the tests be fail at first? If so, why?

  ## 🏆 Bonus

  If you have completed this activity, work through the following challenge with your partner to further your knowledge:

  * Where can you find some examples of well written tests?
  ```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students who need extra help.

### 4. Instructor Review: Test Driven Development (10 min)

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How comfortable do you feel with TDD? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help!

* Use the prompts and talking points (🔑) below to review the following key points:

  * ✔️ By providing our functions different inputs, we can make sure they work correctly by checking their return values.

  * ✔️ Tests ensure our functions carry out their logic the same way every time.

  * ✔️ Tests allow other developers to quickly see what a function or suite of functions should be achieving.

* Open [12-Stu-TDD](../../../../01-Class-Content/10-OOP/01-Activities/12-Stu_TDD/Solved/) in your IDE and explain the following: 

  * We first require the file containing the functions we would like to test.

  ```js
  const Algo = require("../algo");
  ```

  * We can then use the `describe` function to begin setting up our tests. We are going to start with the `Algo` definition.

  ```js
  describe("Algo", () => {
  ```

  * Now we can begin to test specific functionality. Here we are saying that when passed a string and reversed, it returns the proper reversed string. the `it` method allows us to describe what the function should do in plain english given certain parameters.

  ```js
  describe("reverse", () => {
    it("should reverse a given string", () => {
      const str = "Hello World!";
      const reversed = "!dlroW olleH";

      const result = new Algo().reverse(str);

      expect(result).toEqual(reversed);
    });
  });
  ```

  * 🔑 In each case, we're checking to see what the method returns given a certain input. We setup the same testing for `isPalindrome` and capitalize.

  ```js
  describe("isPalindrome", () => {
    it("should return true if a string is a palindrome", () => {
      const str = "racecar";

      const result = new Algo().isPalindrome(str);

      expect(result).toEqual(true);
    });

    it("should return false if a string is not a palindrome", () => {
      const str = "neon";

      const result = new Algo().isPalindrome(str);

      expect(result).toEqual(false);
    });
  ```

  * 🔑 Even though we haven't written code for these methods yet, it would be easy for someone to understand what the methods should do based on these tests.

  ```js
    describe("capitalize", () => {
      it("should take a string and return a new string with the first letter of each word capitalized", () => {
        const str = "capitalize every first word of the string.";
        const capitalized = "Capitalize Every First Word Of The String.";

        const result = new Algo().capitalize(str);

        expect(result).toEqual(capitalized);
      });
    });
  });
  ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ Do you think these are good tests?

  * 🙋 Yes, if they fail, it means the code isn't doing what it should.

  * ☝️ Do you think these are _enough_ tests?

  * 🙋 No, it doesn't account for things like empty strings, what should happen if given invalid arguments or edge cases like palindromes with different casing or spaces.

* Answer any questions before proceeding to the next activity.

### 5. Instructor Demo: Tests Pass (5 min)

* Open [13-Ins-Pass-Tests](../../../../01-Class-Content/10-OOP/01-Activities/13-Ins-Pass-Tests/fizz.js) in your browser and demonstrate the following:

* First open `package.json` and point out our developer dependency of `jest`, then run `npm i` in the directory.

* Run `npm run test` from the command line and demonstrate the following: 

  * 🔑 When we run our test, it checks in `package.json` from any script with the key `test`. As we noted earlier, our test script is defined with a value of `jest`.

  * 🔑 When `jest` is invoked, it will look for files matching a specific pattern of `[filename].test.js`. It will find our one and only test in the `/tests` directory and run it.

  * We can see that all the tests pass, but now lets examine the code that allows these tests to pass:

  ```js
  const fizzBuzz = (num) => { }

  module.exports = fizzBuzz
  ```

  * First we export our function so that `jest` doesn't throw an error right out of the gate. Then we head back to our test file to examine the first case:

  ```js
    it('should return the number if not a multiple of three or five', () => {
      expect(fizzBuzz([1])).toBe('1');
      expect(fizzBuzz([1, 2])).toBe('1, 2');
  });
  ```

  * The following code will map over teh array of numbers that is provided to the function and examine each of them individually using the variable `singleNum`

  ```js
  num.map((singleNum) => {
      const multipleOf3 = singleNum % 3 === 0;
      const multipleOf5 = singleNum % 5 === 0;
  ```

  * Here we are setting some boolean values to variables called `multipleOf3` and `multipleOf5`. We then use these boolean values in our conditional statements:

  * If the number is divisible by three and five, return `fizzBuzz`
  ```js
        if (multipleOf3 && multipleOf5) {
        return 'FizzBuzz';
      }
  ```

  * Similarly, we add a few more conditionals to return just `fizz` or just `buzz`

  ```js
  it('should return Fizz if multiple of 3', () => {
    expect(fizzBuzz([3])).toBe('Fizz');
    expect(fizzBuzz([3, 6, 12])).toBe('Fizz, Fizz, Fizz');
  });

  it('should return Buzz if multiple of 5', () => {
    expect(fizzBuzz([10])).toBe('Buzz');
    expect(fizzBuzz([10, 20, 25])).toBe('Buzz, Buzz, Buzz');
  });
  ```

  * Finally, we check for a mixture of all kinds of output

  ```js
    it('should return a mixture of numbers and strings if passed multiples  and non-multiples of three or five', () => {
      expect(fizzBuzz([1, 2, 3, 5])).toBe('1, 2, Fizz, Buzz');
      expect(fizzBuzz([1, 2, 3, 5, 6, 10])).toBe('1, 2, Fizz, Buzz, Fizz, Buzz');
    expect(fizzBuzz([1, 2, 3, 5, 6, 10, 15])).toBe(
      '1, 2, Fizz, Buzz, Fizz, Buzz, FizzBuzz'
    );
  });
  ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How would we build this?

  * 🙋 Use this example and the previous example of how to write code to make tests pass properly. Because the tests are already written, we are going to start with the second step of making the code.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in [14-Stu_Pass-Tests](../../../../01-Class-Content/10-OOP/01-Activities/14-Stu_Pass-Tests/README.md)

### 6. Student Do: Pass Tests (15 min)

* Direct students to the activity instructions found in [14-Stu_Pass-Tests](../../../../01-Class-Content/10-OOP/01-Activities/14-Stu_Pass-Tests/README.md).

* Break your students into pairs that will work together on this activity.

```md
# 🏗️ Implement Code to Make Tests Pass

Work with a partner to implement the following user story:

* As a developer, I want to write code that will allow my tests to pass

## Acceptance Criteria

* It's done when I have written code for function in `algo.js`.

* It's done when I have ran `npm run test` in the terminal to verify that I correctly implemented each method before moving on.

* It's done when the tests in `tests/algo.test.js` pass.

---

## 💡 Hints

How can we use the tests themselves in `tests/algo.test.js` to give us clues on how to write our function?

## 🏆 Bonus

If you have completed this activity, work through the following challenge with your partner to further your knowledge:

* What part of our code in the `/Unsolved` folder is telling node what to do when we run `npm run test`?
```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students who need extra help.

### 7. Instructor Review: Pass Tests (10 min)

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How comfortable do you feel with TDD thus far? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help!

* Use the prompts and talking points (🔑) below to review the following key points:

  * ✔️ This exercise is not only good practice for understand how to make our code pass, but also great experience with some common interview questions

  * ✔️ Test driven development is a great way to break down a problem into it's most basic parts

  * ✔️ The tests that are written help us think about the inputs and outputs that each function is given and expected to return.

* Open [14-Stu_Pass-Tests](../../../../01-Class-Content/10-OOP/01-Activities/14-Stu_Pass-Tests/Solved/test/algo.test.js) in your IDE and explain the following: 

  * 🔑 Since we had tests written for each method, they will be easier to implement since we didn't have to do any manual testing.

  ```js
  function Algo() {}

  Algo.prototype.reverse = function(str) {
    return str
      .split("")
      .reverse()
      .join("");
  };
  ```

  * 🔑 Because we had tests written, we can be more reasonably sure that each method works as intended.

  ```js
  Algo.prototype.isPalindrome = function(str) {
    return this.reverse(str) === str;
  };
  ```

  * There can be multiple ways to implement methods. It is good practice to worry about testing specific implementation details.

  ```js
  Algo.prototype.capitalize = function(str) {
    return str.split(" ").map(word => {
      return word.substring(0, 1).toUpperCase() + word.substring(1);
    }).join(" ");
  };
  ```

  * ☝️ What is the benefit of writing tests before we write our code?

  * 🙋 This helps us ensure that our code will work. Writing tests first also allows for more rapid development because we will not have to manually test our code.

  * ☝️ What can we do if we don't completely understand this?

  * 🙋 We can refer to supplemental material, read the [Jest docs][(](https://jestjs.io/docs/en/getting-started)), and stick around for office hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 8. Instructor Demo: Organizing Tests (5 min)

* Navigate to `15-Organizing-Tests` in your terminal and demonstrate the following:

* Run `npm i` and then `npm run test` from the command line and demonstrate the following: 

  * 🔑 When we run the command `npm run test` we see that the output shows that we have ran a total of 2 tests.
  
  * The `todo.js` file contains a `Todo` constructor. This constructor creates an object with a provided `text` value. If `text` is not a string or is an empty string, an error is thrown.
  
  * 🔑 Notice that we are not using fat arrow functions for constructors since we need to make use of the `this` keyword. 

  ```js
  function Todo(text) {
    if (typeof text !== "string" || !text.trim().length) {
      throw new Error("Expected parameter 'text' to be a non empty string");
    }

    this.text = text;
  }
  ```

  * `todoList.js` has a constructor for a new todo list. Here we start out with only an empty array for `todos`:

  ```js
  function TodoList() {
    this.todos = [];
  }
  ```
  
  * The `TodoList` has a `addTodo` method that adds a new `Todo` object to the array, a `getNextTodo` property that returns the first todo in the array, and a `completeNextTodo` method that removes the first todo in the list and returns it. 

  ```js
  TodoList.prototype.addTodo = function(text) {
    this.todos.push(new Todo(text));
  };

  TodoList.prototype.getNextTodo = function() {
    return this.todos[0];
  };

  TodoList.prototype.completeNextTodo = function() {
    return this.todos.shift();
  };
  ```


* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How would we build this?

  * 🙋 We could use the Arrange Act Assert pattern gives us a guide for how to organize test code in a way that makes sense to us and other.

  * ☝️ How do we know what to test for?

  * 🙋 When considering what kinds of things to write tests for, it's a good idea to keep in mind positive, negative, and exception tests.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `16-Stu-Structured-Tests`.

### 9. Student Do: Implement and Write Structured Tests (15 min)

* Direct students to the activity instructions found in `16-Stu-Structured-Tests`.

* Break your students into pairs that will work together on this activity.

  ```md
  # 🏗️ Implement and Write Structured Tests

  Work with a partner to implement the following user story:
    
  * As a developer, I want to adopt and use the Arrange Act Assert pattern when writing tests.

  ## Acceptance Criteria

  * It's done when I have opened the `Unsolved/child.js` file and examine its contents.

    * This file exports a `Child` constructor function. The constructor function expects to be provided a name and an age.

    * If `name` is not a string or `name` is an empty string, an error is thrown.

    * If `age` is not a number, is `NaN` or is less than `0`, an error is thrown.

    * Otherwise these values are added to the created instance when the constructor is called.

  * It's done when I understand the logic in `Unsolved/dayCare.js`.
    
    * This file requires the `Child` constructor function.

    * This file exports a `DayCare` constructor function.

    * The `DayCare` constructor has an empty `children` array, a capacity of 3, and an `ageLimit` of 6.

    * The `DayCare` constructor has an `addChild` method used for adding `Child` objects to the `children` array, and a `pickupChild` method used for removing a `Child` object from the `children` array.

  * It's done when I write code to test the `Child` constructor inside of the `Unsolved/test/child.test.js` file.
    
  * It's done when I write code to test the `DayCare` constructor and methods inside of the `Unsolved/test/dayCare.test.js` file.

  ## 💡 Hints

  When considering what to write tests for, ask yourself the following questions:

    * Positive tests: What happens when things go well?

    * Negative tests: What happens in edge cases or when things shouldn't work?

    * Exception tests: What happens in cases when an error should be thrown?


  ## 🏆 Bonus

  If you have completed this activity, work through the following challenge with your partner to further your knowledge:

  * How can you write these tests to ensure that another developer testing your code can understand what the tests are checking?

  Use [Google](https://www.google.com) or another search engine to research this.

  ---
  2020 Trilogy Education Services, LLC, a 2U, Inc. brand. Confidential and Proprietary. All Rights Reserved.
  ```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students who need extra help.

### 10. BREAK (15 min)

### 11. Instructor Review: Implement and Write Structured Tests (10 min)

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How comfortable do you feel with structuring your tests? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help!

* Use the prompts and talking points (🔑) below to review the following key points:

  * ✔️ Arrange Act Assert pattern

  * ✔️ Positive, negative, and exception tests 

  * ✔️ `it(should ...)`

* Open `16-Stu_Structured-Tests/Solved/test/child.test.js` in your IDE and explain the following: 

  * 🔑 By using the Arrange Act Assert pattern, we can organize our tests into three easy to understand parts.

  ```js
  it("should not add a child if already at capacity", () => {
    const dayCare = new DayCare();
    const child = new Child("Alice", 4);
    dayCare.children = [
      new Child("Tammy", 1),
      new Child("Mark", 2),
      new Child("Alvin", 1)
    ];

    dayCare.addChild(child);

    expect(dayCare.children.length).toEqual(3);
  });
  ```

  * 🔑 We would use the `toThrowError` or `toThrow` matcher to check than an error was thrown.

  ```js
  it("should throw an error if not provided a Child object as an argument", () => {
    const err = new Error(
      "Expected parameter 'child' to be an instance of Child"
    );
    const cb = () => {
      const dayCare = new DayCare();
      dayCare.addChild();
    };

    expect(cb).toThrowError(err);
  });
  ```

  * 🔑 We use negative tests to make sure things work as expected in edge cases.

  ```js
  it("should not add a child if already at capacity", () => {
    const dayCare = new DayCare();
    const child = new Child("Alice", 4);
    dayCare.children = [
      new Child("Tammy", 1),
      new Child("Mark", 2),
      new Child("Alvin", 1)
    ];

    dayCare.addChild(child);

    expect(dayCare.children.length).toEqual(3);
  });
  ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ Why is it helpful for a function to intentionally throw an error?

  * 🙋 If we throw a helpful error message when a function is being misused, the issue is easier to track down than if we didn't throw the error and the misuse caused another unexpected error somewhere else in the code.

* Answer any questions before proceeding to the next activity.

### 12. Instructor Demo: { ACTIVITY NAME } (5 min) // 17-Ins_Introduce_mocks

@TODO USE THE FOLLOWING FOR BROWSER AND/OR COMMAND LINE DEMOS, RESPECTIVELY. REMOVE IF UNUSED

* Open `@TODO/folder/file` in your browser and demonstrate the following:

* Run `@TODO/folder/file { AND ARGS, IF ANY }` from the command line and demonstrate the following: 

  * 🔑 @TODO { WHEN WE DO THIS, IT DOES THAT. }

  * 🔑 @TODO { WE ALSO SEE THESE THINGS. }

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How would we build this?

  * 🙋 @TODO { YES, HOW? } 

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `@TODO/folder/file`.

### 13. Student Do: { ACTIVITY NAME } (15 min) 18-Stu-First_Mock (unsolved)

* Direct students to the activity instructions found in `@TODO/folder/file`.

* Break your students into pairs that will work together on this activity.

```md
@TODO ADD INSTRUCTIONS TABBED
```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students who need extra help.

### 14. Instructor Review: { ACTIVITY NAME } (10 min) 18-Stu-First_Mock (solved)

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How comfortable do you feel with `@TODO TOPIC`? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help!

* Use the prompts and talking points (🔑) below to review the following key points:

  * ✔️ @TODO { THIS }

  * ✔️ @TODO { THAT }

  * ✔️ @TODO { THE OTHER }

* Open `@TODO/folder/file` in your IDE and explain the following: 

  * @TODO { WE DO THIS AND THE RESULT IS THAT }

    ```
    @TODO ADD CODE SNIPPET, TABBED
    ```

  * 🔑 @TODO DON'T FORGET TO USE THE KEY EMOJI ON KEY POINTS, BUT ONLY KEY POINTS, NOT _EVERY_ POINT

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ @TODO { DO WE END OUR REVIEWS WITH A QUESTION? }

  * 🙋 @TODO { YES, WE DO! }

  * ☝️ What can we do if we don't completely understand this?

  * 🙋 @TODO We can refer to supplemental material, read the [{ DOCS }]({ URL }), and stick around for office hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 15. Instructor Demo: { ACTIVITY NAME } (5 min) 19-Ins-Module-Mock-Demo

@TODO USE THE FOLLOWING FOR BROWSER AND/OR COMMAND LINE DEMOS, RESPECTIVELY. REMOVE IF UNUSED

* Open `@TODO/folder/file` in your browser and demonstrate the following:

* Run `@TODO/folder/file { AND ARGS, IF ANY }` from the command line and demonstrate the following: 

  * 🔑 @TODO { WHEN WE DO THIS, IT DOES THAT. }

  * 🔑 @TODO { WE ALSO SEE THESE THINGS. }

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How would we build this?

  * 🙋 @TODO { YES, HOW? } 

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `@TODO/folder/file`.

### 16. Student Do: { ACTIVITY NAME } (15 min) 20-Stu-Mick-FS (unsolved)

* Direct students to the activity instructions found in `@TODO/folder/file`.

* Break your students into pairs that will work together on this activity.

```md
@TODO ADD INSTRUCTIONS
```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students who need extra help.

### 17. Instructor Review: { ACTIVITY NAME } (15 min) 20-Stu-Mick-FS (solved)

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How comfortable do you feel with `@TODO TOPIC`? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help!

* Use the prompts and talking points (🔑) below to review the following key points:

  * ✔️ @TODO { THIS }

  * ✔️ @TODO { THAT }

  * ✔️ @TODO { THE OTHER }

* Open `@TODO/folder/file` in your IDE and explain the following: 

  * @TODO { WE DO THIS AND THE RESULT IS THAT }

    ```
    @TODO ADD CODE SNIPPET, TABBED
    ```

  * 🔑 @TODO DON'T FORGET TO USE THE KEY EMOJI ON KEY POINTS, BUT ONLY KEY POINTS, NOT _EVERY_ POINT

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ @TODO { DO WE END OUR REVIEWS WITH A QUESTION? }

  * 🙋 @TODO { YES, WE DO! }

  * ☝️ What can we do if we don't completely understand this?

  * 🙋 @TODO We can refer to supplemental material, read the [{ DOCS }]({ URL }), and stick around for office hours to ask for help.

* Answer any questions before ending the class.

### 18. END (0 min)

How did today’s lesson go? Your feedback is important. Please take 5 minutes to complete this [anonymous survey](https://forms.gle/RfcVyXiMmZQut6aJ6).

---
@TODO © YEAR Trilogy Education Services, LLC, a 2U, Inc. brand. Confidential and Proprietary. All Rights Reserved.