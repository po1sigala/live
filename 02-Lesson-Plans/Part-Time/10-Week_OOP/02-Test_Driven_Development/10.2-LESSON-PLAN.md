# 10.2 Part-Time Lesson Plan: Object-Oriented Programming (OOP)

## Overview 

Today's lesson plan will introduce students to test driven development, unit tests, and mock data. 

## Instructor Notes

* In this lesson, students will complete activities `11-Ins_TDD` through `20-Stu_Mock-Fs`.

* Testing frameworks often use a lot of specific methods that read like plain english. You may benefit from creating a few failing tests of your own and then write the code to make them pass to help refresh your memory. You may also benefit from installing the [Jest Snippets](https://marketplace.visualstudio.com/items?itemName=andys8.jest-snippets) plugin for VSCode.

* Remind students to do a `git pull` of the class repo to have today's activities ready and open in VS Code. 

* If you are comfortable doing so, live-code the solutions to the activities. If not, just use the solutions provided and follow the prompts and talking points for review.

* Let students know that the Bonus at the end of each activity is not meant to be extra coding practice, but instead is a self-study on topics beyond the scope of this unit for those who want to further their knowledge.

## Learning Objectives

By the end of class, students will be able to:

* Explain the benefits of test-driven-development (TDD).

* Use unit tests before as a way to define code requirements for code that hasn't been written yet.

* Write unit tests for pre-existing JavaScript functions.

* Use mocks to test side effects such as reading/writing to the file system, printing to the console, and AJAX requests.

* Use the Arrange, Act, Assert pattern to structure test code.

## Time Tracker
| Start  | #   | Activity Name                       | Duration |
| ------ | --- | ----------------------------------- | -------- |
| 6:30PM | 1   | Instructor Do: Stoke Curiosity      | 0:10     |
| 6:40PM | 2   | Instructor Demo: TDD                | 0:05     |
| 6:45PM | 3   | Student Do: TDD                     | 0:15     |
| 7:00PM | 4   | Instructor Review: TDD              | 0:10     |
| 7:10PM | 5   | Instructor Demo: Pass Tests         | 0:05     |
| 7:15PM | 6   | Student Do: Pass Tests              | 0:15     |
| 7:30PM | 7   | Instructor Review: Pass Tests       | 0:10     |
| 7:40PM | 8   | Instructor Demo: Organizing Tests   | 0:05     |
| 7:45PM | 9   | Student Do: Organizing Tests        | 0:15     |
| 8:00PM | 10  | BREAK                               | 0:15     |
| 8:15PM | 11  | Instructor Review: Organizing Tests | 0:10     |
| 8:25PM | 12  | Instructor Demo: Mocks              | 0:05     |
| 8:30PM | 13  | Student Do: Mocks                   | 0:15     |
| 8:45PM | 14  | Instructor Review: Mocks            | 0:10     |
| 8:55PM | 15  | Instructor Demo: Mock fs            | 0:05     |
| 9:00PM | 16  | Student Do: Mock fs                 | 0:15     |
| 9:15PM | 17  | Instructor Review: Mock fs          | 0:15     |
| 9:30PM | 18  | END                                 | 0:00     |

---

## Class Instruction

### 1. Instructor Do: Stoke Curiosity (10 min)

* Welcome students to class.

* Test driven development is a process and methodology. In order to prime our brain for learning, let's go over some terms that we will see throughout this unit. We will also discuss a very simple flow of how test driven development works (TDD).

* Terms:
  * **Unit Tests**: Unit tests ensure reliability and expected behavior of things like functions or classes. Unit tests assert that the unit being tested returns the expected output.
  
  * **Integration Tests**: Integration tests ensure proper cooperation of units in your application. Integration tests may focus on an API, user input, or user interface that may have subsequent actions like writing to a database or logging output.
  
  * **End-To-End Tests**: End-to-end tests assert that the application will function as expected from the perspective of a user. These tests usually focus almost entirely on the user interface of an application.

* We will be creating tests *before* we write our code. This is the core concept of how TDD works. We let the need to make tests pass dictate how our code should be written. This flow sets up a contract-like expectation for yourself and other developers. It also keeps the development process focused.

* TDD Cycle: We are going to focus on the basics and expand on each step in this unit, but for now all you need to know are the basic steps to TDD:

  1. Write a failing test
  2. Make the test pass
  3. Refactor the implementation


### 2. Instructor Demo: TDD Dissect (5 min)

* Open `11-Ins_TDD/package.json` in your IDE and demonstrate the following:

  * We have included `jest` as a dependency in `package.json` and a special test script defined with a value of `jest`.

  ```json
   "scripts": {
    "test": "jest"
  },
  ...
    "devDependencies": {
    "jest": "^26.5.2"
  }
  ```

* Run `npm install` and  `npm run test` from the command line to demonstrate the following: 

  * 🔑 When we run our test, it checks in `package.json` for a script with the key `test`. As we just noted, test script is defined with a value of `jest`.

  * 🔑 When `jest` is invoked, it will look for files matching a specific pattern of `[filename].test.js`. It will find our one and only test in the `/tests` directory and run it.

  * We can see that everything is passing; now let's examine the actual tests.

* Open `11-Ins_TDD/tests/arithmetic.test.js` in your IDE and demonstrate the following:

  * We have created a `/tests/` folder and an `arithmetic.test.js` file that contains tests for `arithmetic.js`.

  * We are importing an object called `Arithmetic` at the top of the file that connects our tests to `arithmetic.js`. 

  ```js
  const Arithmetic = require('./arithmetic');
  ```
  
  * Let's take a look at the first test. We start with a `describe` statement that contains several other `describe` statements. The parent `describe` statement groups together the related tests for different methods, which also helps with readability.

     ```js
      describe("Arithmetic", () => {
       describe("Initialization", () => {
        ...
       });
      });
       describe("plus", () => {
      ...
       });
      });
       describe("minus", () => {
        ...
       });
      });
       describe("value", () => {
         ...
       });
      });
     });
    ```

  * The `it` portion of this test describes how the function should behave in a successful test case. For example, our first `it` statement indicates that initialization `"should return an object containing a 'number' property when called with the 'new' keyword"`.

  * The following code block then creates a new instance of Arithmetic and uses the `expect` and `toEqual` methods to test values. In our case, we are testing to see that the key `number` has a truthy value in our newly created object.

    ```js
    describe("Arithmetic", () => {
      describe("Initialization", () => {
        it("should return an object containing a 'number' property when called with the 'new' keyword", () => {
        const obj = new Arithmetic();
        expect("number" in obj).toEqual(true);
    });
    ```

  * The other tests under the parent `describe` statement are formatted in the same way, but test other methods in `arithmetic.js` called `plus`, `minus`, and `value`.

  * Let's take a look at `arithmetic.js`. If we right click on the word `Arithmetic` at the top of the file and click "Go to definition", we will be brought to the file that declares all the methods we saw tests for in `arithmetic.test.js`.

  * 🔑 Remember, in a typical TDD cycle, we would write tests first and then write the code that we see here to help our tests pass.

  * Here, we see all of the methods that appeared in the tests in `arithmetic.test.js`. 

  ```js
  function Arithmetic(number = 0) {
  this.number = number;
  }

  Arithmetic.prototype.plus = function(num = 0) {
    const newNumber = this.number + num;

    return new Arithmetic(newNumber);
  };

  Arithmetic.prototype.minus = function(num = 0) {
    const newNumber = this.number - num;

    return new Arithmetic(newNumber);
  };

  Arithmetic.prototype.value = function() {
    return this.number;
  };
  ```
  * Remember, the first test expected `number`to be initialized with a value, and that is what the function `Arithmetic` appears to accomplish.

  ```js
  function Arithmetic(number = 0) {
  this.number = number;
  }
  ```
  * Before we check to see if our tests are working, let's check out `index.js`

* Navigate to `11-Ins_TDD/index.js` in your IDE and explain the following:

  * We see that `index.js` is importing `arithmetic.js` at the top of the file, just like in `arithmetic.test.js`.

  * When we look at the code in `index.js`, we can see the methods declared in `arithmetic.js` chained together, preforming specific operations one after another and finally, logging the value.

  ```js
  const value = new Arithmetic(4)
    .plus(8)
    .plus(15)
    .minus(16)
    .minus(23)
    .plus(42)
    .plus(108)
    .value();

    console.log(value);
  ```

  * If we run `node index.js` , we see the value, `138` logged in the console.
  
  * 🔑 Now that we understand how the tests are written, let's run our tests:

    ```bash
    npm run test
    ```
  
  * We should see the output in the terminal from our testing framework called `jest`. All the passing tests will appear in green and all failing tests will appear in red.

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How would we build this?

  * 🙋 We would first build the tests, and then create the code to make the tests pass.

  * ☝️ What is the significance of the `expect`, `it`, and `toEqual` methods in our testing framework?

  * 🙋 Each of these are methods that tell the testing framework what to expect in terms of output from our functions. You can learn more about how to use these by reading the [Jest Docs](https://jestjs.io/docs/en/expect#expectvalue)

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `12-Stu_TDD/README.md`.

### 3. Student Do: Test Driven Development (15 min)

* Direct students to the activity instructions found in `12-Stu_TDD/README.md`.

* Break your students into pairs that will work together on this activity.

  ```md
  # 📖 Write Tests for Algorithms

  Work with a partner to implement the following user story:

  * As a developer, I want to create tests to define the expectations for algorithms that haven't been implemented yet. 

  ## Acceptance Criteria

  * It's done when the "reverse" test expects the string `"Hello World!"` to become `"!dlroW olleH"` after calling `new Algo().reverse()`.

  * It's done when the "isPalindrome" test expects the string `"racecar"` to return `true` and the string `"neon"` to return `false` after calling `new Algo().isPalindrome()`.

  * It's done when the "capitalize" test expects the string `"capitalize every first word of the string."` to become `"Capitalize Every First Word Of The String."` after calling `new Algo().capitalize()`.

  * It's done when the tests fail, because no code should be added to the `algo.js` file to fulfill the tests yet.

  ## 📝 Notes

  Refer to the documentation: 

  [Jest API documentation](https://jestjs.io/docs/en/api)

  ---

  ## 💡 Hints

  * How can we use the `describe`, `it` and `expect` functions in Jest to check for expected behavior?

  ## 🏆 Bonus

  If you have completed this activity, work through the following challenge with your partner to further your knowledge:

  * Where can you find some examples of well written tests? 

  Use [Google](https://www.google.com) or another search engine to research this.
  ```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students who need extra help.

### 4. Instructor Review: Test Driven Development (10 min)

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How comfortable do you feel with TDD? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help!

* Use the prompts and talking points (🔑) below to review the following key points:

  * ✔️ `describe()`

  * ✔️ `.it()`

  * ✔️ `.expect()`

  * ✔️ `.toEqual()`

* Open `12-Stu_TDD/Solved/test/algo.test.js` in your IDE and explain the following: 

  * We first require the file containing the functions we would like to test.

  ```js
  const Algo = require("../algo");
  ```

  * The `describe` function is provided for each of our tests. We see that our tests are wrapped in a parent `describe` function for `Algo`.

  ```js
  describe("Algo", () => {
  ```

  * 🔑  Now we can build tests for specific functionality, starting with `"reverse"`. The `it` method allows us to describe what the function should do in plain english.

  * Next, we define `str` as the starting string and `reversed` as `str` backwords, and `result` as the actual result of the `reverse` function.

   * 🔑 Finally, we pass `result` as an argument into `.expect()` and compare it to the value of `reversed` using the `.toEqual` method. In other words, we expect the value of `result` to equal the value of `reversed`!

  ```js
  describe("reverse", () => {
    it("should reverse a given string", () => {
      const str = "Hello World!";
      const reversed = "!dlroW olleH";

      const result = new Algo().reverse(str);

      expect(result).toEqual(reversed);
    });
  });
  ```

  * In each case, we're checking to see what the method returns given a certain input. We setup the same testing for `isPalindrome` and `capitalize`.
  
  * 🔑 The `describe` statement for `isPalindrome` contains two tests. We needed to use `.it()` twice to test that `isPalindrome` returns true when a string is a Palindrome and false when it isn't.

  ```js
  describe("isPalindrome", () => {
    it("should return true if a string is a palindrome", () => {
      const str = "racecar";

      const result = new Algo().isPalindrome(str);

      expect(result).toEqual(true);
    });

    it("should return false if a string is not a palindrome", () => {
      const str = "neon";

      const result = new Algo().isPalindrome(str);

      expect(result).toEqual(false);
    });
  ```

  * We follow the same format for the test for `capitalize`. Notice again how Jest allows us to write readable tests that are easy to follow.

  ```js
    describe("capitalize", () => {
      it("should take a string and return a new string with the first letter of each word capitalized", () => {
        const str = "capitalize every first word of the string.";
        const capitalized = "Capitalize Every First Word Of The String.";

        const result = new Algo().capitalize(str);

        expect(result).toEqual(capitalized);
      });
    });
  });
  ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ When should we use the `describe` method?

  * 🙋 When we have several related tests that we wish to group together.

  * ☝️ What is the TDD cycle?

  * 🙋 First, we write tests that describes how our code should work. Then we write code, run tests, debug code, and repeat this part of the process until the tests pass.

* Answer any questions before proceeding to the next activity.

### 5. Instructor Demo: Pass Tests (5 min)

* Open `13-Ins_Pass-Tests/tests/fizz.test.js` in your IDE and demonstrate the following:

  * We are importing `fizz.js`, which tells us that the tests in this file should correspond to the code in `fizz.js`.

  * Just like in the previous activity, we have a group of tests bundled in a `describe` method.

  ```js
   const fizzBuzz = require('../fizz');
 
    describe('fizzBuzz', () => {
      ...
    }
  ```

  * The first test indicates that if a number in a given array is not a multiple of three or five, that number will be returned. In order to pass this test, we would need to write code that meets this requirement. 

  ```js
    it('should return the number if not a multiple of three or five', () => {
     expect(fizzBuzz([1])).toBe('1');
     expect(fizzBuzz([1, 2])).toBe('1, 2');
   });
  ```

   * The second and third tests indicate that if a number in a given array is a multiple of three or five, the strings 'fizz' and 'buzz' should be returned respectively.

   * The fourth test indicates that if a number is a factor of BOTH three and five that the string 'FizzBuzz' should be returned.

   * Finally, we can see that all of the tests expect the final result to be returned as a string.

    ```js
  it('should return Fizz if multiple of 3', () => {
    expect(fizzBuzz([3])).toBe('Fizz');
    expect(fizzBuzz([3, 6, 12])).toBe('Fizz, Fizz, Fizz');
  });

  it('should return Buzz if multiple of 5', () => {
    expect(fizzBuzz([10])).toBe('Buzz');
    expect(fizzBuzz([10, 20, 25])).toBe('Buzz, Buzz, Buzz');
  });

   it('should return FizzBuzz if a multiple of both 3 and 5', () => {
    expect(fizzBuzz([15])).toBe('FizzBuzz');
    expect(fizzBuzz([15, 30, 45])).toBe('FizzBuzz, FizzBuzz, FizzBuzz');
  });
  ```

  * 🔑 Now, we need to write the code that will make these tests pass!

* Open `13-Ins_Pass-Tests/fizz.js` in your IDE and demonstrate the following:

  * When we look at the code in `fizz.js`, we see that `fizzBuzz` will map over an array of numbers that is provided as an argument and examine each of them individually using the variable `singleNum`.

  * Next we are checking to see if `singleNum` is divisible by three and 5 and setting the Boolean result as the value of variables called `multipleOf3` and `multipleOf5`. 

  ```js
  num.map((singleNum) => {
      const multipleOf3 = singleNum % 3 === 0;
      const multipleOf5 = singleNum % 5 === 0;
  ```

  * Then, we see a string of `if` statements that use `multipleOf3` and `multipleOf5` as conditions. 

  * 🔑  The first conditional checks to see if the number is divisible by three and five, and will return `fizzBuzz` if the condition is truthy. That passes the fourth test in `fizz.test.js`!

  ```js
    if (multipleOf3 && multipleOf5) {
    return 'FizzBuzz';
  }
  ```

  * 🔑  The second conditional checks to see if the number is divisible by three, and will return `Fizz` if the condition is truthy. That passes the second test in `fizz.test.js`!
  
  ```js
      if (multipleOf3) {
    return 'Fizz';
  }
  ```

  * 🔑  The third conditional checks to see if the number is divisible by three, and will return `Buzz` if the condition is truthy. That passes the third test in `fizz.test.js`!
  
  ```js
      if (multipleOf5) {
    return 'Buzz';
  }
  ```
  * 🔑  If none of the conditions are met, `singleNumber` is returned. That passes the first test in `fizz.test.js`!
  
  ```js
  return singleNumber
  ```

  * 🔑  Remember - our tests expected the results to be returned as a string, but doesn't `.map()` return a new array? That's where `.join()` comes in! 

  ```js
  const fizzBuzz = (num) =>

    num.map((singleNum) => {
      ...
      return singleNum;
    })
    .join(', ');
  ```

* Run `npm install` and  `npm run test` from the command line and demonstrate the following: 

  * As expected, all of our tests are passing.

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How would we build this?

  * 🙋 Use the tests that we have written (or that are provided for us) to help us write working code.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `14-Stu_Pass-Tests/README.md`

### 6. Student Do: Pass Tests (15 min)

* Direct students to the activity instructions found in `14-Stu_Pass-Tests/README.md`.

* Break your students into pairs that will work together on this activity.

```md
# 🏗️ Implement Code to Make Tests Pass

Work with a partner to implement the following user story:

* As a developer, I want to write code that will allow my tests to pass

## Acceptance Criteria

* It's done when I have written code for function in `algo.js`.

* It's done when I can run `npm run test` in the terminal to verify that I correctly implemented each method before moving on.

* It's done when the tests in `tests/algo.test.js` pass.

---

## 💡 Hints

How can we use the tests themselves in `tests/algo.test.js` to give us clues on how to write our function?

## 🏆 Bonus

If you have completed this activity, work through the following challenge with your partner to further your knowledge:

* How are ATDD and BDD similar to and/or different from TDD?
```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students who need extra help.

### 7. Instructor Review: Pass Tests (10 min)

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How comfortable do you feel with writing code in order to get tests to pass thus far? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help!

* Use the prompts and talking points (🔑) below to review the following key points:

  * ✔️ TDD Cycle

  * ✔️ `algo.test.js`

  * ✔️ `npm run test`

* Open `14-Stu_Pass-Tests/Solved/test/algo.test.js` in your IDE and explain the following: 

  * 🔑  We will follow the TDD cycle and look at the tests to figure out what we need to build. 
  
  * 🔑  The first test in `algo.test.js` should look familiar. We need to build a function, `reverse`, that takes in a string as an argument, reverses it, and returns the reversed string.

  ```js
    describe("reverse", () => {
      it("should reverse a given string", () => {
        const str = "Hello World!";
        const reversed = "!dlroW olleH";
        const result = new Algo().reverse(str);
       expect(result).toEqual(reversed);
      });
    });
  ```

* Open `14-Stu_Pass-Tests/Solved/algo.js` in your IDE and explain the following:

  * Inside of the `reverse` function, we write code that returns `str` with a chain of functions attached. First we use `.split("")` to convert `str` into an array of substrings, we then call `.reverse()` to reverse the order of the array, and finally call `.join("")` to convert the array back into a string.

    ```js
    Algo.prototype.reverse = function(str) {
      return str
        .split("")
        .reverse()
        .join("");
    };
    ```

  * Run `npm run test` in the console and demonstrate the following:

    * 🔑  When we run `npm run test`, we see that `reverse` is passing the test. Success!

    ```bash
    Algo
      reverse
        ✓ should reverse a given string (2ms)
    ```
    
* Open `14-Stu_Pass-Tests/Solved/test/algo.test.js` in your IDE and explain the following: 

  * 🔑  Let's repeat the TDD cycle with the second test. `isPalindrome` includes two tests that we need to pass. The first verifies that it `"should return true if a string is a palindrome"` and the second verifies that it `"should return false if a string is not a palindrome"`.

  ```js
  describe("isPalindrome", () => {
    it("should return true if a string is a palindrome", () => {
      const str = "racecar";
      const result = new Algo().isPalindrome(str);
      expect(result).toEqual(true);
    });

    it("should return false if a string is not a palindrome", () => {
      const str = "neon";
      const result = new Algo().isPalindrome(str);
      expect(result).toEqual(false);
    });
  });
  ```

* Open `14-Stu_Pass-Tests/Solved/algo.js` in your IDE and explain the following:

  * Inside of the `isPalindrome` function, we use `reverse` as a helper function to check if `str` is the same when it is reversed...otherwise known as a Palindrome!

    ```js
    Algo.prototype.isPalindrome = function(str) {
      return this.reverse(str) === str;
    };
    ```

  * Run `npm run test` in the console and demonstrate the following:

    * 🔑  When we run `npm run test`, we see that `isPalindrome` is passing both tests. Great job!

    ```
    isPalindrome
      ✓ should return true if a string is a palindrome
      ✓ should return false if a string is not a palindrome
    ```
    
* Open `14-Stu_Pass-Tests/Solved/test/algo.test.js` in your IDE and explain the following: 

  * 🔑  Let's repeat the TDD cycle one last time with the third and final test. `capitalize` includes one test that we need to pass, verifying that it `"should take a string and return a new string with the first letter of each word capitalized"`.

  ```js
   describe("capitalize", () => {
     it("should take a string and return a new string with the first letter of each word capitalized", () => {
       const str = "capitalize every first word of the string.";
       const capitalized = "Capitalize Every First Word Of The String.";
       const result = new Algo().capitalize(str);
      expect(result).toEqual(capitalized);
     });
   });
  ```

* Open `14-Stu_Pass-Tests/Solved/algo.js` in your IDE and explain the following:

  * Inside of the `capitalize` function, we convert the string to an array with `.split()`, then we map over the array and capitalize the first letter of each word. Finally, we convert the array back into a string with `.join()`.

    ```js
    Algo.prototype.capitalize = function(str) {
      return str.split(" ").map(word => {
      return word.substring(0, 1).toUpperCase() + word.substring(1);
      }).join(" ");
    };
    ```

  * Run `npm run test` in the console and demonstrate the following:

    * 🔑  When we run `npm run test`, we see that all of the tests are now passing, including the test `capitalize`. Nailed it!

    ```
    PASS  test/algo.test.js
      Algo
        reverse
          ✓ should reverse a given string (2ms)
        isPalindrome
          ✓ should return true if a string is a palindrome
          ✓ should return false if a string is not a palindrome
        capitalize
          ✓ should take a string and return a new string with the first letter of each word capitalized (1ms)

    Test Suites: 1 passed, 1 total
    Tests:       4 passed, 4 total
    Snapshots:   0 total
    Time:        1.362s
    Ran all test suites.
    ```

  * ☝️ What is the benefit of writing tests before we write our code?

  * 🙋 This helps us ensure that our code will work. Writing tests first also allows for more rapid development because we will not have to manually test our code.

  * ☝️ What can we do if we don't completely understand this?

  * 🙋 We can refer to supplemental material, read the [Jest docs](https://jestjs.io/docs/en/getting-started), and stick around for office hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 8. Instructor Demo: Organizing Tests (5 min)

* Open `15-Ins_Organizing-Tests/test/todo.test.js` in your IDE and demonstrate the following:

* 🔑  When writing tests, it's a good idea to have framework or set of guidelines that can be used for organizing tests and deciding what kinds of things to test for.

* 🔑  The Arrange Act Assert pattern gives us a guide for how to organize test code in a way that makes sense to us and others.

* 🔑  The tests are split into three parts: Arrange, Act, and Assert.

    * **Arrange**: Any kind of set up you need to run your test.

    * **Act**: Perform the action to be tested.

    * **Assert**: Perform the assertion.

  ```js
  it("should create an object with a 'text' property set to the 'text' argument provided when called with the 'new' keyword", () => {
    // Arrange
    const text = "Pick up milk";

    // Act
    const obj = new Todo(text);

    // Assert
    expect(obj.text).toEqual(text);
  });
  ```

* Open `15-Ins_Organizing-Tests/test/todoList.test.js` in your IDE and explain the following:

  * 🔑  When considering what kinds of things to write tests for, it's a good idea to keep in mind positive, negative, and exception tests.

  * 🔑  This file contains a few **positive tests**. We run these tests to make sure things work as intended in likely situations.

  ```js
  it("should add a new 'Todo' object to its 'todos' array", () => {
    // Arrange
    const todoList = new TodoList();
    const todoText = "Mow Lawn";

    // Act
    todoList.addTodo(todoText);

    // Assert
    expect(todoList.todos.length).toEqual(1);
    expect(todoList.todos[0] instanceof Todo).toEqual(true);
    expect(todoList.todos[0].text).toEqual(todoText);
  });
  ```

  * 🔑  This is an example of a **negative test**. We run these tests to check things work in edge cases or cases where the function should return a negative result. 

  ```js
  it("should return undefined if there are no todos", () => {
    // Arrange
    const todoList = new TodoList();
    let nextTodo;

    // Act
    nextTodo = todoList.getNextTodo();

    // Assert
    expect(typeof nextTodo).toEqual("undefined");
  });
  ```

  * 🔑  This is an example of an **exception test**. We run these tests to make sure than our code throws errors if/when it should.

  ```js
  it("should throw an error if not provided text", () => {
    // Arrange
    const todoList = new TodoList();
    const err = new Error(
      "Expected parameter 'text' to be a non empty string"
    );
    const cb = () => todoList.addTodo();

    // Assert
    expect(cb).toThrowError(err);
  });
  ```

  * Not every function will have all three (positive, negative, and exception tests), but keeping them in mind can help us decide what kinds of things we should be testing for.


* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How would we build this?

  * 🙋 We could use the Arrange Act Assert pattern as a guide for how to organize test code in a way that makes sense to us and others.

  * ☝️ How do we know what to test for?

  * 🙋 When considering what kinds of things to write tests for, it's a good idea to keep in mind positive, negative, and exception tests.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `16-Stu_organizing-Tests/README.md`.

### 9. Student Do: Organizing Tests (15 min)

* Direct students to the activity instructions found in `16-Stu_Organizing-Tests/README.md`.

* Break your students into pairs that will work together on this activity.

  ```md
  # 📐 Add Comments to Implementation of an Arrange Act Assert Pattern

  Work with a partner to add comments describing the functionality of the code found in [Unsolved/test](./Unsolved/test).

  ---

  ## 🏆 Bonus

  If you have completed this activity, work through the following challenge with your partner to further your knowledge:

  * How can you write these tests to ensure that another developer testing your code can understand what the tests are checking? 

  Use [Google](https://www.google.com) or another search engine to research this.
  ```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students who need extra help.

### 10. BREAK (15 min)

### 11. Instructor Review: Organizing Tests (10 min) 

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How comfortable do you feel with structuring your tests? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help!

* Use the prompts and talking points (🔑) below to review the following key points:

  * ✔️ Arrange Act Assert pattern

  * ✔️ Positive, negative, and exception tests 

  * ✔️ `it(should ...)`

* Open `16-Stu_Organizing-Tests/Solved/test/dayCare.test.js` in your IDE and explain the following: 

  * 🔑 By using the Arrange Act Assert pattern, we can organize our tests into three easy to understand parts.

  ```js
  it("should add a child to the 'children' array", () => {
    // arrange
    const child = new Child("Tammy", 1);
    const dayCare = new DayCare();

    // act
    dayCare.addChild(child);

    // assert
    expect(dayCare.children.length).toEqual(1);
    expect(dayCare.children[0]).toBe(child);
  });
  ```

  * 🔑 We use the `toThrowError` or `toThrow` matcher to check that an error was thrown. We wrap the code that will throw the error in a callback function so Jest will suppress the error.

  ```js
  it("should throw an error if not provided a Child object as an argument", () => {
    const err = new Error(
      "Expected parameter 'child' to be an instance of Child"
    );
    const cb = () => {
      const dayCare = new DayCare();
      dayCare.addChild();
    };

    expect(cb).toThrowError(err);
  });
  ```

  * 🔑 We use negative tests to make sure things work as expected in edge cases.

  ```js
  it("should not add a child if already at capacity", () => {
    const dayCare = new DayCare();
    const child = new Child("Alice", 4);
    dayCare.children = [
      new Child("Tammy", 1),
      new Child("Mark", 2),
      new Child("Alvin", 1)
    ];

    dayCare.addChild(child);

    expect(dayCare.children.length).toEqual(3);
  });
  ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ Why is it helpful for a function to intentionally throw an error?

  * 🙋 If we throw a helpful error message when a function is being misused, the issue is easier to track down than if we didn't throw the error and the misuse caused another unexpected error somewhere else in the code.

* Answer any questions before proceeding to the next activity.

### 12. Instructor Demo: Mocks (5 min)

* Open `17-Ins_Introduce_mocks/logger.js` in your IDE and demonstrate the following:

  * Run `node index` from the command line and demonstrate the following: 

    * 🔑 We see that when we run the index file, our output is using colors for each line of output.

    * In order to print different colors to the console, there are special codes for each color that must be included as a first argument to the `console.log` method.

    ```js
    function Logger() {
      if (!this.init) {
        Logger.prototype.init = true;
        const colors = {
          black: "\x1b[30m",
          red: "\x1b[31m",
          green: "\x1b[32m",
          yellow: "\x1b[33m",
          blue: "\x1b[34m",
          magenta: "\x1b[35m",
          cyan: "\x1b[36m",
          white: "\x1b[37m"
        };
    ```

    * Rather than manually write out a method for each color, we're using a loop that runs only once the first time a `Logger` object is created with the constructor. This is called the "dynamic prototype pattern".

    ```js
    for (let key in colors) {
      Logger.prototype[key] = function(...args) {
        console.log(colors[key], ...args);
      };
    }
    ```

* Open `17-Ins_Introduce-Mocks/index.js` to point out the following:

  * We first import a `Logger` constructor that creates an object capable of logging to the console in different colors. When we run the application in the command line window we can see the dynamic output.

  ```js
  const Logger = require("./logger");

  const log = new Logger();

  log.red("We can write to the console in different colors!");

  log.blue("We just need to provide an additional argument to the console.log method!");

  log.magenta("The first argument console.log needs is an 'ANSI Escape Code'");

  log.green("You can look these up at https://en.wikipedia.org/wiki/ANSI_escape_code#Colors");

  log.yellow("But they're just codes that represent different colors");

  log.cyan("The second argument console.log should receive is the message to be printed");
  ```

* Open `17-Ins_Introduce-Mocks/test/logger.test.js` file in your IDE and point out the following key points:

  * 🔑 In this file we're using the `jest.spyOn` method to mock and spy on the `console.log` method. We're also using the `mock.mockImplementation` method to replace `console.log`'s functionality with an empty function that does nothing.

  ```js
  it("should print in black", () => {
    const log = new Logger();
    const message = "Hello world!";
    const mock = jest.spyOn(console, "log");
    mock.mockImplementation(() => {});

    log.black(message);

    expect(mock).toBeCalledWith(colors.black, message);

    mock.mockRestore();
  });
  ```

  * 🔑 Since we're mocking the `console.log` method nothing will be printed to the console when the test is run, and we're able to spy on values provided to the `console.log` method. When `log.black` is called, we can verify that `console.log` was also called with the expected message and color.

* Finally, run `npm install` and `npm run test` to show the console log output from the tests.

* Ask the class the following questions (☝️) and call on students for the answers (🙋):
  
  * ☝️ Why might it be complicated to test something like a fetch request being called? Or writing to the filesystem?

  * 🙋 The results of a fetch request rely on something outside of our code that we can't always control. Reading and writing to the filesystem can be complicated because our tests may make changes that can impact the results of future tests

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `18-Stu_First-Mock`.

### 13. Student Do: Mocks (15 min)

* Direct students to the activity instructions found in `18-Stu_First-Mock`.

* Break your students into pairs that will work together on this activity.

```md
# 🐛 Running `npm run test` Results in Errors.

Work with a partner to resolve the following issue(s):

* As a developer, I would like to spy on the output of the `console.log` method in `dayCare.test.js`.

## Expected Behavior

* When we run `npm run test` in the console, we should not receive an error

* When we run `npm run test` in the console, the Tests and Test Suites for `dayCare.test.js` should be passing

## Actual Behavior

* When we run `npm run test` in the console, we receive the following error: "Cannot spyOn on a primitive value; undefined given"

* When we run `npm run test` in the console, the Tests and Test Suites for `dayCare.test.js` are not passing

## Steps to Reproduce the Problem

1. Navigate to the `Unsolved` folder in this activity.

2. Run `npm install` in your console.

3. Run `npm run test` in your console.

## Assets

The following image demonstrates the web application's appearance and functionality:

![Tests and Test Suites are passing, no messages are logged in the console, and there are no errors](./images/pass-test.png)

---

## 💡 Hints

* What does the error tell you about what is missing?

* How do we capture the value of `console.log`?

## 🏆 Bonus

If you have completed this activity, work through the following challenge with your partner to further your knowledge:

* Use the [Jest Docs](https://jestjs.io/docs/en/jest-object#jestspyonobject-methodname) to explain two or three other methods that can be used in conjunction with `.spyOn`.

Use [Google](https://www.google.com) or another search engine to research this.

```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students who need extra help.

### 14. Instructor Review: Mocks (10 min)

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How comfortable do you feel with using the spy on methods? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help!

* Use the prompts and talking points (🔑) below to review the following key points:

  * ✔️ `jest.spyOn()`

  * ✔️ `mock.mockImplementation()`

* Open `18-Stu_First-Mock/Solved/test/dayCare.test.js` in your IDE and explain the following: 

  * 🔑 We use `jest.spyOn()` and pass in the arguments, `console` and `"log"` to spy on the `console.log` method. 
  
  * 🔑 We pass in an empty function to `mock.mockImplementation()` in order to replace the functionality of the `console.log` method.

  * Now, we can use `expect(mock).toBeCalledWith()` to verify that it was called with the arguments we expect.

  ```js
  const mock = jest.spyOn(console, "log");
  mock.mockImplementation(() => {});

  dayCare.addChild(child);

  expect(dayCare.children.length).toEqual(0);
  expect(mock).toBeCalledWith(
    "Unable to add child, they are over the age limit"
  );
  ```

  * We can "unmock" `console.log` by using the `mock.mockRestore` method. It's a good idea to clean up any mocks we run at the end of a test to ensure the next test isn't affected.

  ```js
  mock.mockRestore();
  ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ What can mocks be used for? 

  * 🙋 Mocks can be used to replace code with side-effects, such as printing to the console, making fetch requests, writing/writing to the filesystem so it doesn't happen when tests are being run.

  * ☝️ What can we do if we don't completely understand this?

  * 🙋 We can refer to supplemental material, read the [Jest Docs](https://jestjs.io/docs/en/jest-object#jestspyonobject-methodname), and stick around for office hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 15. Instructor Demo: Mock fs (5 min)

* Open `19-Ins_Module-Mock-Demo/movieSearch.js` in your IDE and demonstrate the following:

  * 🔑 This file exports a `MovieSearch` constructor that can be used to create an object used for searching the OMDB API.

  ```js
  const axios = require("axios");

  function MovieSearch() {}

  MovieSearch.prototype.buildUrl = function(movie) {
    return `https://www.omdbapi.com/?t=${movie}&apikey=trilogy`;
  };

  MovieSearch.prototype.search = function(movie) {
    return axios.get(this.buildUrl(movie));
  };
  ```

* Open `19-Ins_Module-Mock-Demo/test/movieSearch.test.js` in your IDE and demonstrate the following:

  * 🔑 We require axios and mock it, since we want to prevent actual AJAX requests from happening. This is one way of mocking a node module.

  ```js
  const axios = require("axios");
  const MovieSearch = require("../movieSearch");

  jest.mock("axios");
  ```

  * 🔑 We mock the return value of `axios.get` to be a new Promise object that resolves to an object that contains a `data` property that's set to an empty object. We're mocking the return value to this because it's similar to what we would get from the response from the OMDB API.

  ```js
  it("should search the OMDB API for a given movie", () => {
    const movie = new MovieSearch();
    const name = "Rocky";

    axios.get.mockReturnValue(
      new Promise(function(resolve) {
        resolve({ data: {} });
      })
    );

    expect(movie.search(name)).resolves.toEqual({ data: {} });
    expect(axios.get).lastCalledWith(movie.buildUrl(name));
  });
  ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How would we build this?

  * 🙋 We would first test out our API call to OMDB in something like Insomnia to ensure we understand what our mock should return and how to behave. Then we would import the package we need and wrap it using the `jest.mock()` method. We would then mock the return value of a promise by using `mockReturnValue()`.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `20-Stu_Mock-Fs/README.md`.

### 16. Student Do: Mock fs (15 min)

* Direct students to the activity instructions found in `20-Stu_Mock-Fs/README.md`.

* Break your students into pairs that will work together on this activity.

```md
# 🏗️ Mock and Spy on `fs` Module

Work with a partner to implement the following user story:

* As a developer, I want to be able to write code to mock and spy on the `fs` module to ensure it's called when expected with the correct arguments.

## Acceptance Criteria

* It's done when I have opened the `Unsolved/fileIO.js` file and understand it's contents.

  * It's done when I understand that this exports a `FileIO` constructor function with methods for reading and writing to the filesystem.

  * It's done when I understand that the `read` and `write` methods use the synchronous versions of `fs.readFile` and `fs.writeFile` and that no callback is required.

* It's done when I have opened `Unsolved/tests/fileIO/test.js` and added code to mock the `fs` module and it's `readFileSync` and `writeFileSync` methods so that they don't read from and write to the filesystem.

## 💡 Hints

How can we use the previous demonstration to aid in mocking node modules?

## 🏆 Bonus

If you have completed this activity, work through the following challenge with your partner to further your knowledge:

* How can we further our understanding by writing tests for a `FileIO.prototype.append` method that should append to a given file. How could we update the `Unsolved/fileIO.js` file to include this method using the `fs.appendFileSync` method?

Use [Google](https://www.google.com) or another search engine to research this.

---
2020 Trilogy Education Services, LLC, a 2U, Inc. brand. Confidential and Proprietary. All Rights Reserved.
```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students who need extra help.

### 17. Instructor Review: Mock fs (15 min)

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How comfortable do you feel with mocking and spying on modules? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help!

* Use the prompts and talking points (🔑) below to review the following key points:

  * ✔️ Mocking node modules

  * ✔️ Avoiding touching the file system

* Open `20-Stu_Mock-Fs/Solved/test/fileIO.test.js` file in your editor and point out the following key points:

  * 🔑 We mock the `fs` module by requiring it and using the `jest.mock` method at the top of the file.

  ```js
  const fs = require("fs");
  const FileIO = require("../fileIO");

  jest.mock("fs");
  ```

  * 🔑 Since `fileIO.read` returns the result of `fs.readFileSync`, we can mock it's return value and verify it was called with the expected arguments without actually making a trip to the filesystem.

  ```js
  it("should call fs.readFileSync with the passed in 'file' argument", () => {
    const fileIO = new FileIO();
    const file = "message.txt";
    let data;

    fs.readFileSync.mockReturnValue("Hello World!");
    data = fileIO.read(file);

    expect(data).toEqual("Hello World!");
    expect(fs.readFileSync).lastCalledWith(file, "utf8");
  });
  ```

  * 🔑 When testing the `fileIO.write` method, we just need to know that the `fs.writeFileSync` method was called with the correct arguments. We aren't testing that the `fs` module works, only that it's being utilized as expected.

  ```js
  it("should call fs.writeFileSync with the passed in 'path' and 'data' arguments", () => {
    const fileIO = new FileIO();
    const path = "message.txt";
    const data = "Hello World!";
  
    fileIO.write(path, data);

    expect(fs.writeFileSync).lastCalledWith(path, data);
  });
  ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ What sort of complications can we avoid by mocking the fs module?

  * 🙋 We can avoid requiring our tests to read and write to the filesystem. Not only would this slow down tests, but it could influence how the next test runs.

  * ☝️ What can we do if we don't completely understand this?

  * 🙋 We can refer to supplemental material, read the [Jest Docs](https://jestjs.io/docs/en/jest-object#jestspyonobject-methodname), and stick around for office hours to ask for help.

* Answer any questions before ending the class.

### 18. END (0 min)

How did today’s lesson go? Your feedback is important. Please take 5 minutes to complete this [anonymous survey](https://forms.gle/RfcVyXiMmZQut6aJ6).

---
2020 Trilogy Education Services, LLC, a 2U, Inc. brand. Confidential and Proprietary. All Rights Reserved.
