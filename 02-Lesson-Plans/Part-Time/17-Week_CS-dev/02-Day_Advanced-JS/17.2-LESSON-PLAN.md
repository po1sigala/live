# 17.2 Part-Time Lesson Plan: Computer Science For JavaScript

## Overview 

In today's class, students will be taking a dive deep into what JavaScript does under the hood. Students will get to see how Higher order functions work and how we can implement them into our code. Next, students will get to see the fascinating behavior of closures. Along with learning about closures, they will learn how to leverage them with factory functions. Students will learn about the difference between inheritance and a composition based approach when designing an application. Finally, students will learn a new way to delegate events using closures.

## Instructor Notes

* In this lesson, students will complete activities `11-Ins_Higher-Order-Functions` through `20-Stu_Event-Delegation-Handling`.

* This section deals with a few abstract topics, it's important to keep discussion and dialog open so students can better grasp these topics.

* Closure are a huge chunk of the day's activities. If you are feeling a little unsure about them, take a moment to get more familiar with them.

* In `13-Ins_Closures` we use `console.dir`, students do not need to learn about it. We are using it for a visual demonstration only.

* We will be using jest in a couple of the activities so make sure students use `npm run test` when prompted.

* Remind students to do a `git pull` of the class repo to have today's activities ready and open in VS Code. 

* If you are comfortable doing so, live-code the solutions to the activities. If not, just use the solutions provided and follow the prompts and talking points for review.

* Let students know that the Bonus at the end of each activity is not meant to be extra coding practice, but instead is a self-study on topics beyond the scope of this unit for those who want to further their knowledge.

## Learning Objectives

By the end of class, students will be able to:

* Construct their own higher order functions.

* Explain the lexical environment.

* Identify encapsulated variables.

* Create a factory function.

* Distinguish the difference between inheritance and composition design.

## Time Tracker
@TODO ADD ACTIVITY TITLES for Instructor Demo, Student Do, and Instructor Review
| Start  | #   | Activity Name                                        | Duration |
|---     |---  |---                                                   |---       |
| 6:30PM | 1   | Instructor Do: Stoke Curiosity                       | 0:10     |
| 6:40PM | 2   | Instructor Demo: Higher Order Functions              | 0:05     |
| 6:45PM | 3   | Student Do: Higher Order Functions                   | 0:15     |
| 7:00PM | 4   | Instructor Review: Higher Order Functions            | 0:10     |
| 7:10PM | 5   | Instructor Demo: Closures                            | 0:05     |
| 7:15PM | 6   | Student Do: Closures                                 | 0:15     |
| 7:30PM | 7   | Instructor Review: Closures                          | 0:10     |
| 7:40PM | 8   | Instructor Demo: Factory Functions                   | 0:05     |
| 7:45PM | 9   | Student Do: Factory Functions                        | 0:15     |
| 8:00PM | 10  | BREAK                                                | 0:15     |
| 8:15PM | 11  | Instructor Review: Factory Functions                 | 0:10     |
| 8:25PM | 12  | Instructor Demo: Constructor vs Factory functions    | 0:05     |
| 8:30PM | 13  | Student Do: Constructor vs Factory Functions         | 0:15     |
| 8:45PM | 14  | Instructor Review: Constructor vs Factory Functions  | 0:10     |
| 8:55PM | 15  | Instructor Demo: Event Delegation / handling         | 0:05     |
| 9:00PM | 16  | Student Do: Event Delegation / handling              | 0:15     |
| 9:15PM | 17  | Instructor Review: Event Delegation / Handling       | 0:15     |
| 9:30PM | 18  | END                                                  | 0:00     |

---

## Class Instruction

### 1. Instructor Do: Stoke Curiosity (10 min)

* Welcome students to class.

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝ How many programming paradigms does JavaScript have?
  
  * 🙋 Three!

* Explain that we will be learning about the techinical portion of the interview process. With a focus on the functional paradigm of JavaScript.

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ What is another alternative to using classes in JavaScript?

  * 🙋 Factory Functions.

* Reasure the students that these topics can get abstract and be sure to ask questions.

* JavaScript has many layers and interviewers want to know how well a caniditate understands them. 

* In JavaScript we have choice to make early on that will dictate how we design our application.

* It is important that a developer can recogonize the difference in these design patterns.

* Let students know this knowledge comes with time and practice and not to fall into that sinking feeling of imposter syndrome.

* They have been using these concepts all along and now we are just expanding on that knowledge.

### 2. Instructor Demo: Higher Order Functions (5 min) 

* Open `11-Ins_Higher-Order-Functions/index.js` in your IDE and explain the following:

  * 🔑 We first create a function that we will be using to pass into the JavaScript provided higher order function, `.map()`.

  * We have access to the element and the index of the element which is provided to us through the `.map()` method.

    ```js
     // Create a function which accepts two arguments, number and index.
    // The index of the array is provided to us because we will pass this function through .map array method.
    function evenIndexMultiplier(number, index) {
    ```
  
  * 🔑 Next, we create the logic for our function that will be passed into our higher order function, the `.map()` method.

    ```js
    function evenIndexMultiplier(number, index) {
      // Checking to see if we are on an even index inside of the array we are mapping through.
      if (index % 2 === 0) {
      // Multiply the number on the even index by 10.
      return number * 10;

      }

      // Return the number if it is on an odd index.
      return number;
      }
    ```

  * 🔑 Finally, we pass our newly created function into the `.map()` method and storing it into a variable named `evenIndexes`.
  
  * 🔑 Now we have a function which accepts another function as an argrument, creating a higher order function.

  * 🔑 We are not limited to only using `evenIndexMultiplier` inside the `.map()` method. We can use `evenIndexMultiplier` anywhere in our application or even in a custom higher order function.
    ```js
    // Create a new variable to store our newly mapped array with our `evenIndexMultiplier` function passed through it.
    const evenIndexes = arrayIndex.map(evenIndexMultiplier);

    ```

* Run `11-Ins_Higher-Order-Functions/index.js` from the command line and demonstrate the following: 

  * 🔑 As we can see every even index is being multiplied by ten which is exactly what our function was meant to do.

    ```
    [10, 52, 350, 6, 720, 7, 30, 19, 320, 54, 780, 95, 970]
    ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How can we use higher order functions to our benefit?

  * 🙋 It makes our code more reusable.

  * ☝️ Do we have to use a JavaScript provided higher order function?

  * 🙋 No, we can create our own. The function just needs to be able to accept another function for an argument.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `12-Stu_Higher-Order-Functions/README.md`.

### 3. Student Do: Higher Order Functions (15 min) 

* Direct students to the activity instructions found in `12-Stu_Higher-Order-Functions/README.md`.

* Break your students into pairs that will work together on this activity.

```md
# 🏗️ Create a function to pass into the reducer method that finds the average of an array of numbers

Work with a partner to implement the following user story:

* As a teacher, I want to be able to find the average grade of my entire class.

* As a developer, I want to be able to reuse my `findAverage` function in multiple filter method calls throughout my application so that my code is not being duplicated unnecessarily.

## Acceptance Criteria

* It's done when the `findAverage` function correctly calculates the average of an array of numbers.

* It's done when the `findAverage` function is being correctly passed through the reduce method.

## 💡 Hints

How do you find out how many elements are in an array? 

## 🏆 Bonus

If you have completed this activity, work through the following challenge with your partner to further your knowledge:

* What other built-in functions are also higher order functions? 

Use [Google](https://www.google.com) or another search engine to research this.

---
© 2020 Trilogy Education Services, LLC, a 2U, Inc. brand. Confidential and Proprietary. All Rights Reserved.
```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students who need extra help.

### 4. Instructor Review: Higher Order Functions (10 min) 

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How comfortable do you feel with `higher order functions`? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help!

* Use the prompts and talking points (🔑) below to review the following key points:

  * ✔️ Accepting another function as an argument.

  * ✔️ `.reduce()`

* Open `12-Stu_Higher-Order-Functions/Solved/index.js` in your IDE and explain the following: 

  * We create a function named `findAverage` that has access to four arguements `accumulator`, `currentValue`, `index`, and `array`.

  * 🔑 We have access to these arguments because they are provided to us through the `.reduce()` method.

    ```js
    function findAverage(accumulator, currentValue, index, array) {
    ```

  * Check to see if we are at the final index of the given array.

  * If so, we return our total plus the current value and divide it by how many elements are in the array. 
  
    ```js
    function findAverage(accumulator, currentValue, index, array) {
      // Check to see if we are at the end of the given array.
      if (index === array.length - 1) {
      // Once we have reached the end of the array we divide by how many elements are in the given array.
      return (accumulator + currentValue) / array.length;
    }
    }
    ```
    
  * If we have not reached the end of the array, add the total to the current value we are on. 
  
    ```js
    function findAverage(accumulator, currentValue, index, array) {
      // Check to see if we are at the end of the given array.
      if (index === array.length - 1) {
      // Once we have reached the end of the array we divide by how many elements are in the given array.
      return (accumulator + currentValue) / array.length;
    }

    // Add the current value to our total.
    return accumulator + currentValue;
    }
    ```
  
  * 🔑 Pass our newly created `findAverage` function into the `.reduce()` method.

    ```js
    // Pass the 'findAverage' function into the reduce method.
    let gradeAverage = grades.reduce(findAverage);
    ```

* Run `12-Stu_Higher-Order-Functions/Solved/index.js` from the command line and demonstrate the following:

  * 🔑 Inside of the `console` we should see the correct average being displayed.

      ```
      [79.5]
      ```

    

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ What are some other JavaScript methods that are higher order functions?

  * 🙋 `.filter()` `forEach()`

  * ☝️ What can we do if we don't completely understand this?

  * 🙋 We can refer to supplemental material, read the [MDN Web Docs on Functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions), and stick around for office hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 5. Instructor Demo: Closures (5 min) 

* Open `13-Ins_Closures/index.js` in your IDE and demonstrate the following:

  * 🔑 First we will be creating a function named `bankAccount` which will be the outer function that holds our inner function.

  * 🔑 Closures are created every time a function is created.

    ```js
    function bankAccount() {
      // Code...
    }
    ```

  * 🔑 Now we create two variables inside of our outer function which will be scoped to the inner function we will be creating.

    ```js
    function bankAccount() {
      // Create two variables inside of the outer function.
      // We will be accessing the two variables inside of our inner function.
      const checking = 400;
      const savings = 1000;
    }
    ```
  
  * 🔑 In order to use a closure we need to return an inner function.
    ```js
    function bankAccount() {
      // Create two variables inside of the outer function.
      // We will be accessing the two variables inside of our inner function.
      const checking = 400;
      const savings = 1000;

      return {
        displayFunds: function () {
        
        },
      };
    }
    ```

  * 🔑 Inside of the newly created `displayFunds` function we are going to `console.log` our outer functions variables.
    ```js
    function bankAccount() {
      // Create two variables inside of the outer function.
      // We will be accessing the two variables inside of our inner function.
      const checking = 400;
      const savings = 1000;

      return {
        displayFunds: function () {
          console.log(
            `You have $${checking} in your checking account and $${savings} in your savings account`
          );
        },
      };
    }
    ```

  *  Let's store our `bankAccount` function inside of a variable and test what happens when we call our `displayFunds()` function.

    ```js
    const myBank = bankAccount();

    myBank.displayFunds()
    ```

* Run `13-Ins_Closures/index.js` from the command line and demonstrate the following:
  
  * 🔑 In the console we can see that our inner function has access to our outer functions scope.

  * 🔑 In other words, the `displayFunds()` function has access to the `bankAccount()` function's lexical environment.

    ```
    You have $400 in your checking account and $1000 in your savings account
    ```

  * The next statement we will see is from `console.dir`. Feel free to look up what `console.dir` does but we are only using it for demonstration purposes.

    ```js
    console.dir(myBank)
    ```

  * 🔑 By doing this we can inspect the scope of our `displayFunds()` function and see that it does have a closure with a reference to the two variables in the outer functions lexical environment.

  * Something else that is interesting, is our function is also an object.
    ```
    Object
      displayFunds: ƒ ()
        arguments: null
        caller: null
        length: 0
        name: "displayFunds"
        prototype: {constructor: ƒ}
        __proto__: ƒ ()
        [[FunctionLocation]]: Closures.js:24
        [[Scopes]]: Scopes[3]
          0: Closure (bankAccount)
            checking: 400
            savings: 1000
          1: Script {myBank: {…}}
          2: Global {window: Window, self: Window, document: document, name: "", location: Location, …}
      __proto__: Object
    ```

  * 🔑 For the final two statements, we can see that the variable inside of the `bankAccount()` function are not accessible from outside the functions lexical environment.

    ```
    undefined
    undefined
    ``` 


* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ When is a closure created?

  * 🙋Every time a function is created.

  * ☝️ How do we use a closure?

  * 🙋 Returning an inner function which has access to the outer function's lexical environment.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `14-Stu_Closures/README.md`.

### 6. Student Do: Closures (15 min) 

* Direct students to the activity instructions found in `14-Stu_Closures/README.md`.

* Break your students into pairs that will work together on this activity.

```md
# 🏗️ Create a counter function that uses a private variable

Work with a partner to implement the following user story:

* As a teacher, I want a way to keep track of the number of students I see every day.

* As a developer, I want to keep my  `count` variable data private.

## Acceptance Criteria

* It's done when the `Counter` function correctly increments by one.

* It's done when I can only access the `count` variable from within the `Counter` function.

* It's done when all of the unit tests pass with `npm run test`.

## 💡 Hints

When is a closure created? 

## 🏆 Bonus

If you have completed this activity, work through the following challenge with your partner to further your knowledge:

* What is the lexical environment? 

Use [Google](https://www.google.com) or another search engine to research this.

---
© 2020 Trilogy Education Services, LLC, a 2U, Inc. brand. Confidential and Proprietary. All Rights Reserved.
```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students who need extra help.

### 7. Instructor Review: Closures (10 min) 

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How comfortable do you feel with `Closures`? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help!

* Use the prompts and talking points (🔑) below to review the following key points:

  * ✔️ Closures

  * ✔️ Private variables

  * ✔️ Lexical evironment

* Open `14-Stu_Closures/Solved/index.js` in your IDE and explain the following: 

  * 🔑 By creating the function `counter`, we have also created a closure.

    ```js
    function counter() {
      // Code...
    }
    ```
 
  * 🔑 Inside of our outer function we create a `count` variable which will hold how many times our function is called.

  * 🔑 The `count` variable is only accessible from inside the `counter` function.

    ```js
    function counter() {
      // Create a 'count' variable inside of the outer function.
      let count = 0;
    }
    ```

  * 🔑 Next, we utilize the closure by returning an inner function named `increment`.

  * 🔑 This newly created function will add one to the outer function's `count` variable.

    ```js
    function counter() {
      // Create a 'count' variable inside of the outer function.
      let count = 0;

      return {
        increment: function () {
          // Increment the outer function's 'count' variable by one.
          return count++;
        },
      };
    }
    ```

  * 🔑 If we type `npm run test` in the command line we should see:

    ```
      PASS  __tests__/index.test.js
      √ counter is a defined function (2 ms)
      √ counter is returning as an object
      √ count should equal 0 (1 ms)
      √ count should equal 1
      √ count should equal 4

    Test Suites: 1 passed, 1 total
    Tests:       5 passed, 5 total
    Snapshots:   0 total
    Time:        1.974 s
    ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How else could we use closures?

  * 🙋 We could conceal sensitive variables that shouldn't be mutated outside of its function's scope.

  * ☝️ What can we do if we don't completely understand this?

  * 🙋 We can refer to supplemental material, read the [MDN Web Docs on Closures](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures), and stick around for office hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 8. Instructor Demo: Factory Functions (5 min) 

* Open `15-Ins_Factory-Functions/index.js` in your IDE and demonstrate the following:

  * 🔑 We are going to create a function that accepts three arguments, `name`, `age`, and `city`.

    ```js
    function createUser(name, age, city) {
      // Code...
    }
    ```

  * 🔑 Factory functions are similar to JavaScript classes.

  * 🔑 Instead of using a `constructor()` and binding our arguments to `this`, We create an object inside of our function that holds our arguments.

  * 🔑 Since we don't have a `constructor()` function, `this` refers to the parent object.

    ```js
    function createUser(name, age, city) {
      let user = {
        name: name,
        age: age,
        city: city
      }
    }
    ```

  * 🔑 Factory functions use closures to encapsulate its variables, making it difficult to mutate the data from outside of its function scope.

  * 🔑 For us to leverage closures we need to return a function(s). We return two, `introduceSelf()` and `location()`.

    ```js
    function createUser(name, age, city) {
      let user = {
        name: name,
        age: age,
        city: city
      }

        return {
          introduceSelf: function() {
              // Code...
          },

          location: function() {
              // Code...
          }
      }
    }
    ```

  * 🔑 Inside both of our newly created functions we return `console.log` statements using template literals.

  * 🔑 Instead of using the `this` keyword we use the object we created which holds all of our data.

    ```js
    function createUser(name, age, city) {
      let user = {
        name: name,
        age: age,
        city: city
      }

        return {
          introduceSelf: function() {
             // Instead of using the `this` keyword, we use the object we created in the outer function's scope.
            return console.log(`Hi my name is ${user.name} and I am currently ${user.age} years old!`)
          },

          location: function() {
            return console.log(`${user.name} is located in ${user.city}`)
          }
      }
    }
    ```

  * 🔑 Now we are going to use our `createUser` factory function.

  * 🔑 Similar to JavaScript classes but we no longer need the `new`.

    ```js
    // Create a user without using the `new` keyword different from how we do it with classes.
    const userOne = createUser('Beverly', 58, 'Phoenix')
    ```

* Run `15-Ins_Factory-Functions/index.js` from the command line and demonstrate the following:
  
  * 🔑 As we can see the new user we created works as expected, without using a JavaScript class.

  * 🔑 The new user has a reference to our `createUser` function which has the data we want encapsulated in it.

  * All this is done with closures.

    ```
    Hi my name is Beverly and I am currently 58 years old!
    Beverly is located in Phoenix
    ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ Inside of a factory function what does `this` refer too?

  * 🙋 The parent object.

  * ☝️ Do we need to use the `new` keyword with factory functions?

  * 🙋 No, we can forgo it entirely. 

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `16-Stu_Factory-Functions/README.md`.

### 9. Student Do: Factory Functions (15 min) 

* Direct students to the activity instructions found in `16-Stu_Factory-Functions/README.md`.

* Break your students into pairs that will work together on this activity.

  ```md
  # 🐛 Factory function is returning undefined values when the inner function is called

  Work with a partner to resolve the following issue(s):

  * As a developer, I want the inner function of my factory function to correctly log the variables when called.

  ## Expected Behavior

  When a user calls the `greet` method on the `Student` function, the values should be correctly displayed in the console.

  ## Actual Behavior

  When a user calls the `greet` method on the `Student` function, they see undefined values instead of the `name` and `gradeYear`.
  
  ## Steps to Reproduce the Problem

  1. Create a new student variable and assign it to the `Student` function. 

  2. Call the `greet` method on the newly created student variable.

  3. Check console to see undefined values.

  4. Run `npm run test` to check if all unit test pass.

  ## 💡 Hints

  What is the context of `this` when inside of a factory function? 

  ## 🏆 Bonus

  If you have completed this activity, work through the following challenge with your partner to further your knowledge:

  * Is the `new` keyword required when using a factory function? 

  Use [Google](https://www.google.com) or another search engine to research this.

  ---
  © 2020 Trilogy Education Services, LLC, a 2U, Inc. brand. Confidential and Proprietary. All Rights Reserved.

  ```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students who need extra help.

### 10. BREAK (15 min)

### 11. Instructor Review: Factory Functions (10 min) 

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How comfortable do you feel with `factory functions`? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help!

* Use the prompts and talking points (🔑) below to review the following key points:

  * ✔️ Factory functions

  * ✔️ `new`

  * ✔️ `this`

* Open `16-Stu_Factory-Functions/Solved/index.js` in your IDE and explain the following: 

  * 🔑 We create a new function and store its two arguments`name` and `gradeYear` inside of a newly created object named `student`.

    ```js
    function Student(name, gradeYear) {
      // Store the function's argruments as an object named `student`.
      let student = {
        name: name,
        gradeYear: gradeYear,
      };
    ```

  * 🔑 Remember, we don't use a `constructor` function so `this` is bound to the parent object.

  * 🔑 If we want to access the `name` and `gradeYear` we must use the student object we stored it in.

    ```js
    function Student(name, gradeYear) {
      // Store the function's argruments as an object named `student`.
      let student = {
        name: name,
        gradeYear: gradeYear,
      };

      return {
        // Return an inner function which has access to the outer function's scope.
        greet: function () {
          console.log(
            // Access the students name and grade year using dot notation.
            `My name is ${student.name} and I am in ${student.gradeYear} grade`
          );
        },
      };
    }
    ```

  * 🔑 Now, we create a new student with our `Student` factory function.

  * 🔑 No need to use the `new` keyword when using factory functions.

      ```js
      // Create a new student passing a name and grade year as arguments.
      const newStudent = Student('Dominique', '11th');
      ```
    
  * 🔑 If we type `npm run test` in the command line we should see:

    ```
      Test Suites: 1 passed, 1 total
      Tests:       4 passed, 4 total
      Snapshots:   0 total
      Time:        1.924 s
    ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ Do we use a `constructor()` function inside of a factory function?

  * 🙋 No.

  * ☝️ What can we do if we don't completely understand this?

  * 🙋 We can refer to supplemental material, read the [MDN Web Docs on Closures](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures), and stick around for office hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 12. Instructor Demo: Factory VS Constructor (5 min) 

* Open `17-Ins_Factory-Vs-Constructor/constructor.js` in your IDE and explain the following:

  * 🔑 We are going to take a step back and look at how we have been making classes in JavaScript so far.

  * 🔑 In this application we are going to have a simple `Device` class and a `Phone` class that `extends` off of our `Device`.
  
  * 🔑 Now we have a basic class tree. The `Phone` can `call` and inherits the `takePicture` method from the `Device` class.

    ```js
    // Below is a class based approach.
    // We use inheritance with the `extends` keyword.
    class Device {
        constructor(name){
            this.name = name
        }

        takePicture() {
            console.log(`Taking picture with ${this.name}`)
        }
    }

    // We create a `Phone` class which extends from the `Device` class giving access to its parent's methods.
    class Phone extends Device {
        constructor(name, ringTone) {
            super(name) 
            this.ringTone = ringTone
        }

        // Create a `call` method on the `Phone` class.
        call() {
            console.log(`Phone: ${this.ringTone}`)
        }
    }

    // We have to use the `new` keyword.
    const Nokia = new Phone('Nokia', 'ring')
    Nokia.call()
    Nokia.takePicture()
    console.log(Nokia)
    ```

  * If we run this in node we can see that it is working like we expected.

    ```
    Phone: ring
    Taking picture with Nokia
    ```

  * 🔑 Lets have a quick refresher on how the prototype chains works with classes by inspecting the `Nokia` variable we created.

  * 🔑 By looking at the `__proto__` object we can see the reference to our `Device` which holds the `takePicture` method that our `Phone` class inherits.

      ```
      Phone {name: "Nokia", ringTone: "ring"}
        name: "Nokia"
        ringTone: "ring"
        __proto__: Device
          call: ƒ call()
          constructor: class Phone
          __proto__:
            constructor: class Device
            takePicture: ƒ takePicture()
            __proto__: Object
      ```

  * In this application we are going to create two more classes, `Appliance` and `Dryer` that `extends` of it.

  * Like earlier, they each have a method and some type of data stored.

    ```js
    // Create a new class for appliances.
    class Appliance {
        constructor(noise){
            this.noise = noise
        }

        makeNoise() {
            console.log(this.noise)
        }
    }

    class Dryer extends Appliance {
        constructor(noise) {
            super(noise)

        }

        dry() {
            console.log(`Dryer is on: ${this.noise}`);
        }
    }
      ``` 

  * Okay, we have a simple class hiearchy inside of our application.

  * The `Phone` class inherits from the `Device` class and the `Dryer` class inherits from the `Appliance` class.

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ What happens if we want to make an appliance that can make a phone call??

  * 🙋 We would have to make a new `call` method on the `Appliance` 

  * 🔑 Having to rewrite logic does not practice the DRY principle of programming. Don't Repeat Yourself.

  * 🔑 This can get quickly out of control and make our application very rigid.

* Open `17-Ins_Factory-Vs-Constructor/factory-functions.js` in your IDE and explain the following:

  * 🔑 Lets look at how we can take a composition based approach with factory functions.

  * 🔑 Lets create our action functions Which are also factory functions.

  * 🔑 These functions will accept an object with the proper keys mapped and use that data in the returned function.
    
    ```js
    const phoneCall = (state) => ({
      call: () => console.log(`${state.name}'s Phone: ${state.ringTone}`),
    });

    const makeNoise = (state) => ({
      noise: () => console.log(state.noise),
    });

    const drying = (state) => ({
      dry: () =>
        console.log(`Finish drying in ${state.timer} minutes. ${state.noise}`),
    });
      ```

  * 🔑 Now lets create a phone using factory function.

  * 🔑 Create a function named `Phone` which recieves the `name` and `ringTone`.

  * 🔑 Store the arguments we recieved into an object.

      ```js
      const Phone = (name, ringTone) => {
        // Store the arguments in an object so that we can pass them to the correct functions we return.
        const state = {
          name,
          ringTone,
        };
      };
      ```

  * 🔑 Lets return an object and with `...` operator and our action function passing in the `state` to it.

      ```js
      const Phone = (name, ringTone) => {
        // Store the arguments in an object so that we can pass them to the correct functions we return.
        const state = {
          name,
          ringTone,
        };

        // Return the action functions we want our `Phone` to use.
        return { ...phoneCall(state) };
      };
      ```

  * Using the same logic we are going to create a `Dryer` and `Washer` factory functions.

      ```js
      const Dryer = (noise, timer) => {
        const state = {
          noise,
          timer,
        };

        return { ...makeNoise(state), ...drying(state) };
      };

      const Washer = (name, noise, ringTone) => {
        const state = {
          name,
          noise,
          ringTone,
        };

        // We now have access to the `phoneCall` method because it is no longer tightly coupled to the `Device` class.
        // If we were to use inheritance we would have to rewrite the `call` function inside the `Appliance` class tree.
        // Good coding practice is DRY. Don't Repeat Yourself.
        return { ...makeNoise(state), ...phoneCall(state) };
      };
      ```
  * 🔑 Lets test out our new factory functions to see if it works as expected.

    ```js
    // No need to add the `new` keyword because we are using a factory function.
    const Nokia = Phone('Nokia', 'ring');
    const Decker = Dryer('brshhuhsh', 35);
    const WPool = Washer('Whirlpool', 'brshhh', 'ring ring from the washer');
    // Test if our action functions work correctly with our newly created phone.
    Nokia.call();
    Decker.noise();
    Decker.dry();
    WPool.call();
    WPool.noise();
    ```

  * If we run this in node we can see that it is working like we expected.

  * 🔑 With Inheritance we design our types based what they are. With composition we design our types on what they do.

    ```
    Nokia's Phone: ring
    brshhuhsh
    Finish drying in 35 minutes. brshhuhsh
    Whirlpool's Phone: ring ring from the washer
    brshhh
    ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ What is the difference between inheritance and composition design?

  * 🙋 Inheritance is based on what types are. Composition is based on what types do.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `18-Stu_Factory-Vs-Constructor/README.md`.

### 13. Student Do: Factory VS Constructor (15 min)

* Direct students to the activity instructions found in `18-Stu_Factory-Vs-Constructor/README.md`.

* Break your students into pairs that will work together on this activity.

```md
# 🏗️ Refactor the `Lesson` class to a factory function

Work with a partner to implement the following user story:

* As a developer, I want to move away from a inheritance based approach and start to use a composition based approach so that my application's tree hierarchy is less rigid.

* As a teacher, I want to be able to add a new lesson with a title and description to my collection of lessons I can teach.

## Acceptance Criteria

* It's done when the `Lesson` class is a factory function in order to make my application less rigid in case we decide to add new features.

* It's done when I can call the `information` method on the `Lesson` function and it correctly logs the private variable.

## 💡 Hints

What scope does your inner function have access too? 

## 🏆 Bonus

If you have completed this activity, work through the following challenge with your partner to further your knowledge:

* What are the three paradigms of JavaScript? 

Use [Google](https://www.google.com) or another search engine to research this.

---
© 2020 Trilogy Education Services, LLC, a 2U, Inc. brand. Confidential and Proprietary. All Rights Reserved.
```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students who need extra help.

### 14. Instructor Review: Factory VS Constructor (10 min) 

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How comfortable do you feel with `Factory functions vs constructor functions`? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help!

* Use the prompts and talking points (🔑) below to review the following key points:

  * ✔️ Inheritance

  * ✔️ Composition

* Open `18-Stu_Factory-Vs-Constructor/Solved/index.js` in your IDE and explain the following: 

  * 🔑 Create a function named `lesson` and two variables named `title` and `description` with the respected values.

    ```js
    // Create a function.
    const lesson = function () {
      // Store the locally scoped variables.  
      const title = 'Unit 17 - Computer Science';
      const description = 'CS for JS';

    };
    ```

  * 🔑 Instead of creating a method, we are going to return a function named `information` which will log our lesson's `title` and `description`.

    ```js
    // Create a function.
    const lesson = function () {
      // Store the locally scoped variables.  
      const title = 'Unit 17 - Computer Science';
      const description = 'CS for JS';

      // Return an inner function named 'information' creating a closure.
      return {
        information: function () {
        // Console logs the variables of the outer function.
          console.log(title, description);
        },
      };
    };
    ```
  * 🔑 No need to use the `new` keyword with a factory function.

    ```js
    const csForJS = lesson();
    csForJS.information();
    ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ Do factory functions use the `extends` keyword?

  * 🙋 No, they don't rely on inheritance.

  * ☝️ What can we do if we don't completely understand this?

  * 🙋 @TODO We can refer to supplemental material, read the [Composition over inheritance](https://en.wikipedia.org/wiki/Composition_over_inheritance), and stick around for office hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 15. Instructor Demo: { ACTIVITY NAME } (5 min) 

@TODO USE THE FOLLOWING FOR BROWSER AND/OR COMMAND LINE DEMOS, RESPECTIVELY. REMOVE IF UNUSED

* Open `@TODO/folder/file` in your browser and demonstrate the following:

* Run `@TODO/folder/file { AND ARGS, IF ANY }` from the command line and demonstrate the following: 

  * 🔑 @TODO { WHEN WE DO THIS, IT DOES THAT. }

  * 🔑 @TODO { WE ALSO SEE THESE THINGS. }

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How would we build this?

  * 🙋 @TODO { YES, HOW? } 

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `@TODO/folder/file`.

### 16. Student Do: { ACTIVITY NAME } (15 min) 

* Direct students to the activity instructions found in `@TODO/folder/file`.

* Break your students into pairs that will work together on this activity.

```md
@TODO ADD INSTRUCTIONS
```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students who need extra help.

### 17. Instructor Review: { ACTIVITY NAME } (15 min)

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How comfortable do you feel with `@TODO TOPIC`? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help!

* Use the prompts and talking points (🔑) below to review the following key points:

  * ✔️ @TODO { THIS }

  * ✔️ @TODO { THAT }

  * ✔️ @TODO { THE OTHER }

* Open `@TODO/folder/file` in your IDE and explain the following: 

  * @TODO { WE DO THIS AND THE RESULT IS THAT }

    ```
    @TODO ADD CODE SNIPPET, TABBED
    ```

  * 🔑 @TODO DON'T FORGET TO USE THE KEY EMOJI ON KEY POINTS, BUT ONLY KEY POINTS, NOT _EVERY_ POINT

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ @TODO { DO WE END OUR REVIEWS WITH A QUESTION? }

  * 🙋 @TODO { YES, WE DO! }

  * ☝️ What can we do if we don't completely understand this?

  * 🙋 @TODO We can refer to supplemental material, read the [{ DOCS }]({ URL }), and stick around for office hours to ask for help.

* Answer any questions before ending the class.

### 18. END (0 min)

How did today’s lesson go? Your feedback is important. Please take 5 minutes to complete this [anonymous survey](https://forms.gle/RfcVyXiMmZQut6aJ6).

---
@TODO © YEAR Trilogy Education Services, LLC, a 2U, Inc. brand. Confidential and Proprietary. All Rights Reserved.