# 18.3 Part-Time Lesson Plan: Mongoose

## Overview

This lesson plan will cover the creating computed properties in Mongoose with something called a virtual property. You will also cover populating a sub document in Mongoose after it has been created. Finally, you will go through the various create, read, update, and delete operations that you can perform on a Mongoose document.

## Instructor Notes

* In this lesson, students will complete activities `21-Stu_Aggregates` through `28-Stu_Mini-Project`.

* Students might find it difficult to understand the difference between data that gets stored in the database, and information that gets computed on the fly using virtual properties. Be sure to read the [Mongoose Virtual Properties Documentation](http://mongoosejs.com/docs/api.html#virtuals_virtuals) prior to class to ensure that help teach students the difference between the two.

* Most activities in this lesson will require students to run the seed script by running `npm run seed` or `yarn seed` in the terminal inside the `Unsolved` directory for each activity.

* Remind students to do a `git pull` of the class repo to have today's activities ready and open in VS Code.

* If you are comfortable doing so, live-code the solutions to the activities. If not, just use the solutions provided and follow the prompts and talking points for review.

* Let students know that the Bonus at the end of each activity is not meant to be extra coding practice, but instead is a self-study on topics beyond the scope of this unit for those who want to further their knowledge.

* If the students struggle with the `Everyone Do: Git` activity, walk through it with the students using the talking points provided. Otherwise, support the students as they do the activity and do a brief review at the end.

## Learning Objectives

By the end of class, students will be able to:

* Explain and execute CRUD methods with MongoDB

* Configure Heroku for deployment of a Node.js application using MongoDB

* Implement a Mongoose virtual property to create computed properties that are not stored in the database

## Time Tracker

| Start  | #   | Activity Name                              | Duration |
|---     |---  |---                                         |---       |
| 10:00AM| 1   | Instructor Do: Stoke Curiosity             | 0:10     |
| 10:10AM| 2   | Instructor Demo: Virtuals                  | 0:05     |
| 10:15AM| 3   | Student Do: Virtuals                       | 0:15     |
| 10:30AM| 4   | Instructor Review: Virtuals                | 0:10     |
| 10:40AM| 5   | Instructor Demo: Subdocument Population    | 0:05     |
| 10:45AM| 6   | Student Do: Subdocument Population         | 0:15     |
| 11:00AM| 7   | Instructor Review: Subdocument Population  | 0:10     |
| 11:10AM| 8   | Instructor Demo: Mongoose CRUD             | 0:05     |
| 11:15AM| 9   | Student Do: Mongoose CRUD                  | 0:15     |
| 11:30AM| 10  | Instructor Review: Mongoose CRUD           | 0:10     |
| 11:40AM| 11  | Everyone Do: Git                           | 0:20     |
| 12:00PM| 12  | BREAK                                      | 0:40     |
| 12:40PM| 13  | Instructor Demo: Mini-project              | 0:05     |
| 12:45PM| 14  | Student Do: Mini-project                   | 0:60     |
| 1:45PM | 15  | Instructor Review: Mini-project            | 0:10     |
| 1:55PM | 16  | Introduce Homework                         | 0:05     |
| 2:00PM | 17  | END                                        | 0:00     |

> **Important**: If this lesson occurs on a weekday, you'll follow a different schedule to accommodate for the shorter class time. The `Stoke Curiosity` section is shortened by 5 minutes, the break by 25 minutes, and the `Student Do: Mini-project` by 10 minutes, and the `Everyone Do: Git` activity is omitted completely.

<details>
  <summary>Click to show the adjusted time tracker</summary>

| Start  | #   | Activity Name                              | Duration |
|---     |---  |---                                         |---       |
| 6:30PM | 1   | Instructor Do: Stoke Curiosity             | **0:05** |
| 6:35PM | 2   | Instructor Demo: Virtuals                   | 0:05     |
| 6:40PM | 3   | Student Do: Virtuals                       | 0:15     |
| 6:55PM | 4   | Instructor Review: Virtuals                | 0:10     |
| 7:05PM | 5   | Instructor Demo: Subdocument Population    | 0:05     |
| 7:10PM | 6   | Student Do: Subdocument Population         | 0:15     |
| 7:25PM | 7   | Instructor Review: Subdocument Population  | 0:10     |
| 7:35PM | 8   | Instructor Demo: Populating Subdocuments   | 0:05     |
| 7:40PM | 9   | Student Do: Populating Subdocuments        | 0:15     |
| 7:55PM | 10  | BREAK                                      | **0:15** |
| 8:10PM | 11  | Instructor Review: Populating Subdocuments | 0:10     |
| 8:20PM | 12  | Instructor Demo: Mini-project              | 0:05     |
| 8:25PM | 13  | Student Do: Mini-project                   | **0:50** |
| 9:15PM | 14  | Instructor Review: Mini-project            | 0:10     |
| 9:25PM | 15  | Introduce Homework                         | 0:05     |
| 9:30PM | 16  | END                                        | 0:00     |
</details>

---

## Class Instruction

### 1. Instructor Do: Stoke Curiosity (10 min)

<!-- TODO come back and review this -->
* Welcome students to class and explain the purpose of today's lesson.

* Congratulate students on their hard work and explain where MongoDB fits in the bigger picture as we move into the MERN stack.

* As your application grows in size and you ideas become more ambitious, you'll need to scale your application. MongoDB is a great fit for this. The nice thing about MongoDB is that the time to get your database up and running is significantly reduced when compared to a relational database. This is because MongoDB is schema-less, meaning that you don't have to define the structure of your database in advance. This means that you can add and remove fields without having to change your application. That said, it's important to note that MongoDB is not a replacement for relational databases. With Mongoose you can still use the relational database's features, such as foreign keys, relationships, and indexes.

* Along with Heroku, today we will be taking advantage of the free MongoDB Atlas service to help us deploy our database remotely. The free tier we will be using is perfect our our small application, however if we wanted we could set up our server to automatically scale using proactive or reactive scaling. When transaction times are high, or errors are common, we can use the MongoDB Replica Set to help us scale.

### 2. Instructor Demo: Virtuals (5 min)

* Open [21-Ins_Virtuals/server.js](../../01-Activities/18-NoSQL/21-Ins_Virtuals/server.js) in your IDE.

* Run `npm seed && npm start` from the command line and demonstrate the following:

  * 🔑 In this demo, we will be using virtuals to create computed properties that are not stored in the database.

  * First let's review the folder structure of this application:

    ```sh
    .
    ├── config
    │   └── connection.js
    ├── controllers
    │   ├── commentController.js
    │   └── postController.js
    ├── models
    │   ├── Comment.js
    │   ├── Post.js
    │   └── index.js
    ├── package.json
    ├── routes
    │   ├── api
    │   │   ├── commentRoutes.js
    │   │   ├── index.js
    │   │   └── postRoutes.js
    │   └── index.js
    ├── server.js
    ├── utils
    │   ├── data.js
    │   └── seed.js
    └── yarn.lock
    ```

  * To keep things organized, we broke up our code into multiple files. In our server file you can see that we import our database connection and our routes at the top:

    ```js
    const express = require('express');
    const db = require('./config/connection');
    const routes = require('./routes');

    const PORT = 3001;
    const app = express();

    app.use(express.urlencoded({ extended: true }));
    app.use(express.json());
    app.use(routes);

    db.once('open', () => {
      app.listen(PORT, () => {
        console.log(`API server running on port ${PORT}!`);
      });
    });
      ```

  * Similarly, we created a central `index.js` file for our `api/`, `models/`, and `controllers/` to keep things organized.

  * Now that we have an understanding of the folder structure, let's take a look at our `models` folder and dive into the main concept for this demo - virtuals.

* Open `21-Ins_Virtuals/models/Post.js` in your IDE to demonstrate the following:

  * Virtuals are a way to create computed properties that are not stored in the database.

  * Virtuals also allow the user of your API a way to get computed properties from the server without having to write front end logic to calculate them.

  * The example used in this demo is a computed property that calculates the number of comments on a post.

  * **Important**: Mongoose will not include virtuals in the schema unless you explicitly tell it to. As a result, we add an options object to our schema definition to tell Mongoose to include virtuals by setting the `virtuals` property to `true`.

  * Our postSchema has the following properties:

    ```js
    const postSchema = new Schema(
      {
        text: String,
        username: String,
        comments: [{ type: Schema.Types.ObjectId, ref: 'comment' }],
      },
      {
        toJSON: {
          virtuals: true,
        },
        id: false,
      }
    );
    ```

  * To create a virtual property, we use the `virtual` method and pass in the name of the property we want to create. In this case, we want to create a property called `commentCount` that will return the number of comments on a post.

  * We then define a getter function that returns the value of the property we want to create.

  * Virtuals are defined in the `Post` model as follows:

    ```js
    postSchema.virtual('commentCount').get(function () {
      return this.comments.length;
    });
    ```

  * We can then access the property in our `Post` model as follows:

    ```js
    post.commentCount;
    ```

* Make a GET request to `http://localhost:3001/api/posts` in Insomnia and demonstrate the following:

  * You should see a list of posts with a `commentCount` property. While our seed data is set to have a static number of comments, we can see that the `commentCount` property is dynamically calculated:

    ```json
    [
      {
        "comments": [
          "6113e9dbad15d35c4b407adc"
        ],
        "_id": "6113e9dbad15d35c4b407ae0",
        "text": " blandit curabitur imsum nullam hendrerit ut imperdiet nunc a nullam",
        "username": "Alex",
        "commentCount": 1
      },
      {
        "comments": [
          "6113e9dbad15d35c4b407adb"
        ],
        "_id": "6113e9dbad15d35c4b407ae1",
        "text": " nullam libero gravida orci lorem lacinia lorem nullam imperdiet dolor",
        "username": "Zennon",
        "commentCount": 1
      }
    ]
    ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How would we build this?

  * 🙋 We could build a virtual property in our model by using the `virtual` method and passing in the name of the property we want to create. The `get` method is then used to define the getter function which will return the computed property.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `22-Stu_Virtuals/README.md`.

### 3. Student Do: Virtuals (15 min)

* Direct students to the activity instructions found in `22-Stu_Virtuals/README.md`.

* Break your students into pairs that will work together on this activity.

  ````md
  # 🏗️ Create a Virtual

  Work with a partner to implement the following user story:

  * As a developer, I want to implement a Mongoose virtual in my schema to get and set data. 

  * As a developer, I do not want that data to persist to the database so I can get and set computed properties on documents.

  ## Acceptance Criteria

  * It's done when I have defined a virtual property on the `userSchema` called `fullName` that will get the `first` and `last` attributes and return a string containing the full name of the user.

  * It's done when I have defined a `set()` method on the `fullName` virtual that takes a string containing the full name of the user and sets the virtual attribute values for `first` and `last`.

  * It's done when I allow the schema to include virtuals in `res.json()` by setting the `toJSON` schema option to `{ virtuals: true }`.

  * It's done when I have run the code and added a user using Insomnia.

      ```json
      {  
          "first": "Ada",
          "last": "Lovelace",
          "age": 36
      }
      ```

  * It's done when I have performed a GET request to `http://localhost:3001/api/users/` to get all users and confirmed that the `fullName` virtual attribute is present in response.

  ## 💡 Hints

  What method do we use on a Mongoose schema to create a virtual property?

  Why do we need the `this` keyword when working with virtuals?

  ## 🏆 Bonus

  If you have completed this activity, work through the following challenge with your partner to further your knowledge:

  * What are some of the limitations of Mongoose virtuals as they relate to queries?

  Use [Google](https://www.google.com) or another search engine to research this.
  ````

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students who need extra help.

### 4. Instructor Review: Virtuals (10 min)  

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How comfortable do you feel with virtual properties? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help!

* Use the prompts and talking points (🔑) below to review the following key points:

  * ✔️ `toJSON: { virtuals: true }`

  * ✔️ `this` keyword inside controllers

* Open `22-Stu_Virtuals/Solved/models/User.js` in your IDE and explain the following:

  * In order to get the full name of a user, we need to access the `first` and `last` attributes of the user. These attributes are part of the `userSchema`:

    ```js
    const userSchema = new Schema(
      {
        first: String,
        last: String,
        age: Number,
      }
    );
    ```

  * Next, we needed to create a virtual property on the `userSchema` called `fullName` that will get the `first` and `last` attributes and return a string containing the full name of the user.

  * **Important**: The `this` keyword is used inside of the userSchema.

  * To do this, we invoke the `virtual` method on the `userSchema` and pass in the name of the property we want to create. The `get` method is then used to define the getter function which will return the computed property, as show below:

    ```js
    userSchema.virtual('fullName').get(function () {
      return `${this.first} ${this.last}`;
    });
    ```

  * We also want the virtual property to be able to work in the other direction by setting the `first` and `last` attributes of the user. We can do this by defining a `set` method on the `fullName` virtual.

  * Next, we needed to define a `set()` method on the `fullName` virtual that takes a string containing the full name of the user and sets the virtual attribute values for `first` and `last` as shown below:

    ```js
    userSchema.virtual('fullName').set(function (v) {
      const first = v.split(' ')[0];
      const last = v.split(' ')[1];
      this.set({ first, last });
    });
    ```

  * We can also chain the getter and setter methods for a virtual property as shown below:

    ```js
    userSchema
      .virtual('fullName')
      .get(function () {
        return `${this.first} ${this.last}`;
      })
      .set(function (v) {
        const first = v.split(' ')[0];
        const last = v.split(' ')[1];
        this.set({ first, last });
      });
    ```

  * Finally, we needed to allow the schema to include virtuals in `res.json()` by setting the `toJSON` schema option to `{ virtuals: true }` as shown below:

    ```js
    const userSchema = new Schema(
      {
        first: String,
        last: String,
        age: Number,
      },
      {
        toJSON: {
          virtuals: true,
        },
        id: false,
      }
    );
    ```

  * Now lets add a user to the database and see if we can get the full name of the user.

* Make a POST request to `http://localhost:3001/api/users` using the following JSON and demonstrate the following:

  * Notice that the `fullName` virtual property is present in the response after sending the request containing the following data:

    ```json
    {
      "first": "Ada",
      "last": "Lovelace",
      "age": 36
    }
    ```

  * Confirm that the `fullName` virtual property is present in the response.

    ```json
    {
      "_id": "611419e5c033b36b1775193f",
      "first": "Ada",
      "last": "Lovelace",
      "age": 36,
      "__v": 0,
      "fullName": "Ada Lovelace"
    }
    ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ What are the benefits of virtual properties?

  * 🙋 The benefits of virtual properties are that they allow us to define a property that is computed from other properties. They also us to get information without needing that that data to be stored in the database.

  * ☝️ What can we do if we don't completely understand this?

  * 🙋 We can refer to supplemental material, read the [Mongoose documentation on Virtuals](https://mongoosejs.com/docs/tutorials/virtuals.html), and stick around for office hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 5. Instructor Demo: Populating Subdocuments (5 min)

* Navigate to `23-Ins_Subdoc-Population` in your terminal and run `npm install` to install the dependencies.

  * 💡 Be sure to run the seed scripts to create the database and seed the database with the necessary data with `npm run seed`.

  * Run `npm start` to start the server.

  * In order to demonstrate the `populate` method, lets first add a `user` to the database. That user will also have a posts array that will be populated with a few posts.

* Make a POST request to `https://localhost:3001/api/users` using the following JSON and demonstrate the following:

  * First, let's add a user to the database:

    ```json
    {
      "first": "Ada",
      "last": "Lovelace",
      "age": 36
    }
    ```

  * You will see the new user in the response, including an `_id` and `posts` array. The posts array will be empty, but that is because we haven't populated it yet.

  * For now, let's copy the `_id` of the new user and use it to populate the posts array as shown in the response we got from the POST request.

    ```json
    {
      "posts": [],
      "_id": "61152e041fad508595cb68d6",
      "first": "Ada",
      "last": "Lovelace",
      "age": 36,
      "__v": 0,
      "fullName": "Ada Lovelace"
    }
    ```

  * Copy the `_id` of the new user and use it to populate to the posts array for our new user, "Ada".

* Make a POST request to `https://localhost:3001/api/posts` using the following JSON and demonstrate the following:

  * Now we can make a post that we can use to populate the posts array for our new user. Be sure to include a `userId` property that references the `_id` of the new user that we just created.

    ```json
    {
      "meta": { 
        "upvotes": 156,
        "bookmarks": 12,
      },
      "published": true,
      "text": "Why pineapple is awesome on Pizza: A true story",
      "userId": "61152e041fad508595cb68d6"
    }
    ```

  * You should see a response that looks like the following:

    ```json
    "Created the post 🎉"
    ```

  * Now let's make a GET request for all users and see if we can see the posts array populated for our new user.

* Make a GET request to `https://localhost:3001/api/users/<user_id_of_the_new_user>` and demonstrate the following:

  * You should see the new user in the response, including an `_id` and `posts` array. The posts array should now have a post.

    ```json
    {
      "posts": [
        {
          "meta": {
            "upvotes": 454,
            "bookmarks": 10
          },
          "published": true,
          "_id": "611535921fad508595cb68e7",
          "text": "Why pineapple is awesome on Pizza: A true story",
          "createdAt": "2021-08-12T14:52:02.536Z",
          "__v": 0,
          "upvoteCount": 454
        }
      ],
      "_id": "61152e041fad508595cb68d6",
      "first": "Ada",
      "last": "Lovelace",
      "age": 36,
      "fullName": "Ada Lovelace"
    }

  * You might be wondering how the `posts` array was populated if all we stored was a reference to the post's id.

* Open `23-Ins_Subdoc-Population/controllers/userController.js` in your IDE to demonstrate the following:

  * Notice that we call on the populate method to populate the posts array for our new user inside the `getSingleUser` method inside the `userController`, as shown below.

  * The `populate` method is a Mongoose method that allows you to populate a subdocument. The `populate` method takes a path to the subdocument and a path to the parent document. In this case, we are populating the posts array for the user.

    ```js
    getSingleUser(req, res) {
      User.findOne({ _id: req.params.userId })
        .select('-__v')
        .populate('posts')
        .then((user) =>
          !user
            ? res.status(404).json({ message: 'No user with that ID' })
            : res.json(user)
        )
        .catch((err) => res.status(500).json(err));
    },
    ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How would we build this?

  * 🙋 We could use the `populate` method to populate any subdocument by passing in a path to the subdocument and a path to the parent document when creating the method.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `24-Stu_Subdoc-Population/README.md`.

### 6. Student Do: Populating Subdocuments (15 min)

* Direct students to the activity instructions found in `24-Stu_Subdoc-Population/README.md`.

* Break your students into pairs that will work together on this activity.

  ````md
  # 🐛 Tag Population Not Working

  Work with a partner to resolve the following issue(s):

  * As a user, I should be able to see all tags associated with a `post` after running the Mongoose populate method on the `Posts` model.

  ## Expected Behavior

  When a user queries a `post`, the controller should return the `post` with an array populated with the associated `tags`.

  ## Actual Behavior

  When a user runs the application in an attempt to get a post, they are presented with an error:

  ```sh
  TypeError: Invalid schema configuration: `Tag` is not a valid type within the array `tags`
  ```

  ## Steps to Reproduce the Problem

  1. Navigate to `Unsolved/` in your command line window and run `npm i`

  2. Run `npm run seed` to populate an example database, or `npm run dev` to run the development server.

  3. Notice the following error: ``TypeError: Invalid schema configuration: `Tag` is not a valid type within the array `tags``

  ## 💡 Hints

  When referencing another schema inside our Post schema, what attributes and types need to be specified?

  Use `npm run dev` to automatically restart your application after you save changes

  ## 🏆 Bonus

  If you have completed this activity, work through the following challenge with your partner to further your knowledge:

  * What are the performance benefits associated with using the populate method in Mongoose as opposed to the `$lookup` operator in MongoDB?

  Use [Google](https://www.google.com) or another search engine to research this.
  ````

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students who need extra help.

### 7. Instructor Review: Populating Subdocuments (10 min)  

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How comfortable do you feel with populating subdocuments? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help!

* Use the prompts and talking points (🔑) below to review the following key points:

  * ✔️ `Schema.Types.ObjectId`

  * ✔️ `ref`

  * ✔️ `populate()`

* Open `24-Stu_Subdoc-Population/Solved/models/Post.js` in your IDE and explain the following:

  * In this activity we are again working with the `Posts` schema, but this time each `post` will have an associated `tags` array linked via the `ref` attribute, as shown in the following code snippet:

    ```js
    const postSchema = new Schema(
      {
        published: {
          type: Boolean,
          default: false,
        },
        createdAt: {
          type: Date,
          default: Date.now,
        },
        tags: [
          {
            type: Schema.Types.ObjectId,
            ref: 'Tag',
          },
        ],
        text: {
          type: String,
          minLength: 15,
          maxLength: 500,
        },
      },
      {
        toJSON: {
          virtuals: true,
        },
        id: false,
      }
    );
    ```

  * To associate a subdocument with a parent document, we use the `ref` attribute. This attribute takes a string that represents the path to the subdocument. In our case, we are linking the `tags` array to the `Tag` schema and listing the type of the subdocument as `Schema.Types.ObjectId`.

  * This means we will only reference `Tag` documents by their `_id` attribute instead of the entire document.
  
* Open the `Tag` model, `24-Stu_Subdoc-Population/models/Tag.js`, in your IDE and explain the following:

  * For organization we first imported all the models into one central file, `models/index.js`. Inside that file we require both the `Post` and `Tag` schemas and export them.

  <!-- ! WHERE YOU LEFT OFF  -->

    ```js
    const Tags = require('./Tags');
    const Post = require('./Post');

    module.exports = { Tags, Post };
    ```

* Open `24-Stu_Subdoc-Population/Solved/controllers/tagController.js` in your IDE to demonstrate the following:

  * First we use the imported Tag schema from `models/index.js` and invoke one of the built in Mongoose methods to find all the tags in the database.

  * We also chained an additional method called `select` which allows us to limit the fields returned from the database. In our case we are removing the `-__v` field, which is the Mongoose version number.
  
    ```js
    getTags(req, res) {
      Tags.find({})
        .select('-__v')
    ...
    ```

  * In the `getTags` method, we are using the `populate` method to populate the `posts` array for each `id` in the array that is associated with a post.

  * The populate method takes a path to the subdocument and a path to the parent document. In this case, we are populating the `posts` array for each `tag`.

    ```js
    getTags(req, res) {
      Tags.find({})
        .select('-__v')
        .populate('posts')
        .then((tags) => res.json(tags))
        .catch((err) => res.status(500).json(err));
    },
    ```

  * 🔑 @TODO DON'T FORGET TO USE THE KEY EMOJI ON KEY POINTS, BUT ONLY KEY POINTS, NOT _EVERY_ POINT

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ @TODO { DO WE END OUR REVIEWS WITH A QUESTION? }

  * 🙋 @TODO { YES, WE DO! }

  * ☝️ What can we do if we don't completely understand this?

  * 🙋 @TODO We can refer to supplemental material, read the [{ DOCS }]({ URL }), and stick around for office hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 8. Instructor Demo: Mongoose CRUD (5 min)

@TODO USE THE FOLLOWING FOR BROWSER AND/OR COMMAND LINE DEMOS, RESPECTIVELY. REMOVE IF UNUSED

* Open `@TODO/folder/file` in your browser and demonstrate the following:

* Run `@TODO/folder/file { AND ARGS, IF ANY }` from the command line and demonstrate the following:

  * 🔑 @TODO { WHEN WE DO THIS, IT DOES THAT. }

  * 🔑 @TODO { WE ALSO SEE THESE THINGS. }

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How would we build this?

  * 🙋 @TODO { YES, HOW? }

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `@TODO/folder/file`.

### 9. Student Do: Mongoose CRUD (15 min)

* Direct students to the activity instructions found in `@TODO/folder/file`.

* Break your students into pairs that will work together on this activity.

  ```md
  @TODO ADD ACTIVITY INSTRUCTIONS, TABBED ONCE OR TWICE (DEPENDING ON CODE SNIPPETS IN ACTIVITY INSTRUCTIONS)
  ```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students who need extra help.

### 10. Instructor Review: Mongoose CRUD (10 min)  

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How comfortable do you feel with @TODO { TOPIC }? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help!

* Use the prompts and talking points (🔑) below to review the following key points:

  * ✔️ @TODO { THIS }

  * ✔️ @TODO { THAT }

  * ✔️ @TODO { THE OTHER }

* Open `@TODO/folder/file` in your IDE and explain the following:

  * @TODO { WE DO THIS AND THE RESULT IS THAT }

    ```
    @TODO ADD CODE SNIPPET, TABBED TWICE (4 SPACES)
    ```

  * 🔑 @TODO DON'T FORGET TO USE THE KEY EMOJI ON KEY POINTS, BUT ONLY KEY POINTS, NOT _EVERY_ POINT

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ @TODO { DO WE END OUR REVIEWS WITH A QUESTION? }

  * 🙋 @TODO { YES, WE DO! }

  * ☝️ What can we do if we don't completely understand this?

  * 🙋 @TODO We can refer to supplemental material, read the [{ DOCS }]({ URL }), and stick around for office hours to ask for help.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `@TODO/folder/file`.

### 11. Everyone Do: Git (20 min)

* @TODO Open [Git docs](https://git-scm.com/docs/{TITLE}) in your browser and explain the following:

  * @TODO GIVE A SHORT EXPLANATION OF THIS GIT CONCEPT/COMMAND.

* Direct students to the activity instructions found in `@TODO/folder/file`.

* While everyone is working on the activity, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students who need extra help.

* Open your command line and demonstrate the following:

  * @TODO { WE DO THIS AND THE RESULT IS THAT }

    ```
    @TODO ADD CODE SNIPPET, TABBED TWICE (4 SPACES)
    ```

  * 🔑 @TODO DON'T FORGET TO USE THE KEY EMOJI ON KEY POINTS, BUT ONLY KEY POINTS, NOT _EVERY_ POINT

* Answer any questions before students go on break.

### 12. BREAK (40 min)

### 13. Instructor Demo: Mini Project (5 min)

@TODO USE THE FOLLOWING FOR BROWSER AND/OR COMMAND LINE DEMOS, RESPECTIVELY. REMOVE IF UNUSED

* Open `@TODO/folder/file` in your browser and demonstrate the following:

* Run `@TODO/folder/file { AND ARGS, IF ANY }` from the command line and demonstrate the following:

  * 🔑 @TODO { WHEN WE DO THIS, IT DOES THAT. }

  * 🔑 @TODO { WE ALSO SEE THESE THINGS. }

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How would we build this?

  * 🙋 @TODO { YES, HOW? }

* Answer any questions before allowing students to start the mini project.

### 14. Student Do: Mini Project (60 min)

* Direct students to the activity instructions found in `@TODO/folder/file`.

* Break your students into groups that will work together on this activity.

  ```md
  @TODO ADD ACTIVITY INSTRUCTIONS, TABBED ONCE OR TWICE (DEPENDING ON CODE SNIPPETS IN ACTIVITY INSTRUCTIONS)
  ```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students who need extra help.

### 15. Instructor Review: Mini Project  (10 min)  

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How comfortable do you feel with this mini-project? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help!

* Use the prompts and talking points (🔑) below to review the following key points:

  * ✔️ @TODO { THIS }

  * ✔️ @TODO { THAT }

  * ✔️ @TODO { THE OTHER }

* Open `@TODO/folder/file` in your IDE and explain the following:

  * @TODO { WE DO THIS AND THE RESULT IS THAT }

    ```
    @TODO ADD CODE SNIPPET, TABBED TWICE (4 SPACES)
    ```

  * 🔑 @TODO DON'T FORGET TO USE THE KEY EMOJI ON KEY POINTS, BUT ONLY KEY POINTS, NOT _EVERY_ POINT

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ @TODO { DO WE END OUR REVIEWS WITH A QUESTION? }

  * 🙋 @TODO { YES, WE DO! }

  * ☝️ What can we do if we don't completely understand this?

  * 🙋 @TODO We can refer to supplemental material, read the [{ DOCS }]({ URL }), and stick around for office hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 16. Instructor Demo: Introduce Homework (5 min)

@TODO USE THE FOLLOWING FOR BROWSER AND/OR COMMAND LINE DEMOS, RESPECTIVELY. REMOVE IF UNUSED

* Open `@TODO/folder/file` in your browser and demonstrate the following:

* Run `@TODO/folder/file { AND ARGS, IF ANY }` from the command line and demonstrate the following:

  * @TODO { WHAT ARE WE GOING TO BE BUILD? }

  * @TODO { ISN'T THIS NEAT! A SOPHISTICATED OR MODERN APPLICATION OF A KEY TOPIC. }

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ What are we learning?

  * 🙋 @TODO { YES, WHAT? }.

  * ☝️ How does this project build off or extend previously learned material?

  * 🙋 @TODO {YES, WHAT? }.

  * ☝️ How does this project relate to your career goals?

  * 🙋 @TODO { HOW DO COMPANIES USE IT IN INTERESTING WAYS? HOW POPULAR OR IN-DEMAND IS IT? WHY IS THE PROJECT ENTICING TO EMPLOYERS? }

* Ask TAs to direct students to the Homework Requirements found in `@TODO/folder/file`.

* Answer any questions before ending the class.

### 17. END (0 min)

How did today’s lesson go? Your feedback is important. Please take 5 minutes to complete this [anonymous survey](https://forms.gle/RfcVyXiMmZQut6aJ6).

---
@TODO © YEAR Trilogy Education Services, LLC, a 2U, Inc. brand. Confidential and Proprietary. All Rights Reserved.
