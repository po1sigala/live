# 19.2 Part-Time Lesson Plan: Introduction to Workbox, Caching, and Service Workers

## Overview

In this class, students will learn how to use the workbox library to cache and serve static assets. Students will also become familiar with the different methods workbox provides to create a service worker. Additionally, students will learn some of the caching strategies that workbox provides out of the box.

## Instructor Notes

* In this lesson, students will complete activities `11-Ins_WebPack-HMR` through `20-Stu_Client-Server`.

* This unit features activities that will require students to save and refresh the browser in order to see changes. The very nature of PWAs means that, by design, students will likely run into issues with cached assets interfering while debugging and testing. 

   > **Important**: If you are having issues with cached assets, please use a private or incognito window to view the application.

* For Chrome users, you can open an incognito window by clicking the three dots in the top-right corner of the browser. From there, click the "New Incognito Window" button. You can also use hot keys to open an incognito window: on macOS, press Command + Shift + N; on Windows, press Control + Shift + N.

* In addition to using a private window, students can troubleshoot caching issues further by completely unregistering the service worker. This will allow the browser to cache the assets again. Details on how to do this will vary among browsers, but generally you can find the option to do this in the browser's developer tools.

* Remind students to do a `git pull` of the class repo and to have today's activities ready and open in VS Code.

* If you are comfortable doing so, live code the solutions to the activities. If not, just use the solutions provided and follow the prompts and talking points for review.

* Let students know that the Bonus at the end of each activity is not meant to be extra coding practice, but instead is a self-study on topics beyond the scope of this unit for those who want to further their knowledge.

## Learning Objectives

By the end of class, students will be able to:

* Implement service workers to a web application.

* Leverage caching strategies to optimize performance.

* Execute a full-stack application with a server and client-side development server.

## Time Tracker

| Start  | #   | Activity Name                                     | Duration |
| ------ | --- | ------------------------------------------------- | -------- |
| 6:30PM | 1   | Instructor Do: Stoke Curiosity                    | 0:10     |
| 6:40PM | 2   | Instructor Demo: Hot Module Replacement           | 0:05     |
| 6:45PM | 3   | Student Do: Hot Module Replacement                | 0:15     |
| 7:00PM | 4   | Instructor Review: Hot Module Replacement         | 0:10     |
| 7:10PM | 5   | Instructor Demo: WorkBox Service Workers          | 0:05     |
| 7:15PM | 6   | Student Do: WorkBox Service Workers               | 0:15     |
| 7:30PM | 7   | Instructor Review: WorkBox Service Workers        | 0:10     |
| 7:40PM | 8   | Instructor Demo: Cache CSS and JavaScript Files   | 0:05     |
| 7:45PM | 9   | Student Do: Cache CSS and JavaScript Files        | 0:15     |
| 8:00PM | 10  | BREAK                                             | 0:15     |
| 8:15PM | 11  | Instructor Review: Cache CSS and JavaScript Files | 0:10     |
| 8:25PM | 12  | Instructor Demo: Caching Images                   | 0:05     |
| 8:30PM | 13  | Student Do: Caching Images                        | 0:15     |
| 8:45PM | 14  | Instructor Review: Caching Images                 | 0:10     |
| 8:55PM | 15  | Instructor Demo: Client-Server Model              | 0:05     |
| 9:00PM | 16  | Student Do: Client-Server Model                   | 0:15     |
| 9:15PM | 17  | Instructor Review: Client-Server Model            | 0:15     |
| 9:30PM | 18  | END                                               | 0:00     |

> **Important**: If this lesson occurs on a Saturday, make sure to adjust the activities to accommodate for the extra hour of class time. Feel free to take your time as you go through the activities; for example, you can add 5 minutes to the `Student Do` and `Instructor Review` sections as you see fit. Remember to take a 40-minute break at noon!

---

## Class Instruction

### 1. Instructor Do: Stoke Curiosity (10 min)

* Welcome students to class.

* Progressive Web Apps and service workers first appeared in the browser in 2015. However, the concept was first discussed by Steve Jobs in 2007 just 18 days before the first iPhone shipped. At the time, Steve Jobs envisioned a way to create web applications that look and behave like native apps. The idea was to leverage the browser's native APIs to create a web application that could run on any device. We now know that history played out differently with the advent of the app store, but the concept remains relevant today.

* You can get a glimpse of this moment in history by watching the following video: ["One Last Thing" by Steve Jobs at Worldwide Developer Conference 07'](https://youtu.be/ZlE7dzoD6GA)

* It wasn't until 2015 that Google took that concept and gave it some life. The first Progressive Web App (PWA) specification was introduced at the Chrome Dev summit in 2015. Shortly after, developers started to use the specification to create web applications. Some of the most notable examples of PWAs are Twitter, Uber, and Google Maps, which all tout reduced data consumption of about 70% or more.

* Today, creating a PWA is a lot easier than it was back then, and is usually a lot more cost-effective than developing a mobile application. Google has created an amazing set of tools, called workbox, to help developers create a service worker with minimal effort.

* In this unit, you will learn about service workers and how to use them to cache assets, improve performance, and serve static assets. We will look at one that was made from scratch using plain Javascript, and another that was built on top of workbox.

* We will start with the project setup needed to replace modules on the fly, move on to learning how to generate a service worker using Workbox, and finally learn how to implement caching strategies that make your app faster, and if configured correctly, able to work offline.

### 2. Instructor Demo: Hot Module Replacement (5 min)

* In the terminal, navigate to `11-Ins_WebPack-HMR` and run `npm i && npm run dev`. This will install the dependencies and run the development server.

  * ğŸ”‘ When we run this application, we notice that there is a build process happening on the fly, but unlike other start scripts, this time we are not actually outputting the files to the `dist` directory.

  * ğŸ”‘ Instead, the files are built and sent directly to the browser. The Hot Module Replacement (HMR) will take care of appending a hash to the file name, and the browser will automatically refresh the page when the file changes. For example, this is an example of the file name that will be sent to the browser:

    ```bash
    index.be865f63154ff82e7d29.hot-update.js
    ```

* Open `webpack.config.js` in your IDE to demonstrate the following:

  * In this file, you can see that we have set up our webpack config to use Hot Module Replacement by adding a `devServer` options object with a attribute of `hot` set to `only`. This will reload the module without reloading the entire page.

  * ğŸ”‘ In development, not having to refresh the page is a benefit so that we can see the change in the browser immediately and also keep an eye on the HMR logs that are generated by webpack.

  * It is important to note that when using webpack, you don't need to install the Hot Module Replacement plugin. You can simply add the `hot` option to the `devServer` object in your webpack config.

  * ğŸ”‘ Under the hood, webpack calls on another developer dependency called `webpack-dev-server` when it parses the `devServer` object in the `webpack.config.js` file. You can see this package listed in the `devDependencies` section of the `package.json` file.

* Open the `src/css/style.css` file in your IDE to demonstrate the following:

  * Update the font or font weight of the `h1` element and save the file.

  * ğŸ”‘ Notice that when we update some of the content of a CSS file, we don't need to refresh the page to see the updates reflected in the browser.

* Ask the class the following questions (â˜ï¸) and call on students for the answers (ğŸ™‹):

  * â˜ï¸ How would we build this?

  * ğŸ™‹ We make sure that `webpack-dev-server` is set up to use Hot Module Replacement by adding a `devServer` object to our webpack config.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `12-Stu_WebPack-HMR/README.md`.

### 3. Student Do: Hot Module Replacement (15 min)

* Direct students to the activity instructions found in `12-Stu_WebPack-HMR/README.md`, which are also shown below.

* Break your students into pairs that will work together on this activity.

  ```md
  # ğŸ“– Add WebPack Development Server to a Project Using Hot Module Replacement (HMR)

  Work with a partner to implement the following user story:

  * As a developer, I want to add a `webpack-dev-server` to my project so that I can use Hot Module Replacement (HMR) to update the page without a full page refresh.

  * As a developer, I want to learn how to configure `webpack-dev-server` so that it can test my project in a way that allows my work to continue without much downtime.

  ## Acceptance Criteria

  * It is done when I have installed `webpack-dev-server` as a `devDependency`.

  * It is done when I have added a `dev` command to `package.json` that runs `webpack-dev-server --open`.

  * It is done when I have a `webpack.config.js` file in my project that includes the `devServer` property.

  * It is done when I have added a `hot` property to the `devServer` object in `webpack.config.js` and set its value do the default: `only`.

  * It is done when I have opened `Unsolved/src/index.js` and made the following changes:

    * Imported the CSS file from the CSS folder.

    * Added logic to accept Hot Module Replacement (HMR), as this is an optional feature.

  * It is done when I have modified or added some content to the `style.css` file. For example, I changed the `h1` font weight in the `style.css` file and saved it; and that change is reflected in the browser.

  ## ğŸ“ Notes

  * If you encounter any issues with loading your most recent changes, try again in a private/incognito window.

  Refer to the documentation:

  * [Webpack docs on Hot Module Replacement (HMR)](https://webpack.js.org/guides/hot-module-replacement/#enabling-hmr)

  * [Webpack docs on webpack-dev-server](https://webpack.js.org/configuration/dev-server/)

  ## ğŸ’¡ Hints

  * What other options are available for the `devServer` property?

  ## ğŸ† Bonus

  If you have completed this activity, work through the following challenge with your partner to further your knowledge:

  * What is another way to run `webpack-dev-server` without needing to add it to our `package.json` file?

  Use [Google](https://www.google.com) or another search engine to research this.
  ```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students who need extra help.

### 4. Instructor Review: Hot Module Replacement (10 min)

* Ask the class the following questions (â˜ï¸) and call on students for the answers (ğŸ™‹):

  * â˜ï¸ How comfortable do you feel with Hot Module Replacement and how it can help us in development? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use Office Hours to get extra help.

* Use the prompts and talking points (ğŸ”‘) below to review the following key points:

  * âœ”ï¸ `webpack-dev-server`

  * âœ”ï¸ `hot: 'only'`

  * âœ”ï¸ `module.hot.accept()`

* Open `Solved/package.json` in your IDE and explain the following:

  * ğŸ”‘ Notice that we have added a `devDependencies` object to our `package.json` file. This object contains all of the dependencies that we need to run our development server.

  * ğŸ”‘ When creating a project, the `webpack-dev-server` package is best installed as a `devDependency`. The reason for this that it is only used in development and not in production.

  * Keeping your dependencies list to a minimum is a good way to keep your project size down. While this isn't as important for these simple demos, it is good practice and something you should consider when creating your own projects.

  * ğŸ”‘ In our scripts, we've also added a `dev` command to run `webpack-dev-server --open`. This command will run the `webpack-dev-server` and open the project in the browser. Optionally, if you don't like this behavior, you can use `--no-open` to prevent the browser from opening.

    ```json
    "scripts": {
      "dev": "webpack-dev-server --open",
      "build": "webpack"
    },
    ```

* Open `Solved/webpack.config.js` in your IDE to demonstrate the following:

  * Now that we have our script to start the server and have installed the `webpack-dev-server` package, we need to add a `devServer` object to our `webpack.config.js` file.

  * The `devServer` object contains all of the configuration options for our development server, which gets invoked by the `dev` command.

  * We added a `hot` property to the `devServer` object in `webpack.config.js` and set its value to `only`.

  * ğŸ”‘ The hot attribute is a `webpack-dev-server` feature that allows us to use HMR. Additionally, we set this value to `only` so that we can use HMR without a full page refresh, as shown in the finished `webpack.config.js` snippet.

    ```js
    module.exports = {
      // Truncated webpack.config.js
      devServer: {
        hot: true,
        static: './dist',
      },
    }
    ```

* Open `Solved/src/index.js` in your IDE to demonstrate the following:

  * ğŸ”‘ Even though we have set up HMR, it is by default an opt-in feature. In order to take advantage of it, we need to update the `index.js` file to accept hot modules.

  * This code is added at the bottom of the `index.js` file, but it can be added anywhere in the file. We first check to see if `module.hot` is defined. If it is, we accept hot modules by calling `module.hot.accept()` method, as shown in the following `index.js` snippet:

    ```js
    if (module.hot) {
      module.hot.accept((err) => {
        if (err) {
          console.error('Cannot apply HMR update.', err);
        }
      });
    }
    ```

  * You don't need to accept hot modules in every file, as changes will bubble up to a file that does accept hot modules. For example, if you make a change to `style.css` and save it, the changes will be reflected in the browser because `style.css` is imported in `index.js`. The same is true for JavaScript files.

* Navigate to `12-Stu_WebPack-HMR/Solved` in your terminal and run `npm i && npm run dev` and demonstrate the following:

  * With the development server running, we can now make changes to our `style.css` file and see the changes reflected in the browser.

  * In `Solved/src/css/style.css`, change the font weight of the `h1` element to `bold`. Notice that when you save, the page is updated in the browser without a full page refresh. You can also see the exact modules that were updated in the browser's console as you refresh the page, as shown in the following snippet:

    ```console
    log.js:24 [HMR] Waiting for update signal from WDS...
    index.js:519 [webpack-dev-server] Hot Module Replacement enabled.
    index.js:519 [webpack-dev-server] Live Reloading enabled.
    ```

* Ask the class the following questions (â˜ï¸) and call on students for the answers (ğŸ™‹):

  * â˜ï¸ Why is knowing how to use Hot Module Replacement helpful when creating a webpack project?

  * ğŸ™‹ Using HMR prevents us from having to rebuild the entire project every time we make a change. It also allows us to make changes to the code without having to restart the server.

  * â˜ï¸ What can we do if we don't completely understand this?

  * ğŸ™‹ We can refer to supplemental material, read the [Webpack docs on Hot Module Replacement](https://webpack.js.org/guides/hot-module-replacement/#enabling-hmr), and attend Office Hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 5. Instructor Demo: Workbox Service Workers (5 min)

* Navigate to `13-Ins_WorkBox-Service-Workers` in your terminal, run `npm i && npm run dev`, and demonstrate the following:

  * ğŸ”‘ When we run the application, the first thing you will notice is that unlike the previous activities, this one doesn't use or require webpack. Instead, we see a simple message that our server is running on port `3000`.

  * This demo is a very simple page that contains a card with a title, a description, and an image. It also features a service worker that is running in the background.

  * ğŸ”‘ This demo is very similar to other simple Express applications that we have created in the past, with one key distinction. This application uses a service worker written in plain Javascript to cache the application's assets.

  * **Important**: There are two ways to create a service worker. One is to create it manually using the steps found on MDN, and the other is to use the [workbox](https://developers.google.com/web/tools/workbox/modules/workbox-webpack-plugin) plugin. While we will use workbox in the next activity, it is important that we take a look at how to create a service worker manually.

* Open `src/sw.js` in your IDE to demonstrate the following:

  * This is a service worker that runs in the background and caches the assets that we are using. Services respond to different events, much like a button or input field.

  * In the browser, you can click on the Application tab and see that the service worker is running and what status it is in.

  * There are generally three stages in the service worker life cycle:

    1. Install: When the service worker is installed, it will cache the assets that we are using.

    2. Activate: The phase in which the service worker is activated. This is the phase in which the service worker is ready to handle events.

    3. Claim: The phase when the service worker is claiming the clients that are using it.

  * This particular service worker is also a cache-first strategy, meaning that it will first check to see if the assets are in the cache before trying to fetch them from the network, as show in the following snippet:

    ```js
    self.addEventListener('fetch', (e) =>
      e.respondWith(caches.match(e.request).then((res) => res || fetch(e.request)))
    );
    ```

  * While knowing how to create a service worker from scratch can be beneficial, in this unit we are going to take a look at how to generate a service worker using workbox.

  * Service workers, regardless of whether or not they were made using plain Javascript or generated using workbox, all need to be registered at the entry point for your application. In our case, this file is `index.js`.

* Open `src/index.js` in your IDE to demonstrate the following:

  * Typically, all one needs to do in order to register a service worker is check to see if they are supported in the browser, and then use the `navigator.serviceWorker.register()` method to register the worker in the browser, as shown in the following code snippet:

    ```js
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker
        .register('./sw.js')
        .then((register) => console.log(register));
    }
    ```

* Ask the class the following questions (â˜ï¸) and call on students for the answers (ğŸ™‹):

  * â˜ï¸ What do service workers do?

  * ğŸ™‹ Service workers are a way to cache assets that are used in the application, and are used to speed up the application's loading time.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `14-Stu_WorkBox-Service-Workers/README.md`.

### 6. Student Do: Workbox Service Workers (15 min)

* Direct students to the activity instructions found in `14-Stu_WorkBox-Service-Workers/README.md`, which are also shown below.

* To get a better understanding of how to create a service worker with a framework, we will be using the [workbox](https://developers.google.com/web/tools/workbox/modules/workbox-webpack-plugin) plugin for webpack.

* Break your students into pairs that will work together on this activity.

  ```md
  # ğŸ“ Add Comments to Implementation of a Workbox Service Worker

  Work with a partner to add comments that describe the functionality of the code found in [index.js](./Unsolved/src/index.js) and [webpack.config.js](./Unsolved/webpack.config.js).

  ## ğŸ“ Notes

  Refer to the documentation:

  * [Workbox Service Worker](https://developers.google.com/web/tools/workbox/reference-docs/latest/module-workbox-webpack-plugin.GenerateSW)

  ## ğŸ† Bonus

  If you have completed this activity, work through the following challenge with your partner to further your knowledge:

  * Why don't JavaScript modules work inside service workers?

  Use [Google](https://www.google.com) or another search engine to research this.
  ```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students who need extra help.

### 7. Instructor Review: Workbox Service Workers (10 min)

* Ask the class the following questions (â˜ï¸) and call on students for the answers (ğŸ™‹):

  * â˜ï¸ How comfortable do you feel with service workers in general? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use Office Hours to get extra help.

* Use the prompts and talking points (ğŸ”‘) below to review the following key points:

  * âœ”ï¸ `GenerateSW`

  * âœ”ï¸ `Workbox()`

* Open `Solved/webpack.config.js` in your IDE to demonstrate the following:

  * ğŸ”‘ To make workbox generate a service worker when the application is built, we will use the `GenerateSW` plugin.

  * ğŸ”‘ `GenerateSW` is a method that supports creating a new service worker file as part of the webpack build process.

  * ğŸ”‘ To use the `GenerateSW` plugin, we need to import it and add it to our webpack configuration. Because the entire plugin is rather large, we will destructure it into a variable called `generateSW`.

    ```js
    const path = require('path');
    const HtmlWebpackPlugin = require('html-webpack-plugin');

    // Import workbox-webpack-plugin
    const { GenerateSW } = require('workbox-webpack-plugin');
    ```

  * ğŸ”‘ In our exported object, we add a new entry to the `plugins` array that invokes the `GenerateSW` constructor, which accepts a configuration object.

  * ğŸ”‘ In our case, we added an option called `clientsClaim`, which instructs the service worker to claim the clients that are using it.

  * ğŸ”‘ Note that this aligns with the "claim" phase, or the last step in the service worker life cycle. This is similar to the `clients.claim()` method in our plain JavaScript service worker.

    ```js
    plugins: [
      new HtmlWebpackPlugin({
        title: 'Dev.to Posts',
        template: './index.html',
      }),
      new GenerateSW({
        clientsClaim: true,
        skipWaiting: true,
      }),
    ],
    ```

  * In terms of webpack configuration, this is all we need to do to generate a service worker.

  * The setup is so much easier than writing a plain JavaScript service worker from scratch in the previous activity. This is the benefit of using workbox, and this is just the beginning of what workbox can do!

* Open `Solved/src/index.js` in your IDE to demonstrate the following:

  * Much like we did with the plain JavaScript service worker, we still need to register the service worker that gets created by `GenerateSW`.

  * ğŸ”‘ At the top of the file, we import a constructor called `Workbox` from the `workbox-window` library. This is a class that aids in handling service worker registration, updates, and reacting to service worker life-cycle events. The import should appear as it does in the following code snippet:

    ```js
    import { Workbox } from 'workbox-window';
    ```

  * ğŸ”‘ To register, we need to check to make sure service workers are supported in the browser. If they are, we use the `new Workbox()` constructor and assign it a variable called `wb`.

  * ğŸ”‘ The `wb` variable is an instance of the `Workbox` class, meaning that we inherit all of the methods and properties of the class, one of which is `wb.register()`. This method is used to register the service worker, as shown in the following code snippet:

    ```js
    if ('serviceWorker' in navigator) {
      const wb = new Workbox('/service-worker.js');
      logger('Service Worker', 'GenerateSW Service Worker is ready', wb);

      wb.register();
    }
    ```

  * ğŸ”‘ This method accepts a path to the service worker file. You may be wondering why we don't see a service worker file in the IDE. This is because we will be using the `webpack-dev-server` to build our application and serve it on the fly.

  * ğŸ”‘ When it comes time to actually building your application by using a command like `npm run build`, you will see a service worker file in the `dist` directory. The resulting files will look like this:

    ```sh
    .
    â”œâ”€â”€ index.bundle.js
    â”œâ”€â”€ index.html
    â”œâ”€â”€ service-worker.js
    â””â”€â”€ workbox-9cb17bc4.js
    ```

  * Now that we have reviewed the service worker, let's test our application in the browser.

* Navigate to `14-Stu_WorkBox-Service-Workers/Solved` in your terminal and run `npm i && npm run dev`. This will install the dependencies and run the development server.

  * When we run the application, the browser will open automatically and we will be taken to a page featuring some articles from the web development site [Dev.to](https://dev.to).

  * Open the browser's developer tools to see the service worker registration. Additionally, you can see the messages coming from workbox itself with regards to registration, updates, and life cycle events.

* Ask the class the following questions (â˜ï¸) and call on students for the answers (ğŸ™‹):

  * â˜ï¸ What is the difference between using workbox and plain JavaScript service workers?

  * ğŸ™‹ The benefits of using workbox is that it is so much easier to understand and use. It's a great way to get started with service workers without having to write a plain JavaScript service worker from scratch.

  * â˜ï¸ What can we do if we don't completely understand this?

  * ğŸ™‹ We can refer to supplemental material, read the [Workbox docs on GenerateSW](https://developers.google.com/web/tools/workbox/reference-docs/latest/module-workbox-webpack-plugin.GenerateSW), and attend Office Hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 8. Instructor Demo: Cache CSS and JavaScript Files (5 min)

* Navigate to `15-Ins_Caching` in your terminal and run `npm i && npm run dev`. This will install the dependencies and start the development server.

* **Important:** Unlike the previous instructor demos, this one will not open the browser automatically. This is by design so that you can see the caching strategy messages in the console as the page loads for the first time.

* Open a new incognito window in your browser and then open the developer console in the new window. Once you have the window open with the developer console in view, navigate to `http://localhost:8080`.

  * ğŸ”‘ When we run this application, we see a page with a few modules being loaded, as we saw with the Hot Module Replacement activity. This isn't the interesting part, however.

  * ğŸ”‘ As the page loads, we can see some messages in the console that tell us what is happening in response to our caching strategy.

  * ğŸ”‘ In order to take advantage of these caching strategies, we will use a new method to generate the service worker called `InjectManifest`. This method is used to inject a manifest file into the service worker on the fly.

  * ğŸ”‘ `InjectManifest`, much like the `GenerateSW` method, accepts a configuration object and is added to the `plugins` array in our webpack configuration, as shown in the webpack configuration snippet below:

    ```js
     plugins: [
    new HtmlWebpackPlugin({
        title: 'Caching',
        template: './index.html',
      }),
      new InjectManifest({
        swSrc: './src/sw.js',
      }),
    ],
    ```

  * ğŸ”‘ On the initial load, we see messages in the console that tell us that there was no cached response found in `static-resources`. This is in part because of the caching strategy we are using, as shown in the following snippet:

    ```console
    workbox | Router is responding to: https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css
    workbox | Router is responding to: https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js
    workbox | Using StaleWhileRevalidate to respond to 'https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css'
    workbox | Using StaleWhileRevalidate to respond to 'https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js'
    workbox | Router is responding to: /index.bundle.js
    ```

  * ğŸ”‘ This kind of response is expected for the first visit because our current caching strategy checks to see if we have a cached response to return first. Because we don't have a cached response to return, we will have to fetch the resource from the network.

  * ğŸ”‘ This kind of strategy is called the `StaleWhileRevalidate` caching strategy. This strategy will first check to see if there is a cached response, and if there is, it will return that response. Otherwise, it will fetch the response from the network and update the cache.

  * ğŸ”‘ On subsequent visits, we will see a message in the console that tells us that we have a cached response in `static-resources`. This is a result of the cached response being returned, as shown in the following screenshot:

    ```console
    workbox | Using StaleWhileRevalidate to respond to 'https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css'
    logger.js:50 | Found a cached response in the 'static-resources' cache. Will update with the network response in the background.
    ```

* Ask the class the following questions (â˜ï¸) and call on students for the answers (ğŸ™‹):

  * â˜ï¸ Why does the `StaleWhileRevalidate` strategy sound like a good choice for static assets on a webpage?

  * ğŸ™‹ `StaleWhileRevalidate` is a good choice for static assets because it allows us to respond quickly from the cache, but also update resources in the background.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `16-Stu_Caching`.

### 9. Student Do: Cache CSS and JavaScript Files (15 min)

* Direct students to the activity instructions found in `16-Stu_Caching/README.md`, which are also shown below.

* Break your students into pairs that will work together on this activity.

  ```md
  # ğŸ“– Implement Caching for CSS and JS Files

  Work with a partner to implement the following user story:

  * As a developer, I want to cache the CSS and JS files so that I don't have to download them every time I load a page.

  * As a developer, I want to implement workbox caching strategies so that I can improve the performance of the app.

  ## Acceptance Criteria

  * It is done when I have imported `injectManifest` using destructuring assignment from the `workbox-webpack-plugin` inside the `webpack.config.js` file.

  * It is done when I have registered a new Wqorkbox service worker inside the `src/index.js` file using the `Workbox` constructor.

  * It is done when I have added a new `InjectManifest` plugin to the `plugins` array in `webpack.config.js`.

  * It is done when I have specified the `swSrc` and `swDest` properties in the `InjectManifest` constructor in the `plugins` array in `webpack.config.js`.

  * It is done when I have registered a route for the caching of static assets (e.g., JavaScript, HTML, CSS) by using a `staleWhileRevalidate` strategy for files that aren't pre-cached, by matching against the destination of the incoming request. This is done in the `src/sw.js` file.

  ## ğŸ“ Notes

  Refer to the documentation:

  * [Google docs on common recipes](https://developers.google.com/web/tools/workbox/guides/common-recipes)

  ## ğŸ’¡ Hints

  * What does the `staleWhileRevalidate` strategy do? Is there another strategy that could be used?

  * What are some different methods of matching files that we want to cache? How can we use the `destination` property on the `request` object to our advantage?

  ## ğŸ† Bonus

  If you have completed this activity, work through the following challenge with your partner to further your knowledge:

  * What is the difference between `GenerateSW` and `InjectManifest`?

  Use [Google](https://www.google.com) or another search engine to research this.
  ```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students who need extra help.

### 10. BREAK (15 min)

### 11. Instructor Review: Cache CSS and JavaScript Files (10 min)

* Ask the class the following questions (â˜ï¸) and call on students for the answers (ğŸ™‹):

  * â˜ï¸ How comfortable do you feel with caching JS and CSS files? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use Office Hours to get extra help.

* Use the prompts and talking points (ğŸ”‘) below to review the following key points:

  * âœ”ï¸ `injectManifest`

  * âœ”ï¸ Caching strategies

  * âœ”ï¸ `swSrc`

* Open `16-Stu_Caching/Solved/webpack.config.js` in your IDE and explain the following:

  * To have proper caching, we need to use a caching strategy. And to use a caching strategy, we need to generate a service worker using the `InjectManifest` plugin.

  * ğŸ”‘ The `InjectManifest` plugin is used to inject a manifest file into the service worker on the fly. We start off by importing it into our webpack config.

    ```js
    const path = require('path');
    const HtmlWebpackPlugin = require('html-webpack-plugin');
    const { InjectManifest } = require('workbox-webpack-plugin');
    ```

* Open `src/index.js` in your IDE to demonstrate the following:

  * As with all service workers, we need to register a service worker in our `src/index.js` file. We start off by registering a new `Workbox` service worker.

    ```js
    if ('serviceWorker' in navigator) {
      const wb = new Workbox('/sw.js');

      wb.register();
    }
    ```

* Open `16-Stu_Caching/Solved/webpack.config.js` in your IDE and explain the following:

  * Now that we have the logic to register our service worker, and we imported the `InjectManifest` plugin, we need to add the `InjectManifest` plugin to our `plugins` array.

  * ğŸ”‘ One of the options that we can pass to the `InjectManifest` constructor is the `swSrc` property. This property specifies the location of the service worker file that contains our own custom code for caching.

  * Here is a sample of the the `InjectManifest` plugin in the `plugins` array:

    ```js
    plugins: [
      new HtmlWebpackPlugin({
        title: 'Caching',
        template: './index.html',
      }),

      new InjectManifest({
        swSrc: './src/sw.js',
      }),
    ],
    ```

* Open `Solved/src/sw.js` in your IDE to demonstrate the following:

  * The service worker is where all of our logic for caching assets is located. We can see that the starer code already has the `StaleWhileRevalidate` caching strategy imported for us.

  * The `StaleWhileRevalidate` strategy will try to serve the cached version of the resource if it is available, but if the cached version is not available, it will make a network request, serve the asset, and store the cached version of the resource in the background.

  * With the `StaleWhileRevalidate` strategy, every request that is served from the cache is accompanied by a request to the server to check and see if a newer version is available. If a newer version is available, the cached version is updated and served to the user on the next request.

  * We match the assets by using the `destination` property on the `request` object. This property is a string that contains the path to the asset. In our case, we are looking for those destinations that include style or script files, as shown in the handler below:

    ```js
    const matchCallback = ({ request }) => {
      return (request.destination === 'style' || request.destination === 'script' );
    };
    ```

  * Next, we have to register the route in our service worker. We do this by using the `staleWhileRevalidate` constructor.

    ```js
    registerRoute(
      matchCallback,
      new StaleWhileRevalidate({
        cacheName,
        plugins: [
          // This plugin will cache responses with these headers to a maximum-age of 30 days
          new CacheableResponsePlugin({
            statuses: [0, 200],
          }),
        ],
      })
    );
    ```

* Ask the class the following questions (â˜ï¸) and call on students for the answers (ğŸ™‹):

  * â˜ï¸ How does the `StaleWhileRevalidate` caching strategy work?

  * ğŸ™‹ The `StaleWhileRevalidate` will try to serve the cached version of the resource if it is available, but if the cached version is not available, it will make a network request, serve the asset and store the cached version of the resource in the background.

  * â˜ï¸ What can we do if we don't completely understand this?

  * ğŸ™‹ We can refer to supplemental material, read the [Google docs on common recipes](https://developers.google.com/web/tools/workbox/guides/common-recipes), and attend Office Hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 12. Instructor Demo: Caching Images (5 min)

* Navigate to `17-Ins_Caching-Images` in your terminal and run `npm i && npm run dev`. This will install the dependencies and start the development server.

  * ğŸ”‘ When we run the `npm run dev` command, we can see in the browser that our demo is now serving images inside two of the modules.

  * ğŸ”‘ This demo also uses the `InjectManifest` plugin to inject a manifest file into the service worker on the fly.

  * ğŸ”‘ The key difference, however, is that we are now using the `CacheFirst` caching strategy.

  * ğŸ”‘ This strategy is very straightforward and does what the name suggests. The service worker will always look first to the cache and fall back to the network if a cached version is not available.

  * ğŸ”‘ The `CacheFirst` strategy is a perfect choice for optimizing repetitive requests, since it only reaches out to the network for "fresh" assets.

* Ask the class the following questions (â˜ï¸) and call on students for the answers (ğŸ™‹):

  * â˜ï¸ How would we build this?

  * ğŸ™‹ Building a route for images is very similar to building a route for CSS and JavaScript files. The only difference is that we match the `images` destination and invoke the `CacheFirst` constructor when registering the route.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `18-Stu_Caching-Images/README.md`.

### 13. Student Do: Caching Images (15 min)

* Direct students to the activity instructions found in `18-Stu_Caching-Images/README.md`, which are also shown below.

* Break your students into pairs that will work together on this activity.

  ```md
  # ğŸ› Images Are Not Being Cached Properly

  Work with a partner to resolve the following issue:

  * As a developer, I want to be able to rely on the browser to cache images so that I can create a faster application for the end user.

  ## Expected Behavior

  The browser should load images almost instantly from the cache and not need to download fresh images from the server. You can verify that the cache is working properly by opening the developer console, clicking the Application tab in DevTools and looking for a cache name of `my-image-cache`. Additionally, on subsequent visits to the application, network requests for images will be responded to by the service worker with a 200 response.

  ## Actual Behavior

  When a user visits the page after the first time, the browser is still making network requests to the server to retrieve the images.

  ## Steps to Reproduce the Problem

  To reproduce the problem, follow these steps:

  1. Start the dev server by running `npm run dev`.

  2. Open a new browser tab and navigate to `http://localhost:3000/`.

  3. Open Chrome DevTools, click the Network tab, and notice that there are multiple requests to the server for the images that were not cached.

  ## Assets

  The following image demonstrates the properly functioning network requests to the cache:

  ![Network tab of chrome based browser showing 200 status codes](./Images/network.png)

  ---

  ## ğŸ’¡ Hints

  What is a cache miss and how can we use the advanced recipe to resolve this issue?

  ## ğŸ† Bonus

  If you have completed this activity, work through the following challenge with your partner to further your knowledge:

  * What is the Cache Storage API? How do we use it?

  Use [Google](https://www.google.com) or another search engine to research this.
  ```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students who need extra help.

### 14. Instructor Review: Caching Images (10 min)

* Ask the class the following questions (â˜ï¸) and call on students for the answers (ğŸ™‹):

  * â˜ï¸ How comfortable do you feel with caching images using Workbox? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use Office Hours to get extra help.

* Use the prompts and talking points (ğŸ”‘) below to review the following key points:

  * âœ”ï¸ `CacheFirst`

  * âœ”ï¸ `ExpirationPlugin`

* Open `18-Stu_Caching-Images/Solved/src/sw.js` in your IDE and explain the following:

  * ğŸ”‘ In order to cache images, we need to use the `CacheFirst` caching strategy. This strategy needs to be imported from the `workbox-strategies` package. We added this on to our existing import for the `staleWhileRevalidate` strategy.

    ```js
    import { StaleWhileRevalidate, CacheFirst } from 'workbox-strategies';
    ```

  * ğŸ”‘ The `CacheFirst` strategy is a good choice for images because the same images are often requested multiple times in a short period of time.

  * To use the `CacheFirst` strategy, we need to register the route with the `CacheFirst` constructor. We can do this by using the `registerRoute` method.

  * Any requests that have a destination of `images` will be handled by the `CacheFirst` strategy.

    ```js
    registerRoute(
      ({ request }) => request.destination === 'image',
        new CacheFirst({})
      );
    ```

  * ğŸ”‘ The `ExpirationPlugin` is a plugin that will automatically remove stale assets from the cache. This plugin needs to be imported from the `workbox-expiration` package.

    ```js
    import { ExpirationPlugin } from 'workbox-expiration';
    ```

  * The `ExpirationPlugin` will be included inside the `CacheFirst` constructor and will accept a cache name and a number of options.

  * We also provided some options to the `ExpirationPlugin` constructor. We can use the `maxAgeSeconds` option to set the maximum age of the asset in the cache. This will remove assets that are older than the specified number of seconds.

  * We can also use the `maxEntries` option to set the maximum number of assets that can be stored in the cache. This will prevent the cache from growing too large.

    ```js
      new CacheFirst({
      cacheName: 'my-image-cache',
      plugins: [
        new ExpirationPlugin({
          maxEntries: 60,
          maxAgeSeconds: 30 * 24 * 60 * 60, // 30 Days
        }),
      ],
    })
    ```

  * Let's test our work by running the `npm i && npm run dev` command again from the root of the `/Solved` directory. This time, we can see that the images are now being cached. Specifically, after a few refreshes, the browser will show a new cache called `my-image-cache` that contains the images.

* Ask the class the following questions (â˜ï¸) and call on students for the answers (ğŸ™‹):

  * â˜ï¸ What are some challenges that you encountered with caching images?

  * ğŸ™‹ Caching images can be difficult to troubleshoot due to cors issues. We can use the `cors-anywhere` package to proxy requests to the server, or we can make sure that the images are served from the same domain as the server.

  * â˜ï¸ What can we do if we don't completely understand this?

  * ğŸ™‹ We can refer to supplemental material, read the [Workbox docs on caching images](https://developers.google.com/web/tools/workbox/guides/common-recipes), and attend Office Hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 15. Instructor Demo: Client-Server Model (5 min)

* Navigate to `19-Ins_Client-Server` in your terminal and run `npm i` to install all dependencies and demonstrate the following:

  * Instead of opening the browser right away, run `npm run` to list the available commands.

  * Notice that the list of available commands reflects the scripts that are defined in the `package.json` file.

  * ğŸ”‘ If we run `ls` in the terminal, we should also see that this demo is split up into two directories: `client` and `server`. Both of which have their own `package.json` files, in addition to the `package.json` file for the root directory.

  * ğŸ”‘ We have two directories because we want to separate our front-end code from our back-end code in order to prepare for the future. This separation will allow us to create a more modular and reusable codebase, especially when we start working with React or any other front-end framework that uses a bundler such as webpack.

  * ğŸ”‘ One thing we need to think about is deployment. Let's say that we have an application that has an Express server and a front-end client. We would need some way to spin up the server and the client on the same machine using a single command, while also having the server and client running on different ports.

  * ğŸ”‘ We can use the `concurrently` command to run multiple commands at the same time.

  * In the next activity, we will learn how to use the `concurrently` command to run multiple commands at the same time.

* Ask the class the following questions (â˜ï¸) and call on students for the answers (ğŸ™‹):

  * â˜ï¸ How would we build this?

  * ğŸ™‹ We would start by moving our entire application into a single directory called `client`. We would then create a new directory called `server` and add a simple Express.js server to it. Finally, we could update our `package.json` file to include the `concurrently` package and update our `start` script to run the `concurrently` command.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `20-Stu_Client-Server/README.md`.

### 16. Student Do: Client-Server Model (15 min)

* Direct students to the activity instructions found in `20-Stu_Client-Server/README.md`, which are also shown below.

* Break your students into pairs that will work together on this activity.

  ```md
  # ğŸ—ï¸ Start the Client and Back-End Servers Simultaneously

  Work with a partner to implement the following user story:

  * As a developer, I want to be able to start the client and back-end servers simultaneously so that I can test the full application, not just the client.

  ## Acceptance Criteria

  * It is done when I have moved the existing code into a new `client` folder.

  * It is done when I have created a simple Express server in the `server` folder.

  * It is done when I have added a single static HTML route that serves the contents of the `client/dist/index.html` file.

  * It is done when I have installed the `concurrently` npm package at the root of the project.

  * It is done when I have configured the npm scripts in the root `package.json` to run both servers using `concurrently`.

  * It is done when I am able to start the client and the backend server concurrently by running `npm start`.

  ---

  ## ğŸ’¡ Hints

  * `concurrently` can also be configured to shorten npm commands. How can we include this in our solution?

  * Remember to close any other servers that you may have running to free up the needed ports.

  ## ğŸ† Bonus

  If you have completed this activity, work through the following challenge with your partner to further your knowledge:

  * What is a proxy server?

  Use [Google](https://www.google.com) or another search engine to research this.
  ```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students who need extra help.

### 17. Instructor Review: Client-Server Model (15 min)

* Ask the class the following questions (â˜ï¸) and call on students for the answers (ğŸ™‹):

  * â˜ï¸ How comfortable do you feel with the client server model? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use Office Hours to get extra help.

* Use the prompts and talking points (ğŸ”‘) below to review the following key points:

  * âœ”ï¸ `express`

  * âœ”ï¸ `ports`

  * âœ”ï¸ Separate `client` and `server` directories

* Navigate to `20-Stu_Client-Server` in your terminal and run `npm i && npm run dev`. This will install the dependencies and start the development server.

  * ğŸ”‘ When we run this command, we notice that our terminal beings to start both the client's start command and the backend Express.js server.

    ```console
    concurrently "cd server && npm run server" "cd client && npm run dev"
    ```

  * ğŸ”‘ We can see that because of our root level `dev` command, we invoke `concurrently` to run both the client and the backend server at the same time.

  * The server is navigated to first, and then the `npm run server` command is invoked. This will start the Express server and listen on port `3000`.

* Open `Solved/server/server.js` in your IDE to demonstrate the following:

  * Notice that the static HTML route is configured to serve the contents of the `client/dist` directory.

     ```js
     const express = require('express');

     const app = express();
     const PORT = process.env.PORT || 3000;

     app.use(express.static('../client/dist'));
     app.use(express.urlencoded({ extended: true }));
     app.use(express.json());

     require('./routes/htmlRoutes')(app);

     app.listen(PORT, () => console.log(`Now listening on port: ${PORT}`));
     ```

  * ğŸ”‘ Remember that the `dist` directory is the output of our webpack build.

  * There is also a single HTML route that serves the contents of the `client/dist/index.html` file.

     ```js
     module.exports = (app) =>
       app.get('/', (req, res) =>
         res.sendFile(path.join(__dirname, '../client/dist/index.html'))
       );
     ```

* Open `Solved/package.json` in your IDE to demonstrate the following:

  * Now let's review the other half of our `concurrently` command , `cd client && npm run start`. In this case, the `npm run` command will invoke the `webpack && webpack-serve` command to build the client's application and run a server that watches for changes.

  * The resulting `dist` directory is the output of our webpack build.

  * ğŸ”‘ We already set up an Express.js server in the `server` directory, which will serve the static HTML file found in the `client/dist` directory, so we don't need to do anything else.

  * ğŸ”‘ **Important:** You may be asking yourself, "Why don't we just run the `npm run dev` command in the `client` directory?" The answer is that the `webpack-dev-server` is meant to be a tool for development, and not a replacement for a production server. Additionally, running two servers with one bash command makes it hard to keep track of different outputs. For example, if one process fails, others still keep running and you won't even notice the difference.

* Run `npm start` from the root of the `Solved` directory and visit `http://localhost:3000` in your browser to demonstrate the final result.

* Notice that our application is now running just as it did before, but now we have the infrastructure to run both the client and the backend server at the same time if we wanted to.

* Ask the class the following questions (â˜ï¸) and call on students for the answers (ğŸ™‹):

  * â˜ï¸ How does concurrent server/client development work?

  * ğŸ™‹ The idea is that we can run both the client and the backend server at the same time when developing, and when it comes time to deploy, we can run the build command for the client, and then the server command for the backend.

  * â˜ï¸ What can we do if we don't completely understand this?

  * ğŸ™‹ We can refer to supplemental material, read the [Open-CLI Docs on concurrently](https://github.com/open-cli-tools/concurrently), and attend Office Hours to ask for help.

* Answer any questions before ending the class.

### 18. END (0 min)

How did todayâ€™s lesson go? Your feedback is important. Please take 5 minutes to complete this [anonymous survey](https://forms.gle/RfcVyXiMmZQut6aJ6).

---
2021 Trilogy Education Services, LLC, a 2U, Inc. brand. Confidential and Proprietary. All Rights Reserved.
